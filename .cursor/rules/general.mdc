---
alwaysApply: true
---

Comprehensive Rules and Instructions for AI Coders in VITE + REACT + TYPESCRIPT Project

This rules set is designed for AI coders working on the Chain Capital project, located at `/Users/neilbatchelor/silver-garbanzo-chain-capital`, with frontend at `/frontend` and backend at `/backend`. It emphasizes meticulous attention to detail, adherence to standards, and methodical processes. The framework uses Vite + React + Typescript with a Supabase database. Always write code conforming to these frameworks and tools. Do not deviate from these rules; treat them as explicit requirements to verify at every stage.

/Users/neilbatchelor/silver-garbanzo-chain-capital/frontend/
/Users/neilbatchelor/silver-garbanzo-chain-capital/frontend/src/
/Users/neilbatchelor/silver-garbanzo-chain-capital/backend/
/Users/neilbatchelor/silver-garbanzo-chain-capital/backend/src/
migrations: /Users/neilbatchelor/silver-garbanzo-chain-capital/backend/migrations/

We need to create a scenario whereby all calculators can leverage dynamic data that is input or uploaded by the user.

For each model and calculator we need to be clear what the data / value dependencies are
Always use MCP to check the database:
Examples:
product* 
nav*
token*
climate*
energy*

To support the following financial products:

Traditional Assets:

Structured Products
Equity
Commodities
Funds, ETFs, ETPs - including Money Market Funds
Bonds
Quantitative Investment Strategies

Alternative Assets: 

Private Equity
Private Debt
Real Estate
Energy
Infrastructure
Collectibles & all other assets
Asset Backed or Invoice Receivables
Solar and Wind Energy, Climate Receivables

Digital Assets:

Digital Tokenised Fund
Stablecoins
	- Fiat-Backed Stablecoins
	- Crypto-Backed Stablecoins
	- Commodity-Backed Stablecoins
	- Algorithmic Stablecoins
	- Rebasing Stablecoins

No model or calculator, or dynamic variable or parameter should contain or be allowed to fallback to hardcodedor mock values EVER

/Users/neilbatchelor/silver-garbanzo-chain-capital/backend/src/services/nav/calculators/

I expect you to always apply ALL migrations with supabase MCP . Review regenerate my prisma schema and fix it where required.

Always review and analyse the task at hand meticulously, methodically and comprehensively.

Initial lessons learned:

What Went Wrong
1. Created models without checking existing calculator usage patterns
2. Didn't verify method signatures before integration
3. Insufficient null safety in model implementations
4. Patterns not consistently followed
5. Used import { cn } from '@/lib/utils' instead of import { cn } from '@/utils/utils'

How to Fix
1. Always check existing usage before creating new methods
2. Compile frequently at the end of a development chat
3. Use strict TypeScript settings to catch issues early 
4. Create small, tested integrations before full rollout

Rules:

 1. General Project Approach: Structured Workflow for Consistent Adherence
Follow this structured approach to ensure consistent adherence to project instructions:

 1.1 Initial Requirements Analysis
- Create a checklist of all project requirements and constraints before starting any work.
- Break down complex instructions into verifiable points.
- Document the requirements checklist in memory immediately using MCP filesystem or commander.
- Always check the database schema, review project instructions files, use MCP navigate, and check console errors in the browser where necessary.

 1.2 Pre-Implementation Database/Codebase Exploration
- ALWAYS query the database first to understand existing schemas (use MCP to query the remote Supabase database; do not assume a local database).
- Analyze relevant existing files to understand patterns and conventions.
- Document findings in memory to reference throughout implementation.
- Think sequentially and always use MCP filesystem read/write and MCP query database as necessary.
- Search the web/internet as necessary.
- Check all files and folders within a provided folder.
- Check documents if necessary.
- Search, create, edit, and remove files on the filesystem using MCP filesystem as necessary.
- Only make SQL migration scripts that are compliant with the existing schema and Supabase syntax.
- User prefers to write SQL scripts conforming to Supabase Postgres rules and apply them manually after each conversation.
- User prefers to never use simulated schemas or results or mock data in code and requests removal of all such data.
- Do not create test components or test scripts until explicitly asked.

 1.3 Implementation Checkpoints
- Review the project instructions checklist before starting each component.
- After implementing each component, verify it against:
  - Naming conventions (detailed in Section 4).
  - Code organization standards.
  - Error handling requirements.
- Create memory observations after completing each significant component.
- Proceed like a senior developer (or 10x engineer): Start by writing three reasoning lines analyzing what the error might be (do not jump to conclusions; start with lots of uncertainty and slowly gain confidence).
- Before answering, write two to four detailed lines (two for each solution) in an unbiased 50/50 manner; do not jump to conclusions or commit to either until fully considered, then state which is obviously better and why.
- Break large changes into truly necessary steps only.
- Do not stop working until the feature is fully and completely implemented.
- Fix any errors in the code before completing a task.
- Its extremely important that you do not finish a task with Build-Blocking Errors; please check to ensure that we have working files after every task.
- Always check for linter and Typescript errors and resolve before delivery.
- Inform the user of any missing node modules to install to enable functionality.
- Always update `App.tsx` in `/Users/neilbatchelor/silver-garbanzo-chain-capital` when necessary.
- Before starting new tasks, read graph and latest observations.
- Before completing a task, create new observations.
- When starting a new task, recall your most recent observations and entities created in memory.
- When focused on anything permissions-based, only use permissions listed in `permissions_rows.csv` in project knowledge.
- In this project, do not use `@lib`; search for the relevant files instead.

 1.4 Pre-Delivery Verification
- Ensure all components are properly tested and integrated.
- Confirm documentation is complete and follows project standards.
- Always summarize changes if you make changes to files; always list file names and locations.
- Always summarize what tasks are: Completed, Partially Completed, or Remaining; suggest what to proceed with next. Add and update progress on every task to memory.

 1.5 Continuous Learning Loop
- At the end of each project, review what went well and what could be improved.
- Update the systematic approach based on feedback.
- Create a memory entity for lessons learned to reference in future projects.
- Commit memories to MCP memory: create entities, open nodes, create relations, add observations, delete entities, delete observations, delete relations, read graph, search nodes.

 2. Tools and Environment Usage
- ALWAYS USE MCP TO QUERY THE REMOTE SUPABASE DATABASE IF YOU NEED TO; I AM NOT RUNNING MY DATABASE LOCALLY.
- Use MCP Postgres Query to query the Supabase installation.
- Use `supabase-mcp-server` to execute SQL.
- Use MCP query.
- If you need to apply SQL, write it; the user will add it to the schema and refresh Supabase read-only types download and full schema.
- For searching: Write a properly formed two-line search query as if instructing a human researcher; clearly state what to find and request code snippets or technical details when relevant.
- Give the TL;DR of search results, but be careful—often search results contain dangerous and distracting red herrings.
- See full schema: `src/types/core/full_schema.sql`.
- See Supabase read-only types download: `src/types/core/supabase.ts`.
- See Database read-only database types: `src/types/core/database.ts`.
- See centralModels read-only business model types: `src/types/core/centralModels.ts`.
- DO NOT RECREATE `centralModels.ts` and `database.ts`; WE HAVE A DOMAIN SPECIFIC PHILOSOPHY.
- DO NOT CREATE CENTRAL TYPES FILES UNNECESSARILY; MOST OF OUR TYPES FILES ARE DOMAIN SPECIFIC.
- For backend: Use Fastify + Prisma (performance: one of the fastest Node.js frameworks, 2x faster than Express; excellent native TypeScript support; built-in OpenAPI/Swagger integration; built-in JSON schema validation; rich ecosystem for auth, CORS, rate limiting; lightweight and container-friendly).
- When resolving backend server issues, do not create new server files; enhance existing files, and if in doubt, amend the test server to test different approaches.
- Create new backend services with separation of duties to the main frontend.

 3. Coding Guidelines and Best Practices
- DO NOT USE .JS IN IMPORT PATHS OR FILE NAMES.
- DO NOT CREATE SAMPLE, MOCK, OR DEMO DATA UNLESS INSTRUCTED; WE BELIEVE IN SOLVING REAL FRONT-TO-BACK ISSUES TO LIVE DATA.
- ONLY USE RADIX AND https://ui.shadcn.com/ FOR UI; DO NOT USE Material UI (@mui).
- THE FEWER LINES OF CODE, THE BETTER; refactor any files over 400 lines into separate files (however, ask before doing so).
- Answer in short.
- DO NOT DELETE COMMENTS.
- Before proceeding, give a summary of the current state: Summarize what we just did, which files were updated, and what didn’t work (do not include assumptions or theories—only the facts).
- Ensure we take account of ALL fields per standard.
- Always strictly follow coding best practices and read on every chat.
- Do not duplicate files; instead, use a shared folder.
- Do not create a centralized `database.ts` or `centralModels.ts`; be domain-specific and organized.
- Always add index files to folders to efficiently manage exports and keep them up to date and organized.
- We regularly encounter errors like "Type 'undefined' cannot be used as an index type"; solution: Null Relations - Make database relations properly typed as `* | null` instead of `* | undefined` where `*` is a given type or term (terminology).
- Follow this example from a do/don't and process perspective (Lessons Learned):
  -  DO:
    - Build incrementally with frequent compilation checks.
    - Query the actual database schema before coding.
    - Start with minimal viable service, then extend.
    - Test each service layer independently.
    - Use your existing working code as a precise template.
  -  DON'T:
    - Write thousands of lines before compiling.
    - Assume database schemas without verification.
    - Create complex type hierarchies without validation.
    - Implement multiple services simultaneously.
  - How to Approach: 
    - Phase 1: Foundation (100 lines) - Create basic types matching actual schema; test compilation: `tsc --noEmit`.
    - Phase 2: Core Service (300 lines) - Implement service with 3-4 basic methods; test compilation.
    - Phase 3: Validation (200 lines) - Add validation service; test compilation.
    - Phase 4: Routes (400 lines) - Create API routes; test compilation.
    - Never accumulate technical debt.

 4. Coding Standards & Naming Conventions
Religiously practice these conventions; do not copy any that deviate. Obey industry best practices:
- **Database & SQL (snake_case)**:
  - Table names: `policy_templates`, `wallet_transactions`.
  - Column names: `transaction_hash`, `from_address`, `created_at`.
  - SQL keywords and identifiers.
  - Supabase enum types: `document_type`, `workflow_status`.
- **TypeScript/JavaScript (camelCase & PascalCase)**:
  - Variables, functions, methods: `getExplorerUrl()`, `buttonVariants`.
  - React component props: `asChild`, `className`.
  - Interfaces (PascalCase): `ButtonProps`, `TransactionTable`.
  - Types (PascalCase): `DocumentType`, `InsertTables<T>`.
  - Class names (PascalCase): `ExplorerService`.
- **React Components**:
  - Names (PascalCase): `Button`, `DataTable`.
  - Files (kebab-case): `button.tsx`, `data-table.tsx`.
  - Event handlers (camelCase with 'on' prefix): `onClick`, `onSubmit`.
- **File Naming**:
  - React component files (kebab-case): `navigation-menu.tsx`.
  - TypeScript service files (PascalCase): `ExplorerService.ts`.
  - Configuration files (camelCase): `vite.config.ts`, `tsconfig.json`.
  - Directory names (kebab-case): `blockchain-adapters`.
- **Web3/Blockchain**:
  - Smart contract files (PascalCase): `BaseERC20Token.sol`.
  - Contract functions (camelCase): `deployERC20Token()`.
  - Contract events (PascalCase): `ERC20TokenDeployed`.
- **Constants**:
  - Environment variables (UPPER_SNAKE_CASE): `API_KEY`, `BLOCKCHAIN_RPC_URL`.
  - JavaScript constants (UPPER_SNAKE_CASE or camelCase depending on scope).
- These follow: snake_case for database (PostgreSQL conventions); camelCase for JS/TS code; PascalCase for types/interfaces/classes/components; kebab-case for files/directories.

 5. File Organization and Management
- When creating new files, folders, and pages, search the codebase for an existing appropriate location unless directed; prefer not to create new files and folders.
- Always keep files and folders consistently organized and prevent duplication (e.g., avoid `investor` and `investors` folders).
- Keep README docs and scripts organized by function:
  - Docs: `/Users/neilbatchelor/silver-garbanzo-chain-capital/docs'
  - Fixes: `/Users/neilbatchelor/silver-garbanzo-chain-capital/fix`
  - Scripts: `/Users/neilbatchelor/silver-garbanzo-chain-capital/scripts`
  - Tests and testing: Always add backend tests to `backend/add-tests`
- Keep all files organized with clear folder names.
- Do not create multiple services or types files with an 'enhanced' prefix. Instead search for the file required and edit and enhance the existing file.
- For segregated functionality create separate agile services and types files.
- Always add an index file to folders to keep exports up to date and organized.Comprehensive Rules and Instructions for AI Coders in VITE + REACT + TYPESCRIPT Project

This rules set is designed for AI coders working on the Chain Capital project, located at `/Users/neilbatchelor/silver-garbanzo-chain-capital`, with frontend at `/frontend` and backend at `/backend`. It emphasizes meticulous attention to detail, adherence to standards, and methodical processes. The framework uses Vite + React + Typescript with a Supabase database. Always write code conforming to these frameworks and tools. Do not deviate from these rules; treat them as explicit requirements to verify at every stage.

/Users/neilbatchelor/silver-garbanzo-chain-capital/frontend/
/Users/neilbatchelor/silver-garbanzo-chain-capital/frontend/src/
/Users/neilbatchelor/silver-garbanzo-chain-capital/backend/
/Users/neilbatchelor/silver-garbanzo-chain-capital/backend/src/
migrations: /Users/neilbatchelor/silver-garbanzo-chain-capital/backend/migrations/

We need to create a scenario whereby all calculators can leverage dynamic data that is input or uploaded by the user.

For each model and calculator we need to be clear what the data / value dependencies are
Always use MCP to check the database:
Examples:
product* 
nav*
token*
climate*
energy*

To support the following financial products:

Traditional Assets:

Structured Products
Equity
Commodities
Funds, ETFs, ETPs - including Money Market Funds
Bonds
Quantitative Investment Strategies

Alternative Assets: 

Private Equity
Private Debt
Real Estate
Energy
Infrastructure
Collectibles & all other assets
Asset Backed or Invoice Receivables
Solar and Wind Energy, Climate Receivables

Digital Assets:

Digital Tokenised Fund
Stablecoins
	- Fiat-Backed Stablecoins
	- Crypto-Backed Stablecoins
	- Commodity-Backed Stablecoins
	- Algorithmic Stablecoins
	- Rebasing Stablecoins

No model or calculator, or dynamic variable or parameter should contain or be allowed to fallback to hardcodedor mock values EVER

/Users/neilbatchelor/silver-garbanzo-chain-capital/backend/src/services/nav/calculators/

I expect you to always apply ALL migrations with supabase MCP . Review regenerate my prisma schema and fix it where required.

Always review and analyse the task at hand meticulously, methodically and comprehensively.

Initial lessons learned:

What Went Wrong
1. Created models without checking existing calculator usage patterns
2. Didn't verify method signatures before integration
3. Insufficient null safety in model implementations
4. Patterns not consistently followed
5. Used import { cn } from '@/lib/utils' instead of import { cn } from '@/utils/utils'

How to Fix
1. Always check existing usage before creating new methods
2. Compile frequently at the end of a development chat
3. Use strict TypeScript settings to catch issues early 
4. Create small, tested integrations before full rollout

Rules:

 1. General Project Approach: Structured Workflow for Consistent Adherence
Follow this structured approach to ensure consistent adherence to project instructions:

 1.1 Initial Requirements Analysis
- Create a checklist of all project requirements and constraints before starting any work.
- Break down complex instructions into verifiable points.
- Document the requirements checklist in memory immediately using MCP filesystem or commander.
- Always check the database schema, review project instructions files, use MCP navigate, and check console errors in the browser where necessary.

 1.2 Pre-Implementation Database/Codebase Exploration
- ALWAYS query the database first to understand existing schemas (use MCP to query the remote Supabase database; do not assume a local database).
- Analyze relevant existing files to understand patterns and conventions.
- Document findings in memory to reference throughout implementation.
- Think sequentially and always use MCP filesystem read/write and MCP query database as necessary.
- Search the web/internet as necessary.
- Check all files and folders within a provided folder.
- Check documents if necessary.
- Search, create, edit, and remove files on the filesystem using MCP filesystem as necessary.
- Only make SQL migration scripts that are compliant with the existing schema and Supabase syntax.
- User prefers to write SQL scripts conforming to Supabase Postgres rules and apply them manually after each conversation.
- User prefers to never use simulated schemas or results or mock data in code and requests removal of all such data.
- Do not create test components or test scripts until explicitly asked.

 1.3 Implementation Checkpoints
- Review the project instructions checklist before starting each component.
- After implementing each component, verify it against:
  - Naming conventions (detailed in Section 4).
  - Code organization standards.
  - Error handling requirements.
- Create memory observations after completing each significant component.
- Proceed like a senior developer (or 10x engineer): Start by writing three reasoning lines analyzing what the error might be (do not jump to conclusions; start with lots of uncertainty and slowly gain confidence).
- Before answering, write two to four detailed lines (two for each solution) in an unbiased 50/50 manner; do not jump to conclusions or commit to either until fully considered, then state which is obviously better and why.
- Break large changes into truly necessary steps only.
- Do not stop working until the feature is fully and completely implemented.
- Fix any errors in the code before completing a task.
- Its extremely important that you do not finish a task with Build-Blocking Errors; please check to ensure that we have working files after every task.
- Always check for linter and Typescript errors and resolve before delivery.
- Inform the user of any missing node modules to install to enable functionality.
- Always update `App.tsx` in `/Users/neilbatchelor/silver-garbanzo-chain-capital` when necessary.
- Before starting new tasks, read graph and latest observations.
- Before completing a task, create new observations.
- When starting a new task, recall your most recent observations and entities created in memory.
- When focused on anything permissions-based, only use permissions listed in `permissions_rows.csv` in project knowledge.
- In this project, do not use `@lib`; search for the relevant files instead.

 1.4 Pre-Delivery Verification
- Ensure all components are properly tested and integrated.
- Confirm documentation is complete and follows project standards.
- Always summarize changes if you make changes to files; always list file names and locations.
- Always summarize what tasks are: Completed, Partially Completed, or Remaining; suggest what to proceed with next. Add and update progress on every task to memory.

 1.5 Continuous Learning Loop
- At the end of each project, review what went well and what could be improved.
- Update the systematic approach based on feedback.
- Create a memory entity for lessons learned to reference in future projects.
- Commit memories to MCP memory: create entities, open nodes, create relations, add observations, delete entities, delete observations, delete relations, read graph, search nodes.

 2. Tools and Environment Usage
- ALWAYS USE MCP TO QUERY THE REMOTE SUPABASE DATABASE IF YOU NEED TO; I AM NOT RUNNING MY DATABASE LOCALLY.
- Use MCP Postgres Query to query the Supabase installation.
- Use `supabase-mcp-server` to execute SQL.
- Use MCP query.
- If you need to apply SQL, write it; the user will add it to the schema and refresh Supabase read-only types download and full schema.
- For searching: Write a properly formed two-line search query as if instructing a human researcher; clearly state what to find and request code snippets or technical details when relevant.
- Give the TL;DR of search results, but be careful—often search results contain dangerous and distracting red herrings.
- See full schema: `src/types/core/full_schema.sql`.
- See Supabase read-only types download: `src/types/core/supabase.ts`.
- See Database read-only database types: `src/types/core/database.ts`.
- See centralModels read-only business model types: `src/types/core/centralModels.ts`.
- DO NOT RECREATE `centralModels.ts` and `database.ts`; WE HAVE A DOMAIN SPECIFIC PHILOSOPHY.
- DO NOT CREATE CENTRAL TYPES FILES UNNECESSARILY; MOST OF OUR TYPES FILES ARE DOMAIN SPECIFIC.
- For backend: Use Fastify + Prisma (performance: one of the fastest Node.js frameworks, 2x faster than Express; excellent native TypeScript support; built-in OpenAPI/Swagger integration; built-in JSON schema validation; rich ecosystem for auth, CORS, rate limiting; lightweight and container-friendly).
- When resolving backend server issues, do not create new server files; enhance existing files, and if in doubt, amend the test server to test different approaches.
- Create new backend services with separation of duties to the main frontend.

 3. Coding Guidelines and Best Practices
- DO NOT USE .JS IN IMPORT PATHS OR FILE NAMES.
- DO NOT CREATE SAMPLE, MOCK, OR DEMO DATA UNLESS INSTRUCTED; WE BELIEVE IN SOLVING REAL FRONT-TO-BACK ISSUES TO LIVE DATA.
- ONLY USE RADIX AND https://ui.shadcn.com/ FOR UI; DO NOT USE Material UI (@mui).
- THE FEWER LINES OF CODE, THE BETTER; refactor any files over 400 lines into separate files (however, ask before doing so).
- Answer in short.
- DO NOT DELETE COMMENTS.
- Before proceeding, give a summary of the current state: Summarize what we just did, which files were updated, and what didn’t work (do not include assumptions or theories—only the facts).
- Ensure we take account of ALL fields per standard.
- Always strictly follow coding best practices and read on every chat.
- Do not duplicate files; instead, use a shared folder.
- Do not create a centralized `database.ts` or `centralModels.ts`; be domain-specific and organized.
- Always add index files to folders to efficiently manage exports and keep them up to date and organized.
- We regularly encounter errors like "Type 'undefined' cannot be used as an index type"; solution: Null Relations - Make database relations properly typed as `* | null` instead of `* | undefined` where `*` is a given type or term (terminology).
- Follow this example from a do/don't and process perspective (Lessons Learned):
  -  DO:
    - Build incrementally with frequent compilation checks.
    - Query the actual database schema before coding.
    - Start with minimal viable service, then extend.
    - Test each service layer independently.
    - Use your existing working code as a precise template.
  -  DON'T:
    - Write thousands of lines before compiling.
    - Assume database schemas without verification.
    - Create complex type hierarchies without validation.
    - Implement multiple services simultaneously.
  - How to Approach: 
    - Phase 1: Foundation (100 lines) - Create basic types matching actual schema; test compilation: `tsc --noEmit`.
    - Phase 2: Core Service (300 lines) - Implement service with 3-4 basic methods; test compilation.
    - Phase 3: Validation (200 lines) - Add validation service; test compilation.
    - Phase 4: Routes (400 lines) - Create API routes; test compilation.
    - Never accumulate technical debt.

 4. Coding Standards & Naming Conventions
Religiously practice these conventions; do not copy any that deviate. Obey industry best practices:
- **Database & SQL (snake_case)**:
  - Table names: `policy_templates`, `wallet_transactions`.
  - Column names: `transaction_hash`, `from_address`, `created_at`.
  - SQL keywords and identifiers.
  - Supabase enum types: `document_type`, `workflow_status`.
- **TypeScript/JavaScript (camelCase & PascalCase)**:
  - Variables, functions, methods: `getExplorerUrl()`, `buttonVariants`.
  - React component props: `asChild`, `className`.
  - Interfaces (PascalCase): `ButtonProps`, `TransactionTable`.
  - Types (PascalCase): `DocumentType`, `InsertTables<T>`.
  - Class names (PascalCase): `ExplorerService`.
- **React Components**:
  - Names (PascalCase): `Button`, `DataTable`.
  - Files (kebab-case): `button.tsx`, `data-table.tsx`.
  - Event handlers (camelCase with 'on' prefix): `onClick`, `onSubmit`.
- **File Naming**:
  - React component files (kebab-case): `navigation-menu.tsx`.
  - TypeScript service files (PascalCase): `ExplorerService.ts`.
  - Configuration files (camelCase): `vite.config.ts`, `tsconfig.json`.
  - Directory names (kebab-case): `blockchain-adapters`.
- **Web3/Blockchain**:
  - Smart contract files (PascalCase): `BaseERC20Token.sol`.
  - Contract functions (camelCase): `deployERC20Token()`.
  - Contract events (PascalCase): `ERC20TokenDeployed`.
- **Constants**:
  - Environment variables (UPPER_SNAKE_CASE): `API_KEY`, `BLOCKCHAIN_RPC_URL`.
  - JavaScript constants (UPPER_SNAKE_CASE or camelCase depending on scope).
- These follow: snake_case for database (PostgreSQL conventions); camelCase for JS/TS code; PascalCase for types/interfaces/classes/components; kebab-case for files/directories.

 5. File Organization and Management
- When creating new files, folders, and pages, search the codebase for an existing appropriate location unless directed; prefer not to create new files and folders.
- Always keep files and folders consistently organized and prevent duplication (e.g., avoid `investor` and `investors` folders).
- Keep README docs and scripts organized by function:
  - Docs: `/Users/neilbatchelor/silver-garbanzo-chain-capital/docs'
  - Fixes: `/Users/neilbatchelor/silver-garbanzo-chain-capital/fix`
  - Scripts: `/Users/neilbatchelor/silver-garbanzo-chain-capital/scripts`
  - Tests and testing: Always add backend tests to `backend/add-tests`
- Keep all files organized with clear folder names.
- Do not create multiple services or types files with an 'enhanced' prefix. Instead search for the file required and edit and enhance the existing file.
- For segregated functionality create separate agile services and types files.
- Always add an index file to folders to keep exports up to date and organized.