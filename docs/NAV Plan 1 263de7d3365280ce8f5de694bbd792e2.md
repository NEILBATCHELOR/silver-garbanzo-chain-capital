# NAV Plan 1

**NAV PLAN 1** 

**1. Phase 0 — Discovery, alignment, and standards lock-in**

- Review WARP.md and project rules to enforce domain-first organization, naming conventions, and testing/linting gates.
- Inspect existing climateReceivables and factoring domains (frontend and backend) to mirror structure (components, services, hooks, types, utils; routes; validation; dashboards).
- Decide domain name: nav (backend: backend/src/services/nav, routes/nav.ts; frontend: components/nav, hooks/nav, services/nav, utils/nav, types/nav).
- Verify dev flow: pnpm install, pnpm dev, pnpm type-check, pnpm lint, pnpm test.

**2. Phase 1 — Database reconnaissance with MCP and gap analysis**

- Use MCP Postgres to enumerate and inspect relevant tables and columns:

- asset_nav_data (confirm columns: asset_id, product_type, valuation_date/time, currency, total_assets, total_liabilities, nav_value, nav_per_share, shares_outstanding, fx_rate_used, price_sources, status, created_at, run_id, etc.)

- asset_holdings (validate composite/constituent relationships: holding_id, parent_asset_id, child_asset_id/instrument_id, quantity, weight, cost_basis, currency, effective_date)

- projects (id, organization_id, project_type, relationships to assets/products)

- Product-specific tables (discover actual names): SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND (table_name LIKE '%_products' OR table_name LIKE '%receivable%' OR table_name IN ('asset_nav_data','asset_holdings','projects'));

- Map keys/relationships to unify NAV inputs (asset/product ids, holdings, liabilities, fees, currency).
- Identify existing workflow/audit/permissions tables to reuse for validation/approvals if available.
- Document gaps requiring minimal schema additions.

**3. Phase 2 — Schema proposals (SQL) for minimal NAV workflow primitives**

- Prepare SQL migration drafts (you will apply, then regenerate Supabase types):

- nav_calculation_runs:

- id UUID PK, asset_id UUID, product_type TEXT, project_id UUID NULL, valuation_date DATE, started_at TIMESTAMPTZ, completed_at TIMESTAMPTZ NULL, status TEXT CHECK IN ('queued','running','failed','completed'), inputs_json JSONB, result_nav_value NUMERIC, nav_per_share NUMERIC, fx_rate_used NUMERIC NULL, pricing_sources JSONB NULL, error_message TEXT NULL, created_by UUID NULL, created_at TIMESTAMPTZ DEFAULT now()

- indexes: (asset_id, valuation_date), (status), (project_id, valuation_date)

- nav_validation_results:

- id UUID PK, run_id UUID FK->nav_calculation_runs(id), rule_code TEXT, severity TEXT CHECK IN ('info','warn','error'), passed BOOLEAN, details_json JSONB, created_at TIMESTAMPTZ DEFAULT now()

- index: (run_id)

- nav_approvals:

- id UUID PK, run_id UUID FK->nav_calculation_runs(id), status TEXT CHECK IN ('draft','validated','approved','rejected','published'), requested_by UUID, validated_by UUID NULL, approved_by UUID NULL, approved_at TIMESTAMPTZ NULL, comments TEXT NULL, created_at TIMESTAMPTZ DEFAULT now()

- index: (run_id, status)

- nav_redemptions:

- id UUID PK, asset_id UUID, product_type TEXT, as_of_date DATE, shares_redeemed NUMERIC, value_redeemed NUMERIC, redemption_rate NUMERIC, created_at TIMESTAMPTZ DEFAULT now()

- unique: (asset_id, as_of_date)

- nav_fx_rates:

- base_ccy TEXT, quote_ccy TEXT, rate NUMERIC, as_of TIMESTAMPTZ, source TEXT, PRIMARY KEY (base_ccy, quote_ccy, as_of)

- Optional cache: nav_price_cache

- instrument_key TEXT, price NUMERIC, currency TEXT, as_of TIMESTAMPTZ, source TEXT, PRIMARY KEY (instrument_key, source, as_of)

- Add indexes for asset_nav_data if missing:

- CREATE INDEX IF NOT EXISTS idx_asset_nav_data_asset_date ON asset_nav_data (asset_id, valuation_date);

- CREATE INDEX IF NOT EXISTS idx_asset_nav_data_project_date ON asset_nav_data (project_id, valuation_date);

- Do not change existing columns without confirmation; propose additive-only migrations.

**4. Phase 3 — Backend domain scaffolding (Fastify + Prisma)**

- Create backend/src/services/nav/ with:

- index.ts (barrel exports)

- NavService.ts (orchestration: persist/read NAV, aggregation, project rollups)

- NavCalculationService.ts (engine; DI of calculators, FX, oracle)

- NavValidationService.ts (rules; thresholds, staleness, variance, liquidity)

- NavApprovalService.ts (state machine; RBAC; audit)

- RedemptionService.ts (rates: daily, rolling windows)

- MarketDataOracleService.ts (providers: Chainlink, CoinGecko, internal DB; caching/TTL)

- FxRateService.ts (ccy conversion; sourcing priority; fallbacks)

- OnChainNavService.ts (ERC-4626 share price, ERC-1400/3525 hooks; HSM-aware signing via existing wallet infra)

- types.ts (domain-local types: AssetType, CalculationInput, CalculationResult, ValidationResult, ApprovalStatus)

- Add backend/src/routes/nav.ts:

- Endpoints:

- GET /nav/dashboard (KPIs, charts feeds)

- GET /nav/assets/:assetId?from=&to= (historical NAV)

- GET /projects/:projectId/nav?from=&to=

- POST /nav/calculate (asset_id/product_type/valuation_date; manual run)

- POST /nav/:runId/validate

- POST /nav/:runId/approve

- POST /nav/redemption-rate (asset_id, window)

- GET /nav/calculation-runs?asset_id=&status=

- POST /nav/publish-onchain (run_id | asset_id)

- Use TypeBox JSON schemas; register Swagger docs.

- Register route in backend plugin loader; keep domain isolation.

**5. Phase 4 — Market data and FX providers (plugin architecture)**

- MarketDataOracleService:

- Provider strategy: chainlink, coingecko, onchain-dex, internal-db, manual-override

- Selection policy by instrument and priority list

- Caching: Redis with TTL; key by instrument_key + as_of

- Normalization to {price, currency, asOf, source}

- FxRateService:

- Sources: Chainlink FX feeds, ECB/OFX fallback, internal nav_fx_rates table

- Cache with TTL; precise rounding; handle missing path via triangulation (e.g., USD) if allowed

- Environment variables to add (backend):

- MARKET_DATA_PROVIDERS, COINGECKO_API_KEY, CHAINLINK_RPC_URL, ORACLE_TIMEOUT_MS, REDIS_URL

- If not present, plan to pnpm add: ioredis, @sinclair/typebox, node-cron (or @fastify/schedule), undici.

**6. Phase 5 — Asset-type calculator strategies**

- Define interface:

- interface AssetNavCalculator { canHandle(input): boolean; calculate(input): Promise&lt;CalculationResult&gt;; }

- Implement calculators incrementally (each isolated file; unit-testable):

- Equity: NAV = Σ(shares × price) − liabilities; supports dividends/accruals

- Bonds: price from oracle or PV cash flows + accrued interest; haircuts if illiquid

- Commodities: NAV = Σ(units × spot/futures price); storage/roll costs optional

- MMFs/Composite funds: look-through asset_holdings; NAV = Σ(child NAV or price × qty) − fees/liabilities; nav_per_share = net_assets / shares_outstanding

- Structured Products: payoff engine using underlying indices; use inputs from product table

- Quant Strategies: apply daily return to prior NAV; pull signals/returns from strategy table

- Private Equity/Private Debt/Real Estate: last appraised NAV adjusted for cash flows; FX normalization

- Energy/Infrastructure: DCF on receivables/production; or use climateReceivables outputs

- Collectibles: last appraisal adjusted for index if available

- Asset-backed/Invoice/Climate Receivables: reuse factoring/climateReceivables valuation utilities

- Digital Tokenized Funds: ERC-4626 pricePerShare or look-through to holdings

- Stablecoins:

- Fiat-backed: NAV ~ reserves (bank balances + T-bills) vs liabilities; reconcile with attestation

- Crypto-backed: NAV = collateral value × haircut − liabilities

- Commodity-backed: collateral spot value; storage costs

- Algorithmic/Rebasing: protocol-specific treasury + mechanism state

- Map asset types to product tables and identifier schemes (ISIN, CUSIP, on-chain addresses).

**7. Phase 6 — NAV engine orchestration and persistence**

- NavCalculationService flow:

- Build CalculationInput (asset_id/product_type/project_id, valuation_date)

- Resolve holdings, positions, fees, liabilities, FX target currency

- For each component, fetch prices/FX; run calculator; aggregate

- Persist nav_calculation_runs (status running/completed/failed)

- Upsert into asset_nav_data (atomic, idempotent by asset_id + valuation_date)

- Emit audit events; return CalculationResult

- Ensure precision (BigInt/decimal.js) and deterministic rounding; time-zone normalization to UTC.

**8. Phase 7 — Validation rules and approval workflow**

- NavValidationService:

- Rules: price staleness, large day-over-day delta limits, missing holdings, FX availability, outlier flags vs benchmarks, negative net assets, liquidity coverage

- Record failures in nav_validation_results; compute overall pass/fail

- NavApprovalService:

- States: draft → validated → approved → published (or rejected)

- Enforce RBAC (e.g., nav.calculate, nav.validate, nav.approve); integrate with existing auth

- Persist to nav_approvals; audit all transitions

**9. Phase 8 — Redemption rate calculations**

- RedemptionService:

- Inputs: window (daily/7d/30d/custom), asset_id/product_type

- Data sources: investor share transactions (redemptions), token burns (on-chain), or nav_redemptions if provided externally

- redemption_rate = value_redeemed / average_net_assets_over_window

- Persist nav_redemptions for daily snapshots; expose API endpoint

**10. Phase 9 — On-chain NAV publishing and reconciliation**

- OnChainNavService:

- For ERC-4626: update share price via protocol-specific method if available (or adjust asset/totalAssets)

- For ERC-1400/3525: call setValuation/setPrice if contracts expose it

- HSM integration via existing wallet providers; support multi-chain mapping per product

- Reconciliation endpoint to compare on-chain vs off-chain NAV; thresholds and alerts

**11. Phase 10 — Scheduling daily jobs and manual re-runs**

- Use @fastify/schedule or node-cron:

- 00:15 UTC daily: fetch FX and market prices cache

- 00:30 UTC daily: calculate NAV for all active assets/projects

- 01:00 UTC daily: run validations; notify pending approvals

- Add manual POST /nav/calculate endpoint for ad-hoc runs; queue with status queued→running→completed

**12. Phase 11 — Backend API schemas, docs, and errors**

- Define TypeBox schemas for all routes; strict input/output typing
- OpenAPI/Swagger docs for discoverability
- Standardized error objects with codes (NAV_MISSING_PRICE, NAV_VALIDATION_FAILED, APPROVAL_FORBIDDEN, etc.)
- Comprehensive audit logging for sensitive operations

**13. Phase 12 — Frontend scaffolding (domain-first)**

- Create:

- components/nav/: NavDashboard.tsx, nav-table.tsx, nav-form.tsx, nav-charts.tsx, redemption-calculator.tsx, validation-panel.tsx, approval-workflow.tsx, index.ts

- hooks/nav/: useNavData.ts, useNavCalculator.ts, useRedemptionRate.ts, useNavApproval.ts, index.ts

- services/nav/: NavApi.ts, index.ts

- utils/nav/: calculators.ts, formatters.ts, validation.ts, index.ts

- types/nav/: Nav.ts, index.ts

- pages/nav/: nav-page.tsx, nav-detail-page.tsx

- Update frontend/src/App.tsx to register routes and navigation entries.
- UI: shadcn/ui + Radix only. Reuse existing DataTable/Card components. For charts, prefer existing lib; if none, propose pnpm add recharts.

**14. Phase 13 — NAV Dashboard (KPIs + charts)**

- KPIs: Total AUM, 24h/7d/MTD change, pending validations/approvals, redemption rate
- Charts:

- NAV over time (asset/project/global)

- Asset class allocation (pie/treemap)

- Drawdown/volatility (where applicable)

- Filters: date range, asset type, product, project, currency
- Live updates: Supabase Realtime subscription to asset_nav_data (if enabled) or polling fallback

**15. Phase 14 — NAV Data Management UI**

- Data table with sorting/filtering/pagination
- Create/Edit NAV record form (manual overrides gated by permission)
- Attach validation results and approval status badges
- Export CSV/JSON for selected ranges

**16. Phase 15 — Asset-specific calculators UI**

- Per-asset-type panels exposing relevant inputs (e.g., holdings for MMFs, yield curves for bonds, collateral for stablecoins)
- Preview calculation result with trace (inputs → prices → FX → result)
- Save as draft, request validation → approval

**17. Phase 16 — Historical NAV tracking and visualization**

- Time-series viewer with zoom, compare assets/projects, baseline rebasing
- Show versioning: which run_id populated each NAV point; tooltip with sources and FX used
- Download timeseries (CSV)

**18. Phase 17 — Redemption rate interface**

- Select asset/time window; compute and render rate + trend
- Surface underlying redemptions and AUM used in denominator
- Action to persist daily redemption snapshot

**19. Phase 18 — Validation and approval workflow UI**

- ValidationPanel: list of rules, pass/fail, details, ability to re-run validations
- ApprovalWorkflow: role-gated actions for validate/approve/reject/publish with comments
- Timeline of state transitions (audit)

**20. Phase 19 — Permissions, auth, and audit integration**

- Gate all critical actions using existing RBAC (permissions_rows.csv): e.g., nav.read, nav.write, nav.calculate, nav.validate, nav.approve, nav.publish
- Component-level permission checks via useAuth/usePermissions hooks
- Backend route guards and audit logging on all state-changing endpoints

**21. Phase 20 — Tests (backend and frontend)**

- Backend:

- Unit: calculators, FX, oracle, validation (backend/src/services/nav/__tests__)

- Integration: calculation run end-to-end (temp test DB or DI stubs)

- API: routes/nav.ts via supertest or Fastify inject

- Frontend:

- Components: dashboard, forms, tables

- Hooks: data fetching, mutation flows

- No mock/sample business data persisted; use DI and stubs where needed.

**22. Phase 21 — Performance, indexes, and pagination**

- Ensure server-side pagination on NAV listings
- Add/confirm indexes on frequently filtered columns: asset_id, project_id, valuation_date, product_type, status
- Cache pricing/FX results and NAV KPIs (short TTL) in Redis

**23. Phase 22 — Observability and error budgets**

- Structured logging with context (asset_id, run_id, valuation_date)
- Metrics: run durations, validation failure rates, oracle latency, cache hit ratio
- Alert thresholds for missing prices and validation failures over N assets

**24. Phase 23 — Documentation and READMEs**

- Add docs/NAV-Module-README.md:

- Architecture, data flow, calculators, workflows, APIs, env vars, limits

- Setup instructions and troubleshooting

- Tasks: Completed/Partial/Remaining

- Add fix/ and scripts/ entries as needed (e.g., maintenance scripts)

25. Phase 24 — Delivery checklist and rollout

- pnpm type-check, pnpm lint, pnpm test; resolve errors
- Swagger docs verified at /docs
- Confirm routes in App.tsx and navigation entries
- UAT: compute NAV for at least three asset types end-to-end (read-only data)
- Plan phased enablement by asset class; feature flags per provider

**26. Appendix A — Initial file/folder map (to be created)**

- Backend:

- backend/src/services/nav/index.ts

- backend/src/services/nav/NavService.ts

- backend/src/services/nav/NavCalculationService.ts

- backend/src/services/nav/NavValidationService.ts

- backend/src/services/nav/NavApprovalService.ts

- backend/src/services/nav/RedemptionService.ts

- backend/src/services/nav/MarketDataOracleService.ts

- backend/src/services/nav/FxRateService.ts

- backend/src/services/nav/OnChainNavService.ts

- backend/src/services/nav/types.ts

- backend/src/services/nav/__tests__/...

- backend/src/routes/nav.ts

- Frontend:

- frontend/src/components/nav/index.ts

- frontend/src/components/nav/nav-dashboard.tsx

- frontend/src/components/nav/nav-table.tsx

- frontend/src/components/nav/nav-form.tsx

- frontend/src/components/nav/nav-charts.tsx

- frontend/src/components/nav/redemption-calculator.tsx

- frontend/src/components/nav/validation-panel.tsx

- frontend/src/components/nav/approval-workflow.tsx

- frontend/src/hooks/nav/index.ts

- frontend/src/hooks/nav/useNavData.ts

- frontend/src/hooks/nav/useNavCalculator.ts

- frontend/src/hooks/nav/useRedemptionRate.ts

- frontend/src/hooks/nav/useNavApproval.ts

- frontend/src/services/nav/index.ts

- frontend/src/services/nav/NavApi.ts

- frontend/src/utils/nav/index.ts

- frontend/src/utils/nav/calculators.ts

- frontend/src/utils/nav/validation.ts

- frontend/src/utils/nav/formatters.ts

- frontend/src/types/nav/index.ts

- frontend/src/types/nav/Nav.ts

- frontend/src/pages/nav/nav-page.tsx

- frontend/src/pages/nav/nav-detail-page.tsx

**27. Appendix B — Dependencies to verify/add (inform before install)**

- Backend:

- @sinclair/typebox (schema validation)

- node-cron or @fastify/schedule (scheduling)

- ioredis (caching)

- undici (HTTP fetch for market data)

- decimal.js (high-precision math) or use Prisma Decimal if already present

- Frontend:

- recharts (if no existing chart lib)

- react-hook-form + zod (if not already used)

- Confirm existing libs first; prefer reuse over new installs.

**28. Appendix C — Risk controls and safeguards**

- Dry-run mode for NAV calculation with no persistence
- Dual-control for approve→publish transitions
- Threshold-based blocks (e.g., >5% daily NAV move requires 2 approvals)
- Full traceability: store inputs_json and price sources per run