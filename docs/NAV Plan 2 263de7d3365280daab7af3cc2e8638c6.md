# NAV Plan 2 

NAV PLAN 2

**1. Phase 0 — Baseline verification, migrations, and environment readiness**

- Verify nav-module-schema-migration.sql is complete (the trailing DO $$ block appears truncated). Close any open DO $$ blocks and re-run SQL format check.
- Apply the migration to Supabase (manually): scripts/nav-module-schema-migration.sql
- Verify objects exist: nav_calculation_runs, nav_validation_results, nav_approvals, nav_redemptions, nav_fx_rates, nav_price_cache, nav_data_with_status view, calculate_project_weighted_nav(p_project_id, p_date)
- Regenerate Supabase types (frontend): pnpm types:supabase
- Run: pnpm type-check, pnpm lint, pnpm dev:backend to confirm baseline compiles and boots
- Acceptance: All new tables and indexes exist, view works, function callable, backend compiles and runs with no startup errors

**2. Phase 0.1 — Package dependencies installation (backend)**

Install required modules:

- Core: axios, decimal.js, dayjs
- Scheduling: node-cron
- Swagger/OpenAPI: @fastify/swagger, @fastify/swagger-ui
- EVM on-chain publishing: ethers@6
- Optional (telemetry): pino-pretty, @sentry/node

Commands:

- cd backend &amp;&amp; pnpm add axios decimal.js dayjs node-cron @fastify/swagger @fastify/swagger-ui ethers pino-pretty
- Optional: pnpm add @sentry/node
- Acceptance: pnpm type-check passes; server boots

**3. Phase 1 — Product type normalization utilities**

- Create backend/src/services/nav/utils/productType.ts with functions to normalize AssetType/product_type to product-table names (align TS enums with SQL get_product_table_name):

- bonds → bond, commodities → commodity, digital_tokenized_funds → digital_tokenized_fund, etc.

- Provide productTypeToTableName(productType: string): string | null

- Provide assetTypeToProductType(assetType: AssetType): string

- Ensure no central database files; keep under nav domain; add index.ts in utils folder
- Acceptance: Unit-tested mapping for all types present in types.ts and SQL function

**4. Phase 2 — Finish NAV Fastify routes (backend/src/routes/nav.ts)**

Implement handlers using existing service factories:

- POST /nav/runs (CreateCalculationRequest): queues/executes a calculation run
- GET /nav/runs/:runId
- GET /nav/runs (NavQueryOptions filters: assetId, productType, projectId, status, approvalStatus, dateFrom, dateTo, pagination)
- PATCH /nav/runs/:runId (status, navValue, navPerShare, fxRateUsed, errorMessage)
- GET /nav/current?assetId|productType|projectId
- GET /nav/historical?assetId|productType|projectId&amp;fromDate&amp;toDate
- GET /nav/projects/:projectId/weighted?valuationDate
- POST /nav/redemptions
- GET /nav/redemptions/rate?window=daily|7d|30d|custom&amp;startDate&amp;endDate&amp;assetId|productType
- POST /nav/market-data
- POST /nav/market-data/batch
- POST /nav/fx-rate
- POST /nav/fx-rate/batch
- POST /nav/convert-currency
- POST /nav/publish-onchain

Add JSON Schema validation and error handling; wire to getNavService(), getMarketDataOracleService(), getFxRateService()

- Acceptance: All routes registered, reflected in Swagger, and return 2xx with valid inputs

**5. Phase 3 — Asset calculators foundation and registry**

- Create folder: backend/src/services/nav/calculators
- Create BaseCalculator.ts: abstract class implementing AssetNavCalculator with helpers for FX conversion, price fetch, Decimal math
- Create CalculatorRegistry.ts: register calculators and resolve appropriate calculator by canHandle(input)
- Add index.ts to export all calculators and registry
- Acceptance: Registry returns a calculator for known asset/product types; unit tests cover resolution logic

**6. Phase 4 — Implement priority calculators (MVP set)**

Implement first-wave calculators:

- MmfCalculator.ts: holdings-based, amortized cost for &lt;=60d CP, accrued interest for repos, SEC 2a-7 checks; aim navPerShare ≈ 1.0
- BondCalculator.ts: mark-to-market using yields/price, accrued interest, FX conversion if needed
- EquityCalculator.ts: price × quantity, dividends as cash if provided
- CommoditiesCalculator.ts: spot/futures adjusted value × units, storage fees as liabilities if provided
- StablecoinFiatCalculator.ts: reserves value / outstanding tokens; 1:1 peg validation
- StablecoinCryptoCalculator.ts: collateral value with haircut / outstanding tokens; min collateral ratio validation
- AssetBackedCalculator.ts: discounted cash flows (receivables), impairments

All calculators:

- Use MarketDataOracleService and FxRateService
- Return CalculationResult with pricingSources map and fxRateUsed populated
- Acceptance: Each calculator unit-tested with 1-2 realistic scenarios; Decimal precision verified

**7. Phase 5 — Wire calculators into NavService run orchestration**

- In NavService: choose calculator via CalculatorRegistry
- Create nav_calculation_runs row as QUEUED→RUNNING; persist inputs_json
- Execute calculator; compute totals, navValue, navPerShare; persist result_nav_value, nav_per_share, fx_rate_used, pricing_sources; set COMPLETED/FAILED
- Insert/Upsert into asset_nav_data (date=valuation_date) with computed nav, totals, liabilities, outstanding_shares, source='calculated', calculation_method, notes
- Acceptance: POST /nav/runs triggers end-to-end run with persisted outputs and asset_nav_data updated

**8. Phase 6 — Validation rules engine**

- Create backend/src/services/nav/ValidationService.ts
- Rules (code, severity, thresholds) including:

- NAV_NON_NEGATIVE (error): navValue ≥ 0

- NAV_JUMP_MAX_PCT (warn/error): abs(change_pct) ≤ threshold (e.g., 5% default; 0.5% for MMF)

- LIABILITIES_NON_NEGATIVE (error)

- FX_RATE_PRESENT_WHEN_NEEDED (error)

- MMF_2A7_ELIGIBILITY (warn/error): composition ≥99.5% eligible, maturity ≤397d

- STABLECOIN_COLLATERAL_RATIO (error): ≥100% (fiat), ≥150% (crypto-backed default)

- Persist results to nav_validation_results; return summary
- Acceptance: Validation runs automatically post-calculation; nav_data_with_status view reflects validation_status

**9. Phase 7 — Approval workflow service**

- Create backend/src/services/nav/ApprovalService.ts
- State machine: draft → validated → approved → published; rejected from validated
- Methods: requestApproval(runId), setValidated(runId), approve(runId, approvedBy), reject(runId, comments), publish(runId)
- Persist to nav_approvals with auditing; latest status by run_id deterministically resolved
- Add route handlers for approvals (if not already in nav.ts)
- Acceptance: Approval lifecycle enforced, invalid transitions blocked, approvals visible in nav_data_with_status

**10. Phase 8 — Market data connectors and caching**

- Extend MarketDataOracleService to support:

- Chainlink (primary), CoinGecko (crypto), manual_override

- Add nav_price_cache TTL policy (e.g., 5m default), read-through/write-through

- Implement batch fetch for price data and FX
- Record chosen source per instrument in pricing_sources JSON
- Acceptance: Market data endpoints return cached/fresh data; calculators use cache first

**11. Phase 9 — FX rate service hardening**

- FxRateService: add historical lookup fallback order (nav_fx_rates → external provider → error)
- Support asOf resolution (nearest prior rate within window)
- Add batch insert/upsert utility for daily FX schedules
- Acceptance: Currency conversion endpoint accurate with historical dates; batch FX insert tested

**12. Phase 10 — Redemption rate service**

- Create backend/src/services/nav/RedemptionService.ts
- Methods: createRedemption(data), getRedemptionRate({window, startDate, endDate, assetId|productType})
- Daily rate: value_redeemed / total_assets or shares_redeemed / outstanding_shares (configurable), store both
- 7d/30d/custom: time-window aggregation; ensure UNIQUE(asset_id, as_of_date) handling
- Routes: POST /nav/redemptions, GET /nav/redemptions/rate wired to service
- Acceptance: Windowed redemption rates computed and persisted; API returns correct values

**13. Phase 11 — On-chain NAV publishing (EVM v1)**

- Create backend/src/services/nav/onchain/EvmNavPublisher.ts using ethers v6
- Config via env: EVM_RPC_URL, EVM_CHAIN_ID, NAV_PUBLISHER_ADDRESS, NAV_PUBLISHER_ABI, SIGNER_KEY (or integrate existing HSM/wallet domain)
- Method publish({assetId, contractAddress, chainId, navValue, navPerShare}) → txHash
- Wire to POST /nav/publish-onchain; allow auto-publish on approval status=pulished (event-driven hook)
- Acceptance: Successful transaction hash returned on testnet; persisted to a run audit log (error captured if failed)

**14. Phase 12 — Scheduler (daily NAV, FX, price cache refresh)**

- Add backend/src/plugins/scheduler.ts using node-cron
- Jobs:

- 00:15 UTC: fetch FX rates for T-1 close → nav_fx_rates

- 00:30 UTC: refresh price cache for tracked instruments

- 01:00 UTC: run NAV for all active assets/projects (configurable)

- Expose health endpoint for job status; add enable/disable via env
- Acceptance: Cron jobs registered on startup; logs show periodic execution; reruns idempotent

**15. Phase 13 — Frontend NAV dashboard (MVP)**

- Pages (React + shadcn/ui):

- /nav: list runs with filters, status badges, create run modal

- /nav/runs/:id: run details, validation results, approve/publish actions

- /nav/analytics: KPIs (AUM, daily/weekly/monthly change, pending validations/approvals), breakdowns

- /nav/redemptions: daily/windowed redemption rates

- Components: DataTable, Filters, ValidationList, ApprovalTimeline, RedemptionChart
- Hooks: useNavRuns, useNavAnalytics, useRedemptions, useMarketData
- Services: frontend/src/services/nav/api.ts consuming backend routes
- Acceptance: End-to-end flows visible and actionable in UI without errors

**16. Phase 14 — Swagger/OpenAPI documentation**

- Register @fastify/swagger and @fastify/swagger-ui in backend
- Add schemas to nav routes; ensure types align with CreateCalculationRequest, NavQueryOptions, etc.
- Publish at /docs; export JSON for client generation if needed
- Acceptance: All NAV endpoints documented with request/response models; UI loads without warnings

**17. Phase 15 — Testing suite**

- Backend tests in backend/add-tests:

- calculators.spec.ts (per calculator)

- validation-service.spec.ts

- approval-service.spec.ts

- nav-routes.spec.ts (Supertest + Fastify)

- fx-and-marketdata.spec.ts

- scheduler.spec.ts (mock timers)

- Ensure no mocks for data fetch unless necessary; prefer integration to read-only where possible
- Add coverage thresholds; run pnpm test and pnpm test:coverage
- Acceptance: ≥80% coverage for nav domain; green CI

**18. Phase 16 — Performance and indexing passes**

- SQL: verify and add targeted indexes:

- nav_calculation_runs (asset_id, valuation_date), (status), (project_id, valuation_date)

- nav_validation_results (run_id), (rule_code, severity)

- nav_approvals (run_id, status)

- asset_nav_data (asset_id, date), (project_id, date), (source, validated), (created_at)

- asset_holdings (asset_id), (updated_at), (maturity_date)

- Add price cache eviction policy; batch DB writes
- Consider partitioning asset_nav_data by month or project if row counts warrant
- Acceptance: P95 latency for list endpoints &lt; 300ms with realistic dataset; no slow queries in logs

**19. Phase 17 — Security, RBAC, and audit logging**

- Enforce RBAC permissions based on permissions_rows.csv: nav.read, nav.calculate, nav.approve, nav.publish
- Add audit logs for run creation, validation, approval, publishing (reuse existing audit domain)
- Validate inputs strictly; sanitize user-provided comments/notes
- Acceptance: Unauthorized access blocked; audit entries present for sensitive operations

**20. Phase 18 — Documentation and operational runbooks**

- Add docs/NAV-Module-Implementation-Plan.md (this plan, status, owners, timelines)
- Add docs/NAV-API.md (endpoint catalog with examples)
- Add docs/NAV-Operations-Runbook.md (scheduling, backfills, on-call, common failures)
- Update WARP.md if new scripts/commands introduced
- Acceptance: Docs complete, discoverable, and accurate

**21. Phase 19 — Final QA, hardening, and handover**

- UAT checklist: All routes exercised; calculators validated against sample historical values; on-chain publish tested on testnet
- Stress test: bulk runs for multiple assets/projects; verify scheduler resilience
- Final type-check, lint, build
- Acceptance: Zero build-blocking errors, green tests, sign-off from stakeholders