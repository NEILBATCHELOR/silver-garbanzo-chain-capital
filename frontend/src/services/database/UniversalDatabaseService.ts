/**
 * Universal Database Service
 * 
 * Provides automatic audit logging for ALL database operations.
 * This service wraps all Supabase operations to ensure that audit_logs
 * is updated whenever any table records are modified.
 */

import { supabase } from '../../infrastructure/database/client';
import { tableAuditGenerator } from '../audit/TableAuditGenerator';
import { universalAuditService } from '../audit/UniversalAuditService';
import { enhancedActivityService, ActivitySource, ActivityCategory, ActivitySeverity } from '../activity/EnhancedActivityService';
import { getTableSchema, getPrimaryKeyField, isAutoGeneratedField, hasCompositeKey, getCompositeKeyFields, getTimestampFields } from './TableSchemaConfig';

// Re-export Supabase types for convenience
export type {
  PostgrestResponse,
  PostgrestSingleResponse,
  PostgrestMaybeSingleResponse
} from '@supabase/supabase-js';

interface DatabaseOperation {
  table: string;
  operation: 'create' | 'update' | 'delete' | 'bulkCreate' | 'bulkUpdate' | 'bulkDelete';
  entityId?: string;
  userId?: string;
  projectId?: string;
  metadata?: Record<string, any>;
}

interface CreateOptions {
  userId?: string;
  projectId?: string;
  skipAudit?: boolean;
}

interface UpdateOptions {
  userId?: string;
  projectId?: string;
  skipAudit?: boolean;
}

interface DeleteOptions {
  userId?: string;
  projectId?: string;
  skipAudit?: boolean;
}

/**
 * Universal Database Service Class
 * 
 * Automatically logs all database operations to audit_logs table
 * while maintaining the same API as direct Supabase operations.
 */
export class UniversalDatabaseService {
  /**
   * Create a new record with automatic audit logging
   */
  async create<T extends Record<string, any> = any>(
    table: string, 
    data: Partial<T>, 
    options: CreateOptions = {}
  ): Promise<T> {
    if (options.skipAudit) {
      // Direct operation without audit
      const { data: result, error } = await (supabase as any)
        .from(table)
        .insert(data)
        .select()
        .single();
      
      if (error) throw error;
      return result as T;
    }

    // Get table schema to handle fields correctly
    const schema = getTableSchema(table);
    const timestampFields = getTimestampFields(table);
    const primaryKeyField = getPrimaryKeyField(table);
    
    // Use audit wrapper
    const auditService = tableAuditGenerator.generateTableAuditService(table);
    
    // Only add fields that don't conflict with database defaults
    const enrichedData = {
      ...data,
      // Only add primary key if not auto-generated and not already provided
      ...(!isAutoGeneratedField(table, primaryKeyField) && !(data as any)[primaryKeyField] && {
        [primaryKeyField]: crypto.randomUUID()
      }),
      // Only add created_at if table has it and it's not already provided
      ...(timestampFields.createdAt && !(data as any)[timestampFields.createdAt] && {
        [timestampFields.createdAt]: new Date().toISOString()
      }),
      // Add project_id if provided and not already set
      ...(options.projectId && !(data as any).project_id && { project_id: options.projectId })
    };

    const result = await auditService.create(enrichedData, options.userId);
    
    // Get the actual ID field for activity logging
    const entityId = result[primaryKeyField] || result.id || 'unknown';
    
    // Log creation event
    await enhancedActivityService.logActivity({
      source: options.userId ? ActivitySource.USER : ActivitySource.SYSTEM,
      action: `${table}_created`,
      category: this.getTableCategory(table),
      severity: ActivitySeverity.INFO,
      entityType: table,
      entityId: entityId,
      userId: options.userId,
      projectId: options.projectId,
      details: `Created new ${table} record`,
      newData: result
    });

    return result;
  }

  /**
   * Update a record with automatic audit logging
   */
  async update<T extends Record<string, any> = any>(
    table: string, 
    id: string, 
    data: Partial<T>, 
    options: UpdateOptions = {}
  ): Promise<T> {
    // Get table schema for correct field handling
    const primaryKeyField = getPrimaryKeyField(table);
    const timestampFields = getTimestampFields(table);
    
    if (options.skipAudit) {
      // Direct operation without audit
      const updateData = {
        ...data,
        // Only add updated_at if table has it and it's not already provided
        ...(timestampFields.updatedAt && !(data as any)[timestampFields.updatedAt] && {
          [timestampFields.updatedAt]: new Date().toISOString()
        })
      };
      
      const { data: result, error } = await (supabase as any)
        .from(table)
        .update(updateData)
        .eq(primaryKeyField, id)
        .select()
        .single();
      
      if (error) throw error;
      return result as T;
    }

    // Use audit wrapper
    const auditService = tableAuditGenerator.generateTableAuditService(table);
    const enrichedData = {
      ...data,
      // Only add updated_at if table has it and it's not already provided
      ...(timestampFields.updatedAt && !(data as any)[timestampFields.updatedAt] && {
        [timestampFields.updatedAt]: new Date().toISOString()
      })
    };

    const result = await auditService.update(id, enrichedData, options.userId);
    
    // Log update event
    await enhancedActivityService.logActivity({
      source: options.userId ? ActivitySource.USER : ActivitySource.SYSTEM,
      action: `${table}_updated`,
      category: this.getTableCategory(table),
      severity: ActivitySeverity.INFO,
      entityType: table,
      entityId: id,
      userId: options.userId,
      projectId: options.projectId,
      details: `Updated ${table} record`,
      newData: result
    });

    return result;
  }

  /**
   * Delete a record with automatic audit logging
   */
  async delete(
    table: string, 
    id: string, 
    options: DeleteOptions = {}
  ): Promise<void> {
    // Get table schema for correct field handling
    const primaryKeyField = getPrimaryKeyField(table);
    
    if (options.skipAudit) {
      // Direct operation without audit
      const { error } = await (supabase as any)
        .from(table)
        .delete()
        .eq(primaryKeyField, id);
      
      if (error) throw error;
      return;
    }

    // Use audit wrapper
    const auditService = tableAuditGenerator.generateTableAuditService(table);
    await auditService.delete(id, options.userId);
    
    // Log deletion event
    await enhancedActivityService.logActivity({
      source: options.userId ? ActivitySource.USER : ActivitySource.SYSTEM,
      action: `${table}_deleted`,
      category: this.getTableCategory(table),
      severity: ActivitySeverity.WARNING,
      entityType: table,
      entityId: id,
      userId: options.userId,
      projectId: options.projectId,
      details: `Deleted ${table} record`
    });
  }

  /**
   * Bulk create records with automatic audit logging
   */
  async bulkCreate<T extends Record<string, any> = any>(
    table: string, 
    dataArray: Partial<T>[], 
    options: CreateOptions = {}
  ): Promise<T[]> {
    if (options.skipAudit) {
      // Direct operation without audit
      const { data: results, error } = await (supabase as any)
        .from(table)
        .insert(dataArray)
        .select();
      
      if (error) throw error;
      return (results || []) as T[];
    }

    // Get table schema for correct field handling
    const schema = getTableSchema(table);
    const timestampFields = getTimestampFields(table);
    const primaryKeyField = getPrimaryKeyField(table);
    
    // Use audit wrapper
    const auditService = tableAuditGenerator.generateTableAuditService(table);
    const enrichedData = dataArray.map(item => ({
      ...item,
      // Only add primary key if not auto-generated and not already provided
      ...(!isAutoGeneratedField(table, primaryKeyField) && !(item as any)[primaryKeyField] && {
        [primaryKeyField]: crypto.randomUUID()
      }),
      // Only add created_at if table has it and it's not already provided
      ...(timestampFields.createdAt && !(item as any)[timestampFields.createdAt] && {
        [timestampFields.createdAt]: new Date().toISOString()
      }),
      // Add project_id if provided and not already set
      ...(options.projectId && !(item as any).project_id && { project_id: options.projectId })
    }));

    const results = await auditService.bulkCreate(enrichedData, options.userId);
    
    // Log bulk creation event
    await enhancedActivityService.logActivity({
      source: options.userId ? ActivitySource.USER : ActivitySource.SYSTEM,
      action: `${table}_bulk_created`,
      category: this.getTableCategory(table),
      severity: ActivitySeverity.NOTICE,
      entityType: table,
      entityId: `bulk_${crypto.randomUUID()}`,
      userId: options.userId,
      projectId: options.projectId,
      details: `Created ${dataArray.length} ${table} records in bulk`,
      metadata: { recordCount: dataArray.length }
    });

    return results;
  }

  /**
   * Find a single record by ID
   */
  async findById<T extends Record<string, any> = any>(table: string, id: string): Promise<T | null> {
    // Get table schema for correct field handling
    const primaryKeyField = getPrimaryKeyField(table);
    
    const { data, error } = await (supabase as any)
      .from(table)
      .select('*')
      .eq(primaryKeyField, id)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null; // No rows found
      throw error;
    }
    
    return data as T;
  }

  /**
   * Find multiple records with filters
   */
  async findMany<T extends Record<string, any> = any>(
    table: string, 
    filters: Record<string, any> = {},
    options: {
      limit?: number;
      offset?: number;
      orderBy?: string;
      ascending?: boolean;
      select?: string;
    } = {}
  ): Promise<T[]> {
    let query = (supabase as any)
      .from(table)
      .select(options.select || '*');

    // Apply filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        query = query.eq(key, value);
      }
    });

    // Apply ordering
    if (options.orderBy) {
      query = query.order(options.orderBy, { ascending: options.ascending ?? true });
    }

    // Apply pagination
    if (options.limit) {
      const offset = options.offset || 0;
      query = query.range(offset, offset + options.limit - 1);
    }

    const { data, error } = await query;
    
    if (error) throw error;
    return (data || []) as T[];
  }

  /**
   * Count records with filters
   */
  async count(table: string, filters: Record<string, any> = {}): Promise<number> {
    let query = (supabase as any)
      .from(table)
      .select('*', { count: 'exact', head: true });

    // Apply filters
    Object.entries(filters).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        query = query.eq(key, value);
      }
    });

    const { count, error } = await query;
    
    if (error) throw error;
    return count || 0;
  }

  /**
   * Check if a record exists
   */
  async exists(table: string, filters: Record<string, any>): Promise<boolean> {
    const count = await this.count(table, filters);
    return count > 0;
  }

  /**
   * Get raw Supabase client for complex queries
   * Note: These operations will NOT be automatically audited
   */
  getClient() {
    return supabase;
  }

  /**
   * Execute a custom query with audit logging
   */
  async executeWithAudit<T extends Record<string, any> = any>(
    operation: DatabaseOperation,
    query: () => Promise<T>
  ): Promise<T> {
    return universalAuditService.auditOperation(
      {
        table: operation.table,
        operation: operation.operation.toUpperCase() as any,
        entityId: operation.entityId || crypto.randomUUID(),
        userId: operation.userId,
        metadata: operation.metadata
      },
      query
    );
  }

  /**
   * Get table category for activity classification
   */
  private getTableCategory(table: string): ActivityCategory {
    // Define explicit categories for important tables
    const tableCategories: Record<string, ActivityCategory> = {
      // User Management
      'users': ActivityCategory.USER_MANAGEMENT,
      'investors': ActivityCategory.USER_MANAGEMENT,
      'user_roles': ActivityCategory.USER_MANAGEMENT,
      'user_sessions': ActivityCategory.AUTH,
      'auth_events': ActivityCategory.AUTH,
      
      // Financial
      'transactions': ActivityCategory.FINANCIAL,
      'wallet_transactions': ActivityCategory.FINANCIAL,
      'subscriptions': ActivityCategory.FINANCIAL,
      'invoices': ActivityCategory.FINANCIAL,
      'distributions': ActivityCategory.FINANCIAL,
      'token_allocations': ActivityCategory.FINANCIAL,
      
      // Blockchain/Tokens
      'tokens': ActivityCategory.BLOCKCHAIN,
      'token_versions': ActivityCategory.BLOCKCHAIN,
      'guardian_wallets': ActivityCategory.BLOCKCHAIN,
      'multi_sig_wallets': ActivityCategory.BLOCKCHAIN,
      'wallet_details': ActivityCategory.BLOCKCHAIN,
      
      // Compliance
      'rules': ActivityCategory.COMPLIANCE,
      'policy_templates': ActivityCategory.COMPLIANCE,
      'compliance_reports': ActivityCategory.COMPLIANCE,
      'compliance_checks': ActivityCategory.COMPLIANCE,
      'audit_logs': ActivityCategory.COMPLIANCE,
      
      // Documents
      'documents': ActivityCategory.DOCUMENT,
      'document_versions': ActivityCategory.DOCUMENT,
      'document_workflows': ActivityCategory.DOCUMENT,
      'issuer_documents': ActivityCategory.DOCUMENT,
      
      // System
      'system_settings': ActivityCategory.SYSTEM,
      'health_checks': ActivityCategory.SYSTEM,
      'monitoring_metrics': ActivityCategory.SYSTEM,
      'security_events': ActivityCategory.SECURITY,
      
      // Notifications
      'notifications': ActivityCategory.NOTIFICATION,
      'alerts': ActivityCategory.NOTIFICATION,
      
      // Integrations - All DFNS tables
      'dfns_applications': ActivityCategory.INTEGRATION,
      'dfns_service_accounts': ActivityCategory.INTEGRATION,
      'dfns_users': ActivityCategory.INTEGRATION,
      'dfns_credentials': ActivityCategory.INTEGRATION,
      'dfns_personal_access_tokens': ActivityCategory.INTEGRATION,
      'dfns_wallet_balances': ActivityCategory.INTEGRATION,
      'dfns_permission_assignments': ActivityCategory.INTEGRATION,
      'dfns_policies': ActivityCategory.INTEGRATION,
      'dfns_policy_approvals': ActivityCategory.INTEGRATION,
      'dfns_webhooks': ActivityCategory.INTEGRATION,
      'dfns_webhook_deliveries': ActivityCategory.INTEGRATION,
      'dfns_exchange_integrations': ActivityCategory.INTEGRATION,
      'dfns_exchange_accounts': ActivityCategory.INTEGRATION,
      'dfns_exchange_balances': ActivityCategory.INTEGRATION,
      'dfns_staking_integrations': ActivityCategory.INTEGRATION,
      'dfns_fee_sponsors': ActivityCategory.INTEGRATION,
      'dfns_sponsored_fees': ActivityCategory.INTEGRATION,
      'dfns_validators': ActivityCategory.INTEGRATION,
      'dfns_activity_logs': ActivityCategory.INTEGRATION,
      'dfns_api_requests': ActivityCategory.INTEGRATION,
      'dfns_sync_status': ActivityCategory.INTEGRATION,
      'dfns_signing_keys': ActivityCategory.INTEGRATION,
      'dfns_wallets': ActivityCategory.INTEGRATION,
      'dfns_wallet_nfts': ActivityCategory.INTEGRATION,
      'dfns_transaction_history': ActivityCategory.INTEGRATION,
      'dfns_transfers': ActivityCategory.INTEGRATION,
      'dfns_signatures': ActivityCategory.INTEGRATION,
      'dfns_broadcast_transactions': ActivityCategory.INTEGRATION,
      'dfns_permissions': ActivityCategory.INTEGRATION,
      'dfns_fiat_provider_configs': ActivityCategory.INTEGRATION,
      'dfns_fiat_transactions': ActivityCategory.INTEGRATION,
      'dfns_fiat_quotes': ActivityCategory.INTEGRATION,
      'dfns_fiat_activity_logs': ActivityCategory.INTEGRATION,
      
      // MoonPay Integration
      'moonpay_webhook_events': ActivityCategory.INTEGRATION,
      'moonpay_asset_cache': ActivityCategory.INTEGRATION,
      'moonpay_swap_transactions': ActivityCategory.INTEGRATION,
      'moonpay_passes': ActivityCategory.INTEGRATION,
      'moonpay_projects': ActivityCategory.INTEGRATION,
      'moonpay_customers': ActivityCategory.INTEGRATION,
      'moonpay_policies': ActivityCategory.INTEGRATION,
      'moonpay_transactions': ActivityCategory.INTEGRATION,
      'moonpay_webhook_config': ActivityCategory.INTEGRATION,
      'moonpay_compliance_alerts': ActivityCategory.INTEGRATION,
      'moonpay_policy_logs': ActivityCategory.INTEGRATION,
      
      // Stripe Integration
      'stripe_stablecoin_accounts': ActivityCategory.INTEGRATION,
      'stripe_conversion_transactions': ActivityCategory.INTEGRATION,
      'stripe_webhook_events': ActivityCategory.INTEGRATION,
      
      // Ramp Integration
      'ramp_network_config': ActivityCategory.INTEGRATION,
      'ramp_supported_assets': ActivityCategory.INTEGRATION,
      'ramp_transaction_events': ActivityCategory.INTEGRATION,
      'ramp_webhook_events': ActivityCategory.INTEGRATION,
      
      // Token Properties
      'token_erc20_properties': ActivityCategory.BLOCKCHAIN,
      'token_erc721_properties': ActivityCategory.BLOCKCHAIN,
      'token_erc1155_properties': ActivityCategory.BLOCKCHAIN,
      'token_erc1400_properties': ActivityCategory.BLOCKCHAIN,
      'token_erc3525_properties': ActivityCategory.BLOCKCHAIN,
      'token_erc4626_properties': ActivityCategory.BLOCKCHAIN,
      
      // All other token-related tables
      'token_erc1400_partitions': ActivityCategory.BLOCKCHAIN,
      'token_erc1400_controllers': ActivityCategory.BLOCKCHAIN,
      'token_erc1155_types': ActivityCategory.BLOCKCHAIN,
      'token_erc4626_strategy_params': ActivityCategory.BLOCKCHAIN,
      'token_erc721_attributes': ActivityCategory.BLOCKCHAIN,
      'token_erc4626_asset_allocations': ActivityCategory.BLOCKCHAIN,
      'token_erc3525_slots': ActivityCategory.BLOCKCHAIN
    };

    // Use explicit mapping first
    if (tableCategories[table]) {
      return tableCategories[table];
    }

    // Fall back to pattern matching for unmapped tables
    if (table.includes('user') || table.includes('investor') || table.includes('auth')) {
      return ActivityCategory.USER_MANAGEMENT;
    }
    if (table.includes('token') || table.includes('wallet') || table.includes('blockchain')) {
      return ActivityCategory.BLOCKCHAIN;
    }
    if (table.includes('transaction') || table.includes('payment') || table.includes('financial')) {
      return ActivityCategory.FINANCIAL;
    }
    if (table.includes('compliance') || table.includes('rule') || table.includes('policy')) {
      return ActivityCategory.COMPLIANCE;
    }
    if (table.includes('document') || table.includes('file')) {
      return ActivityCategory.DOCUMENT;
    }
    if (table.includes('notification') || table.includes('alert')) {
      return ActivityCategory.NOTIFICATION;
    }
    if (table.includes('system') || table.includes('config') || table.includes('setting')) {
      return ActivityCategory.SYSTEM;
    }
    if (table.includes('dfns') || table.includes('moonpay') || table.includes('stripe') || table.includes('ramp')) {
      return ActivityCategory.INTEGRATION;
    }
    
    return ActivityCategory.DATA;
  }
}

// Export singleton instance
export const universalDatabaseService = new UniversalDatabaseService();

// Convenience functions for common operations
export const createRecord = universalDatabaseService.create.bind(universalDatabaseService);
export const updateRecord = universalDatabaseService.update.bind(universalDatabaseService);
export const deleteRecord = universalDatabaseService.delete.bind(universalDatabaseService);
export const findRecord = universalDatabaseService.findById.bind(universalDatabaseService);
export const findRecords = universalDatabaseService.findMany.bind(universalDatabaseService);
export const countRecords = universalDatabaseService.count.bind(universalDatabaseService);
export const recordExists = universalDatabaseService.exists.bind(universalDatabaseService);

export default universalDatabaseService;