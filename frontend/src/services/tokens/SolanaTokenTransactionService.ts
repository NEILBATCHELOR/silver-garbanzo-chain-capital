/**
 * Solana Token Transaction Service
 * Handles logging and tracking of Solana token transactions
 * 
 * Features:
 * - Log transfers
 * - Query transaction history
 * - Track token operations
 */

import { supabase } from '@/infrastructure/database/client';
import { logActivity } from '@/infrastructure/activityLogger';

// ============================================================================
// TYPES
// ============================================================================

export interface SolanaTransferRecord {
  id?: string; // UUID from database
  token_id: string;
  token_address: string;
  token_symbol: string;
  from_address: string;
  to_address: string;
  amount: string;
  decimals: number;
  transaction_hash: string;
  network: string;
  status: 'pending' | 'confirmed' | 'failed';
  block_number?: number;
  timestamp: string;
  project_id: string;
  user_id?: string;
  created_at?: string; // Auto-generated by database
  updated_at?: string; // Auto-updated by database
}

export interface TransactionHistoryFilter {
  token_id?: string;
  project_id?: string;
  from_address?: string;
  to_address?: string;
  network?: string;
  status?: string;
  start_date?: string;
  end_date?: string;
  limit?: number;
}

// ============================================================================
// SERVICE
// ============================================================================

class SolanaTokenTransactionService {
  /**
   * Log a token transfer
   */
  async logTransfer(transfer: SolanaTransferRecord): Promise<string> {
    try {
      // Insert transaction record
      const { data, error } = await supabase
        .from('solana_token_transactions')
        .insert({
          token_id: transfer.token_id,
          token_address: transfer.token_address,
          token_symbol: transfer.token_symbol,
          from_address: transfer.from_address,
          to_address: transfer.to_address,
          amount: transfer.amount,
          decimals: transfer.decimals,
          transaction_hash: transfer.transaction_hash,
          network: transfer.network,
          status: transfer.status,
          block_number: transfer.block_number,
          timestamp: transfer.timestamp,
          project_id: transfer.project_id,
          user_id: transfer.user_id
        })
        .select('id')
        .single();

      if (error) throw error;

      // Log activity
      await logActivity({
        action: 'solana_token_transfer',
        entity_type: 'token',
        entity_id: transfer.token_id,
        details: {
          token_id: transfer.token_id,
          token_symbol: transfer.token_symbol,
          from: transfer.from_address,
          to: transfer.to_address,
          amount: transfer.amount,
          transaction_hash: transfer.transaction_hash,
          network: transfer.network,
          status: transfer.status
        }
      });

      return data.id;
    } catch (error) {
      console.error('Error logging transfer:', error);
      throw error;
    }
  }

  /**
   * Update transaction status
   */
  async updateTransactionStatus(
    transactionHash: string,
    status: 'confirmed' | 'failed',
    blockNumber?: number
  ): Promise<void> {
    try {
      const { error } = await supabase
        .from('solana_token_transactions')
        .update({
          status,
          block_number: blockNumber,
          updated_at: new Date().toISOString()
        })
        .eq('transaction_hash', transactionHash);

      if (error) throw error;
    } catch (error) {
      console.error('Error updating transaction status:', error);
      throw error;
    }
  }

  /**
   * Get transaction history
   */
  async getTransactionHistory(
    filter: TransactionHistoryFilter
  ): Promise<SolanaTransferRecord[]> {
    try {
      let query = supabase
        .from('solana_token_transactions')
        .select('*');

      // Apply filters
      if (filter.token_id) {
        query = query.eq('token_id', filter.token_id);
      }
      if (filter.project_id) {
        query = query.eq('project_id', filter.project_id);
      }
      if (filter.from_address) {
        query = query.eq('from_address', filter.from_address);
      }
      if (filter.to_address) {
        query = query.eq('to_address', filter.to_address);
      }
      if (filter.network) {
        query = query.eq('network', filter.network);
      }
      if (filter.status) {
        query = query.eq('status', filter.status);
      }
      if (filter.start_date) {
        query = query.gte('timestamp', filter.start_date);
      }
      if (filter.end_date) {
        query = query.lte('timestamp', filter.end_date);
      }

      // Order and limit
      query = query
        .order('timestamp', { ascending: false })
        .limit(filter.limit || 100);

      const { data, error } = await query;

      if (error) throw error;

      return data || [];
    } catch (error) {
      console.error('Error fetching transaction history:', error);
      throw error;
    }
  }

  /**
   * Get token transfer count
   */
  async getTokenTransferCount(tokenId: string): Promise<number> {
    try {
      const { count, error } = await supabase
        .from('solana_token_transactions')
        .select('*', { count: 'exact', head: true })
        .eq('token_id', tokenId)
        .eq('status', 'confirmed');

      if (error) throw error;

      return count || 0;
    } catch (error) {
      console.error('Error getting transfer count:', error);
      return 0;
    }
  }

  /**
   * Get total volume for token
   */
  async getTokenTotalVolume(tokenId: string): Promise<string> {
    try {
      const { data, error } = await supabase
        .from('solana_token_transactions')
        .select('amount')
        .eq('token_id', tokenId)
        .eq('status', 'confirmed');

      if (error) throw error;

      const total = (data || []).reduce((sum, tx) => {
        return sum + BigInt(tx.amount);
      }, BigInt(0));

      return total.toString();
    } catch (error) {
      console.error('Error calculating total volume:', error);
      return '0';
    }
  }
}

// Export singleton instance
export const solanaTokenTransactionService = new SolanaTokenTransactionService();
export default solanaTokenTransactionService;
