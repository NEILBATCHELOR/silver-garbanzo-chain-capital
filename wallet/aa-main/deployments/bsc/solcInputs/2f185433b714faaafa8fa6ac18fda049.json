{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC1271 standard signature validation method for\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\n *\n * _Available since v4.1._\n */\ninterface IERC1271 {\n    /**\n     * @dev Should return whether the signature provided is valid for the provided data\n     * @param hash      Hash of the data to be signed\n     * @param signature Signature byte array associated with _data\n     */\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\n *\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\n * contract implement this interface (contract holders can be their own\n * implementer) and registering it on the\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\n *\n * See {IERC1820Registry} and {ERC1820Implementer}.\n */\ninterface IERC777Recipient {\n    /**\n     * @dev Called by an {IERC777} token contract whenever tokens are being\n     * moved or created into a registered account (`to`). The type of operation\n     * is conveyed by `from` being the zero address or not.\n     *\n     * This call occurs _after_ the token contract's state is updated, so\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\n     *\n     * This function may revert to prevent the operation from being executed.\n     */\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata userData,\n        bytes calldata operatorData\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSA.sol\";\nimport \"../../interfaces/IERC1271.sol\";\n\n/**\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\n * Argent and Gnosis Safe.\n *\n * _Available since v4.1._\n */\nlibrary SignatureChecker {\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\n        return\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\n            isValidERC1271SignatureNow(signer, hash, signature);\n    }\n\n    /**\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\n     * against the signer smart contract using ERC1271.\n     *\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\n     */\n    function isValidERC1271SignatureNow(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal view returns (bool) {\n        (bool success, bytes memory result) = signer.staticcall(\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\n        );\n        return (success &&\n            result.length >= 32 &&\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/aa-4337/core/BaseAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-empty-blocks */\n\nimport \"../interfaces/IAccount.sol\";\nimport \"../interfaces/IEntryPoint.sol\";\nimport \"./Helpers.sol\";\n\n/**\n * Basic account implementation.\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\n * specific account implementation should inherit it and provide the account-specific logic\n */\nabstract contract BaseAccount is IAccount {\n    using UserOperationLib for UserOperation;\n\n    //return value in case of signature failure, with no time-range.\n    // equivalent to _packValidationData(true,0,0);\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n    /**\n     * Return the account nonce.\n     * This method returns the next sequential nonce.\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\n     */\n    function getNonce() public view virtual returns (uint256) {\n        return entryPoint().getNonce(address(this), 0);\n    }\n\n    /**\n     * return the entryPoint used by this account.\n     * subclass should return the current entryPoint used by this account.\n     */\n    function entryPoint() public view virtual returns (IEntryPoint);\n\n    /**\n     * Validate user's signature and nonce.\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external virtual override returns (uint256 validationData) {\n        _requireFromEntryPoint();\n        validationData = _validateSignature(userOp, userOpHash);\n        _validateNonce(userOp.nonce);\n        _payPrefund(missingAccountFunds);\n    }\n\n    /**\n     * ensure the request comes from the known entrypoint.\n     */\n    function _requireFromEntryPoint() internal view virtual {\n        require(\n            msg.sender == address(entryPoint()),\n            \"account: not from EntryPoint\"\n        );\n    }\n\n    /**\n     * validate the signature is valid for this message.\n     * @param userOp validate the userOp.signature field\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\n     *          (also hashes the entrypoint and chain id)\n     * @return validationData signature and time-range of this operation\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If the account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function _validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) internal virtual returns (uint256 validationData);\n\n    /**\n     * Validate the nonce of the UserOperation.\n     * This method may validate the nonce requirement of this account.\n     * e.g.\n     * To limit the nonce to use sequenced UserOps only (no \"out of order\" UserOps):\n     *      `require(nonce < type(uint64).max)`\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\n     *      `require(nonce & type(uint64).max == 0)`\n     *\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\n     * action is needed by the account itself.\n     *\n     * @param nonce to validate\n     *\n     * solhint-disable-next-line no-empty-blocks\n     */\n    function _validateNonce(uint256 nonce) internal view virtual {}\n\n    /**\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\n     * subclass MAY override this method for better funds management\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\n     * it will not be required to send again)\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\n     */\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\n        if (missingAccountFunds != 0) {\n            (bool success, ) = payable(msg.sender).call{\n                value: missingAccountFunds,\n                gas: type(uint256).max\n            }(\"\");\n            (success);\n            //ignore failure (its EntryPoint's job to verify, not account.)\n        }\n    }\n}\n"
    },
    "contracts/aa-4337/core/Helpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n/* solhint-disable no-inline-assembly */\n\n/**\n * returned data from validateUserOp.\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\n * @param aggregator - address(0) - the account validated the signature by itself.\n *              address(1) - the account failed to validate the signature.\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\n * @param validAfter - this UserOp is valid only after this timestamp.\n * @param validaUntil - this UserOp is valid only up to this timestamp.\n */\nstruct ValidationData {\n    address aggregator;\n    uint48 validAfter;\n    uint48 validUntil;\n}\n\n//extract sigFailed, validAfter, validUntil.\n// also convert zero validUntil to type(uint48).max\nfunction _parseValidationData(\n    uint validationData\n) pure returns (ValidationData memory data) {\n    address aggregator = address(uint160(validationData));\n    uint48 validUntil = uint48(validationData >> 160);\n    if (validUntil == 0) {\n        validUntil = type(uint48).max;\n    }\n    uint48 validAfter = uint48(validationData >> (48 + 160));\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n// intersect account and paymaster ranges.\nfunction _intersectTimeRange(\n    uint256 validationData,\n    uint256 paymasterValidationData\n) pure returns (ValidationData memory) {\n    ValidationData memory accountValidationData = _parseValidationData(\n        validationData\n    );\n    ValidationData memory pmValidationData = _parseValidationData(\n        paymasterValidationData\n    );\n    address aggregator = accountValidationData.aggregator;\n    if (aggregator == address(0)) {\n        aggregator = pmValidationData.aggregator;\n    }\n    uint48 validAfter = accountValidationData.validAfter;\n    uint48 validUntil = accountValidationData.validUntil;\n    uint48 pmValidAfter = pmValidationData.validAfter;\n    uint48 pmValidUntil = pmValidationData.validUntil;\n\n    if (validAfter < pmValidAfter) validAfter = pmValidAfter;\n    if (validUntil > pmValidUntil) validUntil = pmValidUntil;\n    return ValidationData(aggregator, validAfter, validUntil);\n}\n\n/**\n * helper to pack the return value for validateUserOp\n * @param data - the ValidationData to pack\n */\nfunction _packValidationData(\n    ValidationData memory data\n) pure returns (uint256) {\n    return\n        uint160(data.aggregator) |\n        (uint256(data.validUntil) << 160) |\n        (uint256(data.validAfter) << (160 + 48));\n}\n\n/**\n * helper to pack the return value for validateUserOp, when not using an aggregator\n * @param sigFailed - true for signature failure, false for success\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\n * @param validAfter first timestamp this UserOperation is valid\n */\nfunction _packValidationData(\n    bool sigFailed,\n    uint48 validUntil,\n    uint48 validAfter\n) pure returns (uint256) {\n    return\n        (sigFailed ? 1 : 0) |\n        (uint256(validUntil) << 160) |\n        (uint256(validAfter) << (160 + 48));\n}\n\n/**\n * keccak function over calldata.\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\n */\nfunction calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\n    assembly {\n        let mem := mload(0x40)\n        let len := data.length\n        calldatacopy(mem, data.offset, len)\n        ret := keccak256(mem, len)\n    }\n}\n"
    },
    "contracts/aa-4337/interfaces/IAccount.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\ninterface IAccount {\n    /**\n     * Validate user's signature and nonce\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\n     * This allows making a \"simulation call\" without a valid signature\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\n     *\n     * @dev Must validate caller is the entryPoint.\n     *      Must validate the signature and nonce\n     * @param userOp the operation that is about to be executed.\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\n     *      The excess is left as a deposit in the entrypoint, for future calls.\n     *      can be withdrawn anytime using \"entryPoint.withdrawTo()\"\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\n     *         otherwise, an address of an \"authorizer\" contract.\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \"indefinite\"\n     *      <6-byte> validAfter - first timestamp this operation is valid\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\n     */\n    function validateUserOp(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256 missingAccountFunds\n    ) external returns (uint256 validationData);\n}\n"
    },
    "contracts/aa-4337/interfaces/IAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\nimport \"./UserOperation.sol\";\n\n/**\n * Aggregated Signatures validator.\n */\ninterface IAggregator {\n    /**\n     * validate aggregated signature.\n     * revert if the aggregated signature does not match the given list of operations.\n     */\n    function validateSignatures(\n        UserOperation[] calldata userOps,\n        bytes calldata signature\n    ) external view;\n\n    /**\n     * validate signature of a single userOp\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\n     * @param userOp the userOperation received from the user.\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\n     *    (usually empty, unless account and aggregator support some kind of \"multisig\"\n     */\n    function validateUserOpSignature(\n        UserOperation calldata userOp\n    ) external view returns (bytes memory sigForUserOp);\n\n    /**\n     * aggregate multiple signatures into a single value.\n     * This method is called off-chain to calculate the signature to pass with handleOps()\n     * bundler MAY use optimized custom code perform this aggregation\n     * @param userOps array of UserOperations to collect the signatures from.\n     * @return aggregatedSignature the aggregated signature\n     */\n    function aggregateSignatures(\n        UserOperation[] calldata userOps\n    ) external view returns (bytes memory aggregatedSignature);\n}\n"
    },
    "contracts/aa-4337/interfaces/IEntryPoint.sol": {
      "content": "/**\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\n ** Only one instance required on each chain.\n **/\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable avoid-low-level-calls */\n/* solhint-disable no-inline-assembly */\n/* solhint-disable reason-string */\n\nimport \"./UserOperation.sol\";\nimport \"./IStakeManager.sol\";\nimport \"./IAggregator.sol\";\nimport \"./INonceManager.sol\";\n\ninterface IEntryPoint is IStakeManager, INonceManager {\n    /***\n     * An event emitted after each successful request\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\n     * @param sender - the account that generates this request.\n     * @param paymaster - if non-null, the paymaster that pays for this request.\n     * @param nonce - the nonce value from the request.\n     * @param success - true if the sender transaction succeeded, false if reverted.\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\n     */\n    event UserOperationEvent(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address indexed paymaster,\n        uint256 nonce,\n        bool success,\n        uint256 actualGasCost,\n        uint256 actualGasUsed\n    );\n\n    /**\n     * account \"sender\" was deployed.\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\n     * @param sender the account that is deployed\n     * @param factory the factory used to deploy this account (in the initCode)\n     * @param paymaster the paymaster used by this UserOp\n     */\n    event AccountDeployed(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        address factory,\n        address paymaster\n    );\n\n    /**\n     * An event emitted if the UserOperation \"callData\" reverted with non-zero length\n     * @param userOpHash the request unique identifier.\n     * @param sender the sender of this request\n     * @param nonce the nonce used in the request\n     * @param revertReason - the return bytes from the (reverted) call to \"callData\".\n     */\n    event UserOperationRevertReason(\n        bytes32 indexed userOpHash,\n        address indexed sender,\n        uint256 nonce,\n        bytes revertReason\n    );\n\n    /**\n     * an event emitted by handleOps(), before starting the execution loop.\n     * any event emitted before this event, is part of the validation.\n     */\n    event BeforeExecution();\n\n    /**\n     * signature aggregator used by the following UserOperationEvents within this bundle.\n     */\n    event SignatureAggregatorChanged(address indexed aggregator);\n\n    /**\n     * a custom revert error of handleOps, to identify the offending op.\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\n     *  @param reason - revert reason\n     *      The string starts with a unique code \"AAmn\", where \"m\" is \"1\" for factory, \"2\" for account and \"3\" for paymaster issues,\n     *      so a failure can be attributed to the correct entity.\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\n     */\n    error FailedOp(uint256 opIndex, string reason);\n\n    /**\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\n     */\n    error SignatureValidationFailed(address aggregator);\n\n    /**\n     * Successful result from simulateValidation.\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     */\n    error ValidationResult(\n        ReturnInfo returnInfo,\n        StakeInfo senderInfo,\n        StakeInfo factoryInfo,\n        StakeInfo paymasterInfo\n    );\n\n    /**\n     * Successful result from simulateValidation, if the account returns a signature aggregator\n     * @param returnInfo gas and time-range returned values\n     * @param senderInfo stake information about the sender\n     * @param factoryInfo stake information about the factory (if any)\n     * @param paymasterInfo stake information about the paymaster (if any)\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\n     */\n    error ValidationResultWithAggregation(\n        ReturnInfo returnInfo,\n        StakeInfo senderInfo,\n        StakeInfo factoryInfo,\n        StakeInfo paymasterInfo,\n        AggregatorStakeInfo aggregatorInfo\n    );\n\n    /**\n     * return value of getSenderAddress\n     */\n    error SenderAddressResult(address sender);\n\n    /**\n     * return value of simulateHandleOp\n     */\n    error ExecutionResult(\n        uint256 preOpGas,\n        uint256 paid,\n        uint48 validAfter,\n        uint48 validUntil,\n        bool targetSuccess,\n        bytes targetResult\n    );\n\n    //UserOps handled, per aggregator\n    struct UserOpsPerAggregator {\n        UserOperation[] userOps;\n        // aggregator address\n        IAggregator aggregator;\n        // aggregated signature\n        bytes signature;\n    }\n\n    /**\n     * Execute a batch of UserOperation.\n     * no signature aggregator is used.\n     * if any account requires an aggregator (that is, it returned an aggregator when\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\n     * @param ops the operations to execute\n     * @param beneficiary the address to receive the fees\n     */\n    function handleOps(\n        UserOperation[] calldata ops,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * Execute a batch of UserOperation with Aggregators\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\n     * @param beneficiary the address to receive the fees\n     */\n    function handleAggregatedOps(\n        UserOpsPerAggregator[] calldata opsPerAggregator,\n        address payable beneficiary\n    ) external;\n\n    /**\n     * generate a request Id - unique identifier for this request.\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\n     */\n    function getUserOpHash(\n        UserOperation calldata userOp\n    ) external view returns (bytes32);\n\n    /**\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\n     * @param userOp the user operation to validate.\n     */\n    function simulateValidation(UserOperation calldata userOp) external;\n\n    /**\n     * gas and return values during simulation\n     * @param preOpGas the gas used for validation (including preValidationGas)\n     * @param prefund the required prefund for this operation\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\n     */\n    struct ReturnInfo {\n        uint256 preOpGas;\n        uint256 prefund;\n        bool sigFailed;\n        uint48 validAfter;\n        uint48 validUntil;\n        bytes paymasterContext;\n    }\n\n    /**\n     * returned aggregated signature info.\n     * the aggregator returned by the account, and its current stake.\n     */\n    struct AggregatorStakeInfo {\n        address aggregator;\n        StakeInfo stakeInfo;\n    }\n\n    /**\n     * Get counterfactual sender address.\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\n     * this method always revert, and returns the address in SenderAddressResult error\n     * @param initCode the constructor code to be passed into the UserOperation.\n     */\n    function getSenderAddress(bytes memory initCode) external;\n\n    /**\n     * simulate full execution of a UserOperation (including both validation and target execution)\n     * this method will always revert with \"ExecutionResult\".\n     * it performs full validation of the UserOperation, but ignores signature error.\n     * an optional target address is called after the userop succeeds, and its value is returned\n     * (before the entire call is reverted)\n     * Note that in order to collect the the success/failure of the target call, it must be executed\n     * with trace enabled to track the emitted events.\n     * @param op the UserOperation to simulate\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\n     *        are set to the return from that call.\n     * @param targetCallData callData to pass to target address\n     */\n    function simulateHandleOp(\n        UserOperation calldata op,\n        address target,\n        bytes calldata targetCallData\n    ) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/INonceManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ninterface INonceManager {\n    /**\n     * Return the next nonce for this sender.\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\n     * But UserOp with different keys can come with arbitrary order.\n     *\n     * @param sender the account address\n     * @param key the high 192 bit of the nonce\n     * @return nonce a full nonce to pass for next UserOp with this sender.\n     */\n    function getNonce(\n        address sender,\n        uint192 key\n    ) external view returns (uint256 nonce);\n\n    /**\n     * Manually increment the nonce of the sender.\n     * This method is exposed just for completeness..\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\n     * as the EntryPoint will update the nonce regardless.\n     * Possible use-case is call it with various keys to \"initialize\" their nonces to one, so that future\n     * UserOperations will not pay extra for the first transaction with a given key.\n     */\n    function incrementNonce(uint192 key) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/IStakeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity ^0.8.12;\n\n/**\n * manage deposits and stakes.\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\n * stake is value locked for at least \"unstakeDelay\" by the staked entity.\n */\ninterface IStakeManager {\n    event Deposited(address indexed account, uint256 totalDeposit);\n\n    event Withdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /// Emitted when stake or unstake delay are modified\n    event StakeLocked(\n        address indexed account,\n        uint256 totalStaked,\n        uint256 unstakeDelaySec\n    );\n\n    /// Emitted once a stake is scheduled for withdrawal\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\n\n    event StakeWithdrawn(\n        address indexed account,\n        address withdrawAddress,\n        uint256 amount\n    );\n\n    /**\n     * @param deposit the entity's deposit\n     * @param staked true if this entity is staked.\n     * @param stake actual amount of ether staked for this entity.\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\n     *    and the rest fit into a 2nd cell.\n     *    112 bit allows for 10^15 eth\n     *    48 bit for full timestamp\n     *    32 bit allows 150 years for unstake delay\n     */\n    struct DepositInfo {\n        uint112 deposit;\n        bool staked;\n        uint112 stake;\n        uint32 unstakeDelaySec;\n        uint48 withdrawTime;\n    }\n\n    //API struct used by getStakeInfo and simulateValidation\n    struct StakeInfo {\n        uint256 stake;\n        uint256 unstakeDelaySec;\n    }\n\n    /// @return info - full deposit information of given account\n    function getDepositInfo(\n        address account\n    ) external view returns (DepositInfo memory info);\n\n    /// @return the deposit (for gas payment) of the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * add to the deposit of the given account\n     */\n    function depositTo(address account) external payable;\n\n    /**\n     * add to the account's stake - amount and delay\n     * any pending unstake is first cancelled.\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\n     */\n    function addStake(uint32 _unstakeDelaySec) external payable;\n\n    /**\n     * attempt to unlock the stake.\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\n     */\n    function unlockStake() external;\n\n    /**\n     * withdraw from the (unlocked) stake.\n     * must first call unlockStake and wait for the unstakeDelay to pass\n     * @param withdrawAddress the address to send withdrawn value.\n     */\n    function withdrawStake(address payable withdrawAddress) external;\n\n    /**\n     * withdraw from the deposit.\n     * @param withdrawAddress the address to send withdrawn value.\n     * @param withdrawAmount the amount to withdraw.\n     */\n    function withdrawTo(\n        address payable withdrawAddress,\n        uint256 withdrawAmount\n    ) external;\n}\n"
    },
    "contracts/aa-4337/interfaces/UserOperation.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\n/* solhint-disable no-inline-assembly */\n\nimport {calldataKeccak} from \"../core/Helpers.sol\";\n\n/**\n * User Operation struct\n * @param sender the sender account of this request.\n * @param nonce unique value the sender uses to verify it is not a replay.\n * @param initCode if set, the account contract will be created by this constructor/\n * @param callData the method call to execute on this account.\n * @param callGasLimit the gas limit passed to the callData method call.\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\n * @param maxFeePerGas same as EIP-1559 gas parameter.\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\n */\nstruct UserOperation {\n    address sender;\n    uint256 nonce;\n    bytes initCode;\n    bytes callData;\n    uint256 callGasLimit;\n    uint256 verificationGasLimit;\n    uint256 preVerificationGas;\n    uint256 maxFeePerGas;\n    uint256 maxPriorityFeePerGas;\n    bytes paymasterAndData;\n    bytes signature;\n}\n\n/**\n * Utility functions helpful when working with UserOperation structs.\n */\nlibrary UserOperationLib {\n    function getSender(\n        UserOperation calldata userOp\n    ) internal pure returns (address) {\n        address data;\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\n        assembly {\n            data := calldataload(userOp)\n        }\n        return address(uint160(data));\n    }\n\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\n    // pay above what he signed for.\n    function gasPrice(\n        UserOperation calldata userOp\n    ) internal view returns (uint256) {\n        unchecked {\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n            if (maxFeePerGas == maxPriorityFeePerGas) {\n                //legacy mode (for networks that don't support basefee opcode)\n                return maxFeePerGas;\n            }\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\n        }\n    }\n\n    function pack(\n        UserOperation calldata userOp\n    ) internal pure returns (bytes memory ret) {\n        address sender = getSender(userOp);\n        uint256 nonce = userOp.nonce;\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\n        uint256 callGasLimit = userOp.callGasLimit;\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\n        uint256 preVerificationGas = userOp.preVerificationGas;\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\n\n        return\n            abi.encode(\n                sender,\n                nonce,\n                hashInitCode,\n                hashCallData,\n                callGasLimit,\n                verificationGasLimit,\n                preVerificationGas,\n                maxFeePerGas,\n                maxPriorityFeePerGas,\n                hashPaymasterAndData\n            );\n    }\n\n    function hash(\n        UserOperation calldata userOp\n    ) internal pure returns (bytes32) {\n        return keccak256(pack(userOp));\n    }\n\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/facets/AccountFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"../aa-4337/interfaces/UserOperation.sol\";\nimport {IEntryPoint} from \"../aa-4337/interfaces/IEntryPoint.sol\";\nimport {BaseAccount} from \"../aa-4337/core/BaseAccount.sol\";\nimport {LibAppStorage, BarzStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../libraries/LibLoupe.sol\";\nimport {IFacetRegistry} from \"../infrastructure/interfaces/IFacetRegistry.sol\";\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\nimport {IERC1271} from \"../interfaces/ERC/IERC1271.sol\";\nimport {IAccountFacet} from \"./interfaces/IAccountFacet.sol\";\n\n/**\n * @title Account Facet\n * @dev Account module contract that provides the account features and initialization of signer\n *      compatible with EIP-1271 & EIP-4337\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract AccountFacet is BarzStorage, BaseAccount, IAccountFacet {\n    using ECDSA for bytes32;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceAccountInitialize();\n    }\n\n    /**\n     * @notice Returns the address of EntryPoint contract registered to Barz account\n     */\n    function entryPoint() public view override returns (IEntryPoint) {\n        return s.entryPoint;\n    }\n\n    /**\n     * @notice Initializes the initial storage of the Barz contract.\n     * @dev This method can only be called during the initialization or signature migration.\n     *      If the proxy contract was created without initialization, anyone can call initialize.\n     *      Barz calls initialize in constructor in an atomic transaction during deployment\n     * @param _verificationFacet Facet contract handling the verificationi\n     * @param _anEntryPoint Entrypoint contract defined in EIP-4337 handling the flow of UserOp\n     * @param _facetRegistry Registry of Facets that hold all facet information\n     * @param _defaultFallBackHandler Middleware contract for default facets\n     * @param _ownerPublicKey Bytes of owner public key\n     */\n    function initialize(\n        address _verificationFacet,\n        address _anEntryPoint,\n        address _facetRegistry,\n        address _defaultFallBackHandler,\n        bytes calldata _ownerPublicKey\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceAccountInitialize();\n        s.entryPoint = IEntryPoint(_anEntryPoint);\n        s.facetRegistry = IFacetRegistry(_facetRegistry);\n        LibDiamond.diamondStorage().defaultFallbackHandler = IDiamondLoupe(\n            _defaultFallBackHandler\n        );\n\n        _cutDiamondAccountFacet(_verificationFacet);\n\n        bytes memory initCall = abi.encodeWithSignature(\n            \"initializeSigner(bytes)\",\n            _ownerPublicKey\n        );\n        // Every Verification Facet should comply with initializeSigner(bytes)\n        // to be compatible with the Barz contract(for initialization)\n        (bool success, bytes memory result) = _verificationFacet.delegatecall(\n            initCall\n        );\n        if (!success || uint256(bytes32(result)) != 1) {\n            revert AccountFacet__InitializationFailure();\n        }\n\n        initSuccess = 1;\n        emit AccountInitialized(s.entryPoint, _ownerPublicKey);\n    }\n\n    function _cutDiamondAccountFacet(address _verificationFacet) internal {\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n\n        bytes4 ownerVerificationFuncSelector = IVerificationFacet(\n            _verificationFacet\n        ).validateOwnerSignatureSelector();\n\n        bytes4[] memory verificationFunctionSelectors = new bytes4[](3);\n        verificationFunctionSelectors[0] = IERC1271.isValidSignature.selector;\n        verificationFunctionSelectors[1] = ownerVerificationFuncSelector;\n        verificationFunctionSelectors[2] = IVerificationFacet.owner.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _verificationFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: verificationFunctionSelectors\n        });\n\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    /**\n     * @notice Calls the destination with inputted calldata and value from EntryPoint\n     * @dev This method executes the calldata coming from the EntryPoint.\n     *      Barz will make a call to this function for majority of typical execution(e.g. Swap, Token Transfer)\n     * @param _dest Address of destination where the call will be forwarded to\n     * @param _value Amount of native coin the owner is willing to send(e.g. ETH, BNB)\n     * @param _func Bytes of calldata to execute in the destination address\n     */\n    function execute(\n        address _dest,\n        uint256 _value,\n        bytes calldata _func\n    ) external override onlyWhenUnlocked {\n        _requireFromEntryPoint();\n        _call(_dest, _value, _func);\n    }\n\n    /**\n     * @notice Batch calls the destination with inputted calldata and value from EntryPoint\n     * @dev This method batch executes the calldata coming from the EntryPoint.\n     *      Barz will make a call to this function for majority of typical execution(e.g. Swap, Token Transfer)\n     * @param _dest Array of addresses of destination where the call will be forwarded to\n     * @param _value Array of amount of native coin the owner is willing to send(e.g. ETH, BNB)\n     * @param _func Array of bytes of calldata to execute in the destination address\n     */\n    function executeBatch(\n        address[] calldata _dest,\n        uint256[] calldata _value,\n        bytes[] calldata _func\n    ) external override onlyWhenUnlocked {\n        _requireFromEntryPoint();\n        require(\n            _dest.length == _func.length && _dest.length == _value.length,\n            \"wrong array lengths\"\n        );\n        for (uint256 i; i < _dest.length; ) {\n            _call(_dest[i], _value[i], _func[i]);\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Validates the signature field of UserOperation\n     * @dev This method validates if the signature of UserOp is indeed valid by delegating the call to Verification Facet\n     *      Barz makes a call to the pre-registered Verification Facet address in App Storage\n     * @param _userOp UserOperation from owner to be validated\n     * @param _userOpHash Hash of UserOperation given from the EntryPoint contract\n     */\n    function _validateSignature(\n        UserOperation calldata _userOp,\n        bytes32 _userOpHash\n    ) internal override returns (uint256 validationData) {\n        // Get Facet with Function Selector\n        address facet = LibLoupe.facetAddress(s.validateOwnerSignatureSelector);\n        if (facet == address(0))\n            revert AccountFacet__NonExistentVerificationFacet();\n\n        // Make function call to VerificationFacet\n        bytes memory validateCall = abi.encodeWithSelector(\n            s.validateOwnerSignatureSelector,\n            _userOp,\n            _userOpHash\n        );\n        (bool success, bytes memory result) = facet.delegatecall(validateCall);\n        if (!success) revert AccountFacet__CallNotSuccessful();\n        validationData = uint256(bytes32(result));\n        if (validationData == 0) emit VerificationSuccess(_userOpHash);\n        else emit VerificationFailure(_userOpHash);\n    }\n\n    /**\n     * @notice Calls the target with the inputted value and calldata\n     * @dev This method is the actual function in Barz that makes a call with an arbitrary owner-given data\n     * @param _target Address of the destination contract which the call is getting forwarded to\n     * @param _value Amount of Native coin the owner is wanting to make in this call\n     * @param _data Calldata the owner is forwarding together in the call e.g. Swap/Token Transfer\n     */\n    function _call(\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal {\n        address facet = LibDiamond.restrictionsFacet();\n        // NOTE: No restrictions facet, so restriction validation passes\n        if (facet != address(0)) {\n            if (_checkRestrictions(facet, _target, _value, _data) == 1)\n                revert AccountFacet__RestrictionsFailure();\n        }\n\n        (bool success, bytes memory result) = _target.call{value: _value}(\n            _data\n        );\n        if (!success) {\n            assembly {\n                revert(add(result, 32), mload(result))\n            }\n        }\n    }\n\n    /**\n     * @notice Checks restrictions if the restrictions facet exists\n     * @dev This method checks if the restrictions facet exists and makes a verification call to an array of restrictions facet\n     * @param _facet Address that holds the restrictions logic\n     * @param _target Address the call is getting forwarded to\n     * @param _value Amount of native coin the call is sending together with the call\n     * @param _data Calldata to trigger execution in target address\n     */\n    function _checkRestrictions(\n        address _facet,\n        address _target,\n        uint256 _value,\n        bytes memory _data\n    ) internal returns (uint256 result) {\n        bytes memory call = abi.encodeWithSignature(\n            \"verifyRestrictions(address,address,uint256,bytes)\",\n            address(this),\n            _target,\n            _value,\n            _data\n        );\n        (bool success, bytes memory response) = _facet.delegatecall(call);\n        if (!success) revert AccountFacet__RestrictionsFailure();\n        result = uint256(bytes32(response));\n    }\n}\n"
    },
    "contracts/facets/AccountRecoveryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {LibAppStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../libraries/LibLoupe.sol\";\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {LibFacetStorage, RecoveryStorage, RecoveryConfig, RecoveryApprovalConfig, ApprovalConfig} from \"../libraries/LibFacetStorage.sol\";\nimport {Modifiers} from \"./Modifiers.sol\";\nimport {ISecurityManager} from \"../infrastructure/interfaces/ISecurityManager.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\nimport {IAccountRecoveryFacet} from \"./interfaces/IAccountRecoveryFacet.sol\";\n\n/**\n * @title Account Recovery Facet\n * @dev Contract that enables recovery of accounts when owner key is unavailable\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract AccountRecoveryFacet is IAccountRecoveryFacet, Modifiers {\n    bytes constant UNINIT_CALL =\n        abi.encodeWithSignature(\"uninitializeSigner()\");\n    ISecurityManager public immutable securityManager;\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    /**\n     * @notice Approve recovery of account as guardian\n     * @dev This method can only be called by guardian and guardian inputs the public key of the new owner\n     *      When the threshold(majority of guardians) passes, it automatically executes account recovery\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function approveAccountRecovery(\n        bytes calldata _recoveryPublicKey\n    ) external override onlyGuardian {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        validateNewOwner(_recoveryPublicKey);\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"ExecuteRecovery\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + _getApprovalValidationPeriod()\n        );\n        rs.isNewOwnerApproved[recoveryPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit RecoveryApproved(\n            _recoveryPublicKey,\n            msg.sender,\n            approvalValidUntil\n        );\n        if (\n            getRecoveryApprovalCountWithTimeValidity(recoveryPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians()\n        ) _executeRecovery(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Revoke recovery of account as guardian\n     * @dev This method can only be called by guardian and guardian inputs the public key of the new owner\n            When the threshold(majority of guardians) passes, it automatically revokes account recovery when recovery is pending\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function revokeAccountRecoveryApproval(\n        bytes calldata _recoveryPublicKey\n    ) external override onlyGuardian {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        validateNewOwner(_recoveryPublicKey);\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"ExecuteRecovery\"\n        );\n        if (\n            !rs\n            .isNewOwnerApproved[recoveryPublicKeyHash][msg.sender].isApproved ||\n            !(block.timestamp <\n                rs\n                .isNewOwnerApproved[recoveryPublicKeyHash][msg.sender]\n                    .validUntil)\n        ) revert AccountRecoveryFacet__NonExistentApproval();\n\n        rs.isNewOwnerApproved[recoveryPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(false, 0);\n        emit RecoveryApprovalRevoked(_recoveryPublicKey, msg.sender);\n    }\n\n    /**\n     * @notice Executes recovery with signatures or on-chain pre-approvals\n     * @dev This method validates the signatures of guardians or checks the on-chain pre-approved calls to check if the threshold passes\n     *      When the threshold passes, account recovery is executed and revert otherwise\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     * @param _guardians Array of guardians address that are approving the recovery of Account\n     * @param _signatures Array of signature bytes that signed the approval hash\n     */\n    function executeRecovery(\n        bytes calldata _recoveryPublicKey,\n        address[] calldata _guardians,\n        bytes[] calldata _signatures\n    ) external override {\n        if (_isRecoveryPending())\n            revert AccountRecoveryFacet__RecoveryAlreadyOngoing();\n        if (_guardians.length != _signatures.length)\n            revert AccountRecoveryFacet__InvalidArrayLength();\n        validateNewOwner(_recoveryPublicKey);\n\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"ExecuteRecovery\"\n        );\n\n        _checkApprover(_guardians);\n        _checkDuplicateOnChainApprover(recoveryPublicKeyHash, _guardians);\n\n        if (\n            _guardians.length +\n                getRecoveryApprovalCountWithTimeValidity(\n                    recoveryPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians()\n        ) revert AccountRecoveryFacet__InsufficientGuardians();\n        for (uint256 i; i < _guardians.length; ) {\n            if (!LibGuardian.isGuardian(_guardians[i]))\n                revert AccountRecoveryFacet__InvalidGuardian();\n            if (\n                !SignatureChecker.isValidSignatureNow(\n                    _guardians[i],\n                    recoveryPublicKeyHash,\n                    _signatures[i]\n                )\n            ) revert AccountRecoveryFacet__InvalidGuardianSignature();\n            unchecked {\n                ++i;\n            }\n        }\n        _executeRecovery(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Executes recovery of the account. Note that execution and finalization is a different process\n     * @dev Executes the recovery and adds recovery data to recovery configuration. Locks the account\n     * @param _recoveryPublicKey Public Key of the account for recovery\n     */\n    function _executeRecovery(bytes memory _recoveryPublicKey) internal {\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        ++rs.nonce;\n        uint64 executeAfter = uint64(block.timestamp + _getRecoveryPeriod());\n        rs.recoveryConfigs[INNER_STRUCT] = RecoveryConfig(\n            _recoveryPublicKey,\n            executeAfter // NOTE: Remove guardian Count\n        );\n        LibAppStorage.setLock(\n            block.timestamp + _getLockPeriod(),\n            AccountRecoveryFacet.executeRecovery.selector\n        );\n        emit RecoveryExecuted(_recoveryPublicKey, executeAfter);\n    }\n\n    /**\n     * @notice Finalize recovery after recovery pending period. Recovery pending period can be set by user beforehand in SecurityManager\n     * @dev This method finalizes recovery and fully changes the ownership of the account to the newly inputted recovery public key\n     */\n    function finalizeRecovery() external override {\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n\n        if (!_isRecoveryPending())\n            revert AccountRecoveryFacet__NonexistentRecovery();\n        if (\n            uint64(block.timestamp) <=\n            rs.recoveryConfigs[INNER_STRUCT].executeAfter\n        ) revert AccountRecoveryFacet__RecoveryPeriodNotOver();\n        bytes memory recoveryOwner = rs\n            .recoveryConfigs[INNER_STRUCT]\n            .recoveryPublicKey;\n\n        delete rs.recoveryConfigs[INNER_STRUCT];\n\n        LibAppStorage.setLock(0, bytes4(0));\n\n        LibAppStorage.initiateSignerMigration();\n        address verificationFacet = address(\n            bytes20(\n                LibDiamond.diamondStorage().facets[\n                    s.validateOwnerSignatureSelector\n                ]\n            )\n        );\n        (bool success, bytes memory result) = verificationFacet.delegatecall(\n            UNINIT_CALL\n        );\n        if (!success) revert AccountRecoveryFacet__CallNotSuccesful();\n        uint256 validationData = uint256(bytes32(result));\n        if (validationData != 1)\n            revert AccountRecoveryFacet__SignerUninitializationFailure();\n        bytes memory initCall = abi.encodeWithSignature(\n            \"initializeSigner(bytes)\",\n            recoveryOwner\n        );\n        (success, result) = verificationFacet.delegatecall(initCall);\n        if (!success) revert AccountRecoveryFacet__CallNotSuccesful();\n        validationData = uint256(bytes32(result));\n        if (validationData != 1)\n            revert AccountRecoveryFacet__SignerInitializationFailure();\n        LibAppStorage.finalizeSignerMigration();\n        emit RecoveryFinalized(recoveryOwner);\n    }\n\n    /**\n     * @notice Approves the cancellation of recovery\n     * @dev This method approves the cancellation of recovery when recovery is still pending - waiting for finalization\n     * @param _recoveryPublicKey Bytes of public key which is pending for recovery\n     */\n    function approveCancelRecovery(\n        bytes calldata _recoveryPublicKey\n    ) external override onlyGuardian {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        validateNewOwner(_recoveryPublicKey);\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"CancelRecovery\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + _getApprovalValidationPeriod()\n        );\n        rs.isNewOwnerApproved[recoveryPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit RecoveryCancellationApproved(_recoveryPublicKey, msg.sender);\n        if (\n            getRecoveryApprovalCountWithTimeValidity(recoveryPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians()\n        ) {\n            _cancelRecovery(_recoveryPublicKey);\n        }\n    }\n\n    /**\n     * @notice Hardstops an ongoing recovery\n     * @dev This method provides a safety mechanism to protect owners of malicious guardians.\n     *      Owners can hardstop recovery when an malicious guardians starts the recovery process.\n     * @param _signature Signature of the owner that signs the hash to hardstop recovery\n     */\n    function hardstopRecovery(bytes calldata _signature) external override {\n        if (!_isRecoveryPending())\n            revert AccountRecoveryFacet__NonexistentRecovery();\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            \"0\",\n            \"HardstopRecovery\"\n        );\n        if (\n            !SignatureChecker.isValidSignatureNow(\n                address(this),\n                recoveryPublicKeyHash,\n                _signature\n            )\n        ) revert AccountRecoveryFacet__InvalidOwnerSignature();\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        ++rs.nonce;\n        delete rs.recoveryConfigs[INNER_STRUCT];\n        LibAppStorage.setLock(0, bytes4(0));\n        emit RecoveryHardstopped();\n    }\n\n    /**\n     * @notice Cancels recovery with signatures or on-chain pre-approvals\n     * @dev This method validates the signatures of guardians or checks the on-chain pre-approved calls to check if the threshold passes\n     *      When the threshold passes, account recovery is canceled and revert otherwise\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     * @param _guardians Array of guardians address that are approving the recovery of Account\n     * @param _signatures Array of signature bytes that signed the cancellation approval hash\n     */\n    function cancelRecovery(\n        bytes calldata _recoveryPublicKey,\n        address[] calldata _guardians,\n        bytes[] calldata _signatures\n    ) external override {\n        if (_guardians.length != _signatures.length)\n            revert AccountRecoveryFacet__InvalidArrayLength();\n        validateNewOwner(_recoveryPublicKey);\n\n        bytes32 recoveryPublicKeyHash = getApprovalRecoveryKeyHash(\n            _recoveryPublicKey,\n            \"CancelRecovery\"\n        );\n\n        _checkApprover(_guardians);\n        _checkDuplicateOnChainApprover(recoveryPublicKeyHash, _guardians);\n\n        if (\n            _guardians.length +\n                getRecoveryApprovalCountWithTimeValidity(\n                    recoveryPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians()\n        ) revert AccountRecoveryFacet__InsufficientGuardians();\n        for (uint256 i; i < _guardians.length; ) {\n            if (!LibGuardian.isGuardian(_guardians[i]))\n                revert AccountRecoveryFacet__CallerNotGuardian();\n            if (\n                !SignatureChecker.isValidSignatureNow(\n                    _guardians[i],\n                    recoveryPublicKeyHash,\n                    _signatures[i]\n                )\n            ) revert AccountRecoveryFacet__InvalidGuardianSignature();\n            unchecked {\n                ++i;\n            }\n        }\n        _cancelRecovery(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Cancel recovery when the recovery is pending. Unlock the account as well\n     * @dev This method checks if the recovery is pending and reverts if not pending.\n     *      It increases the recovery nonce and deletes the recovery information and gets a small portion of gas in return\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function _cancelRecovery(bytes memory _recoveryPublicKey) internal {\n        if (!_isRecoveryPending())\n            revert AccountRecoveryFacet__NonexistentRecovery();\n        LibAppStorage.setLock(0, bytes4(0));\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        ++rs.nonce;\n        delete rs.recoveryConfigs[INNER_STRUCT];\n        emit RecoveryCanceled(_recoveryPublicKey);\n    }\n\n    /**\n     * @notice Validates the format of public key to be used for recovery\n     * @dev This method checks if the public key format is correct and reverts otherwise\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     */\n    function validateNewOwner(bytes memory _recoveryPublicKey) public view {\n        if (\n            !IVerificationFacet(\n                LibLoupe.facetAddress(s.validateOwnerSignatureSelector)\n            ).isValidKeyType(_recoveryPublicKey)\n        ) revert AccountRecoveryFacet__InvalidRecoveryPublicKey();\n    }\n\n    /**\n     * @notice Checks if recovery is currently pending\n     * @return isPending Boolean indicating if recovery is pending\n     */\n    function _isRecoveryPending() internal view returns (bool isPending) {\n        RecoveryStorage storage rs = LibFacetStorage.recoveryStorage();\n        isPending = (rs.recoveryConfigs[INNER_STRUCT].executeAfter > 0);\n    }\n\n    /**\n     * @notice Calculate the recovery hash dependent on chain, wallet address, nonce with EIP-191 prefix for safety\n     * @dev Returns the keccak256 hash of EIP-191 msg hash packed with public key, salt, nonce, wallet address, etc\n     * @param _recoveryPublicKey Bytes of newly recovered public key of the owner\n     * @param _saltString Salt string to uniquely identify each recovery hash and for security\n     * @return recoveryKeyHash Bytes32 string of the recovery hash\n     */\n    function getApprovalRecoveryKeyHash(\n        bytes memory _recoveryPublicKey,\n        string memory _saltString\n    ) public view override returns (bytes32 recoveryKeyHash) {\n        recoveryKeyHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        _recoveryPublicKey,\n                        _saltString,\n                        address(this),\n                        block.chainid,\n                        LibFacetStorage.recoveryStorage().nonce\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Check the onchain approval of guardians and returns the number of guardians that approved\n     * @dev Loop through the guardian addresses and returns the number of guardians that approved this recovery hash\n     * @param _recoveryPublicKeyHash Bytes hash of newly recovered public key and recovery value of the account\n     * @return approvalCount Number of guardians that approved\n     */\n    function getRecoveryApprovalCountWithTimeValidity(\n        bytes32 _recoveryPublicKeyHash\n    ) public view override returns (uint256 approvalCount) {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isRecoveryApproved(_recoveryPublicKeyHash, guardians[i])) {\n                unchecked {\n                    ++approvalCount;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Checks if the recovery is approved by the given approver\n     * @param _recoveryPublicKeyHash Hash of the public key and configuration for recovery\n     * @param _approver Address of approver\n     * @return isApproved Bool value if recovery hash is approved\n     */\n    function isRecoveryApproved(\n        bytes32 _recoveryPublicKeyHash,\n        address _approver\n    ) public view override returns (bool isApproved) {\n        RecoveryApprovalConfig storage rs = LibFacetStorage\n            .recoveryStorage()\n            .recoveryApprovalConfigs[INNER_STRUCT];\n        if (\n            rs\n            .isNewOwnerApproved[_recoveryPublicKeyHash][_approver].isApproved &&\n            block.timestamp <\n            rs.isNewOwnerApproved[_recoveryPublicKeyHash][_approver].validUntil\n        ) {\n            isApproved = true;\n        }\n    }\n\n    /**\n     * @notice Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval\n     *         Approvers who approved on-chain should not be included in the off-chain approval\n     * @param _recoveryPublicKeyHash Hash of recovery information\n     * @param _approvers List of approver addresses\n     */\n    function _checkDuplicateOnChainApprover(\n        bytes32 _recoveryPublicKeyHash,\n        address[] memory _approvers\n    ) public view {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        uint256 approversLength = _approvers.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isRecoveryApproved(_recoveryPublicKeyHash, guardians[i])) {\n                for (uint256 j; j < approversLength; ) {\n                    if (_approvers[j] == guardians[i])\n                        revert AccountRecoveryFacet__DuplicateApproval();\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the lock period of this wallet address from security manager\n     * @return lockPeriod value of lock period\n     */\n    function _getLockPeriod() internal view returns (uint256 lockPeriod) {\n        lockPeriod = securityManager.lockPeriodOf(address(this));\n        if (lockPeriod == 0) revert AccountRecoveryFacet__InvalidLockPeriod();\n    }\n\n    /**\n     * @notice Returns the lock period of this wallet address from security manager\n     * @return recoveryPeriod value of recovery period\n     */\n    function _getRecoveryPeriod()\n        internal\n        view\n        returns (uint256 recoveryPeriod)\n    {\n        recoveryPeriod = securityManager.recoveryPeriodOf(address(this));\n        if (recoveryPeriod == 0)\n            revert AccountRecoveryFacet__InvalidRecoveryPeriod();\n    }\n\n    /**\n     * @notice Returns the approval validation period of this wallet address from security manager\n     * @return approvalValidationPeriod value of approval validation period\n     */\n    function _getApprovalValidationPeriod()\n        internal\n        view\n        returns (uint256 approvalValidationPeriod)\n    {\n        approvalValidationPeriod = securityManager.approvalValidationPeriodOf(\n            address(this)\n        );\n        if (approvalValidationPeriod == 0)\n            revert AccountRecoveryFacet__InvalidApprovalValidationPeriod();\n    }\n\n    /**\n     * @notice Returns the recovery nonce of this wallet address from security manager\n     * @return nonce value of recovery nonce\n     */\n    function getRecoveryNonce() public view override returns (uint128 nonce) {\n        nonce = LibFacetStorage.recoveryStorage().nonce;\n    }\n\n    /**\n     * @notice Returns the recovery information of the pending recovery\n     * @return recoveryConfig value struct of pending recovery\n     */\n    function getPendingRecovery()\n        public\n        view\n        override\n        returns (RecoveryConfig memory recoveryConfig)\n    {\n        recoveryConfig = LibFacetStorage.recoveryStorage().recoveryConfigs[\n            INNER_STRUCT\n        ];\n    }\n}\n"
    },
    "contracts/facets/base/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IERC777Recipient} from \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport {IERC165} from \"../../interfaces/ERC/IERC165.sol\";\nimport {IERC1271} from \"../../interfaces/ERC/IERC1271.sol\";\nimport {IERC677Receiver} from \"../../interfaces/ERC/IERC677Receiver.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC1155Receiver} from \"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\";\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../../libraries/LibLoupe.sol\";\nimport {LibUtils} from \"../../libraries/LibUtils.sol\";\nimport {IDiamondCut} from \"../../facets/base/interfaces/IDiamondCut.sol\";\nimport {IStorageLoupe} from \"./interfaces/IStorageLoupe.sol\";\nimport {IDiamondLoupe} from \"./interfaces/IDiamondLoupe.sol\";\n\n/**\n * @title DiamondLoupe Facet\n * @dev DiamondLoupe contract compatible with EIP-2535\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract DiamondLoupeFacet is IDiamondLoupe, IStorageLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools off-chain.\n\n    /**\n     * @notice Gets all facets and their selectors.\n     * @dev Barz uses a special architecture called default fallback handler. Default Fallback handler is used as a middleware\n     *      that holds the mapping of facet function selector and facet address that Barz uses. This helps Barz to reduce\n     *      significant amount of gas during the initialization process.\n     *      Hence, this method aggregates both the facet information from DefaulFallbackHandler and in diamond storage and shows the data to users.\n     * @return facets_ Facet\n     */\n    function facets() public view override returns (Facet[] memory facets_) {\n        Facet[] memory defaultFacet = LibDiamond\n            .diamondStorage()\n            .defaultFallbackHandler\n            .facets();\n        Facet[] memory _facets = LibLoupe.facets();\n        uint256 numFacets = _facets.length;\n        bytes4[] memory keys;\n        address[] memory values;\n        for (uint256 i; i < numFacets; ) {\n            uint256 selectorsLength = _facets[i].functionSelectors.length;\n            for (uint256 j; j < selectorsLength; ) {\n                (keys, values) = LibUtils.setValue(\n                    keys,\n                    values,\n                    _facets[i].functionSelectors[j],\n                    _facets[i].facetAddress\n                );\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        {\n            bool iIncrement;\n            for (uint256 i; i < defaultFacet.length; ) {\n                bool jIncrement;\n                for (\n                    uint256 j;\n                    j < defaultFacet[i].functionSelectors.length;\n\n                ) {\n                    if (\n                        LibUtils.getValue(\n                            keys,\n                            values,\n                            defaultFacet[i].functionSelectors[j]\n                        ) != address(0)\n                    ) {\n                        if (defaultFacet[i].functionSelectors.length == 1) {\n                            defaultFacet = LibUtils.removeFacetElement(\n                                defaultFacet,\n                                i\n                            );\n                            iIncrement = true;\n                            break;\n                        }\n                        defaultFacet[i].functionSelectors = LibUtils\n                            .removeElement(\n                                defaultFacet[i].functionSelectors,\n                                j\n                            );\n                        jIncrement = true;\n                    }\n                    if (!jIncrement) {\n                        unchecked {\n                            ++j;\n                        }\n                    } else {\n                        jIncrement = false;\n                    }\n                }\n                if (!iIncrement) {\n                    unchecked {\n                        ++i;\n                    }\n                } else {\n                    iIncrement = false;\n                }\n            }\n        }\n        {\n            uint256 facetLength = numFacets + defaultFacet.length;\n            facets_ = new Facet[](facetLength);\n            uint256 defaultFacetIndex;\n            for (uint256 i; i < facetLength; ) {\n                if (i < numFacets) {\n                    facets_[i] = _facets[i];\n                    bool jIncrementor;\n                    for (uint256 j; j < defaultFacet.length; ) {\n                        if (\n                            facets_[i].facetAddress ==\n                            defaultFacet[j].facetAddress\n                        ) {\n                            facets_[i].functionSelectors = LibUtils.mergeArrays(\n                                _facets[i].functionSelectors,\n                                defaultFacet[j].functionSelectors\n                            );\n                            defaultFacet = LibUtils.removeFacetElement(\n                                defaultFacet,\n                                j\n                            );\n                            jIncrementor = true;\n                            {\n                                facets_ = LibUtils.removeFacetElement(\n                                    facets_,\n                                    facets_.length - 1\n                                );\n                            }\n                            --facetLength;\n                        }\n                        if (!jIncrementor) {\n                            unchecked {\n                                ++j;\n                            }\n                        } else {\n                            jIncrementor = false;\n                        }\n                    }\n                } else {\n                    facets_[i] = defaultFacet[defaultFacetIndex];\n                    ++defaultFacetIndex;\n                }\n                unchecked {\n                    ++i;\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Gets all the function selectors provided by a facet.\n     * @param _facet The facet address.\n     * @return facetFunctionSelectors_\n     */\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        Facet[] memory facet = facets();\n        uint256 facetLength = facet.length;\n        for (uint256 i; i < facetLength; ) {\n            if (facet[i].facetAddress == _facet)\n                return facet[i].functionSelectors;\n            unchecked {\n                ++i;\n            }\n        }\n        return facetFunctionSelectors_;\n    }\n\n    /**\n     * @notice Get all the facet addresses used by Barz.\n     * @return facetAddresses_\n     */\n    function facetAddresses()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        Facet[] memory facet = facets();\n        uint256 facetLength = facet.length;\n        facetAddresses_ = new address[](facetLength);\n        for (uint256 i; i < facetLength; ) {\n            facetAddresses_[i] = facet[i].facetAddress;\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Gets the facet that supports the given selector.\n     * @dev If facet is not found return address(0).\n     * @param _functionSelector The function selector.\n     * @return facetAddress_ The facet address.\n     */\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n\n        facetAddress_ = address(bytes20(ds.facets[_functionSelector]));\n        if (facetAddress_ == address(0)) {\n            facetAddress_ = IDiamondLoupe(ds.defaultFallbackHandler)\n                .facetAddress(_functionSelector);\n        }\n    }\n\n    /**\n     * @notice SupportInterface to be compatible with EIP 165\n     * @param _interfaceId Interface ID for detecting the interface\n     * @return isSupported Bool value showing if the standard is supported in the contract\n     */\n    function supportsInterface(\n        bytes4 _interfaceId\n    ) external view override returns (bool isSupported) {\n        isSupported =\n            _interfaceId == type(IERC165).interfaceId ||\n            _interfaceId == IDiamondCut.diamondCut.selector ||\n            _interfaceId == type(IDiamondLoupe).interfaceId ||\n            _interfaceId == type(IERC1155Receiver).interfaceId ||\n            _interfaceId == type(IERC721Receiver).interfaceId ||\n            _interfaceId == type(IERC777Recipient).interfaceId ||\n            _interfaceId == IERC1271.isValidSignature.selector ||\n            _interfaceId == type(IERC677Receiver).interfaceId ||\n            LibDiamond.diamondStorage().supportedInterfaces[_interfaceId];\n    }\n\n    /**\n     * @notice Returns the facet from the diamond storage. This excludes the facets from the default fallback handler\n     * @return facets_ Facet information attached directly to diamond storage\n     */\n    function facetsFromStorage()\n        external\n        view\n        override\n        returns (Facet[] memory facets_)\n    {\n        facets_ = LibLoupe.facets();\n    }\n\n    /**\n     * @notice Returns the facet address attached to the given function selector. This excludes the facets from the default fallback handler\n     * @param _functionSelector Function selector to fetch the facet address from diamond storage\n     * @return facetAddress_ Facet address mapped with the function selector\n     */\n    function facetAddressFromStorage(\n        bytes4 _functionSelector\n    ) external view override returns (address facetAddress_) {\n        facetAddress_ = LibLoupe.facetAddress(_functionSelector);\n    }\n\n    /**\n     * @notice Returns all facet addresses attached directly to diamond storage. This excludes the facets from the default fallback handler\n     * @return facetAddresses_ All facet addresses attached directly to diamond storage\n     */\n    function facetAddressesFromStorage()\n        external\n        view\n        override\n        returns (address[] memory facetAddresses_)\n    {\n        facetAddresses_ = LibLoupe.facetAddresses();\n    }\n\n    /**\n     * @notice Returns function selectors of given facet address attached directly to diamond storage. This excludes the facets from the default fallback handler\n     * @param _facet Facet address to fetch the facet function selectors from diamond storage\n     * @return facetFunctionSelectors_ Facet function selectors of the given facet address\n     */\n    function facetFunctionSelectorsFromStorage(\n        address _facet\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\n        facetFunctionSelectors_ = LibLoupe.facetFunctionSelectors(_facet);\n    }\n}\n"
    },
    "contracts/facets/base/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title DiamondCut Facet Interface\n * @dev Interface for DiamondCut Facet responsible for adding/removing/replace facets in Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IDiamondCut {\n    error DiamondCutFacet__InvalidRouteWithGuardian();\n    error DiamondCutFacet__InvalidRouteWithoutGuardian();\n    error DiamondCutFacet__InvalidArrayLength();\n    error DiamondCutFacet__InsufficientApprovers();\n    error DiamondCutFacet__InvalidApprover();\n    error DiamondCutFacet__InvalidApproverSignature();\n    error DiamondCutFacet__InvalidApprovalValidationPeriod();\n    error DiamondCutFacet__CannotRevokeUnapproved();\n    error DiamondCutFacet__LackOfOwnerApproval();\n    error DiamondCutFacet__OwnerAlreadyApproved();\n    error DiamondCutFacet__DuplicateApproval();\n    error DiamondCutFacet__InvalidInitAddress();\n\n    event DiamondCutApproved(FacetCut[] diamondCut);\n    event DiamondCutApprovalRevoked(FacetCut[] diamondCut);\n\n    event SupportsInterfaceUpdated(bytes4 interfaceId, bool _lag);\n\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param diamondCut Contains the facet addresses and function selectors\n    /// @param init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata diamondCut,\n        address init,\n        bytes calldata _calldata\n    ) external;\n\n    function updateSupportsInterface(bytes4 interfaceId, bool flag) external;\n\n    function diamondCutWithGuardian(\n        FacetCut[] calldata diamondCut,\n        address[] calldata approvers,\n        bytes[] calldata signatures\n    ) external;\n\n    function approveDiamondCut(FacetCut[] calldata diamondCut) external;\n\n    function revokeDiamondCutApproval(FacetCut[] calldata diamondCut) external;\n\n    function getDiamondCutApprovalCountWithTimeValidity(\n        bytes32 diamondCutHash\n    ) external view returns (uint256);\n\n    function getOwnerCutApprovalWithTimeValidity(\n        bytes32 diamondCutHash\n    ) external view returns (bool);\n\n    function isCutApproved(\n        bytes32 diamondCutHash,\n        address approver\n    ) external view returns (bool);\n\n    function getDiamondCutHash(\n        FacetCut[] calldata diamondCut\n    ) external view returns (bytes32);\n\n    function getDiamondCutNonce() external view returns (uint128);\n}\n"
    },
    "contracts/facets/base/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(\n        address _facet\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/facets/base/interfaces/IStorageLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"./IDiamondLoupe.sol\";\n\n/**\n * @title LoupeFromStorage Interface\n * @dev Interface contract to function as a loupe facet directly attached to diamond storage of Barz\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IStorageLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facetsFromStorage()\n        external\n        view\n        returns (IDiamondLoupe.Facet[] memory);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    function facetFunctionSelectorsFromStorage(\n        address _facet\n    ) external view returns (bytes4[] memory);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    function facetAddressesFromStorage()\n        external\n        view\n        returns (address[] memory);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    function facetAddressFromStorage(\n        bytes4 _functionSelector\n    ) external view returns (address);\n}\n"
    },
    "contracts/facets/interfaces/IAccountFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IEntryPoint} from \"../../aa-4337/interfaces/IEntryPoint.sol\";\n\n/**\n * @title Account Facet Interface\n * @dev Interface of module contract that provides the account features and init/unitialization of signer\n *      compatible with EIP-1271 & EIP-4337\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IAccountFacet {\n    event AccountInitialized(\n        IEntryPoint indexed entryPoint,\n        bytes indexed ownerPublicKey\n    );\n    // NOTE: Added Below Event\n    event VerificationSuccess(bytes32);\n    event VerificationFailure(bytes32);\n\n    error AccountFacet__InitializationFailure();\n    error AccountFacet__RestrictionsFailure();\n    error AccountFacet__NonExistentVerificationFacet();\n    error AccountFacet__CallNotSuccessful();\n\n    function initialize(\n        address verificationFacet,\n        address anEntryPoint,\n        address facetRegistry,\n        address _defaultFallBack,\n        bytes calldata _ownerPublicKey\n    ) external returns (uint256);\n\n    function execute(address dest, uint256 value, bytes calldata func) external;\n\n    function executeBatch(\n        address[] calldata dest,\n        uint256[] calldata value,\n        bytes[] calldata func\n    ) external;\n}\n"
    },
    "contracts/facets/interfaces/IAccountRecoveryFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {RecoveryConfig} from \"../../libraries/LibFacetStorage.sol\";\n\n/**\n * @title Account Recovery Facet Interface\n * @dev Interface of contract that enables recovery of accounts when owner key is unavailable\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IAccountRecoveryFacet {\n    event RecoveryExecuted(\n        bytes indexed recoveryPublicKey,\n        uint64 executeAfter\n    );\n    event RecoveryFinalized(bytes indexed recoveryPublicKey);\n    event RecoveryCanceled(bytes indexed recoveryPublicKey);\n    event RecoveryApproved(\n        bytes indexed recoveryPublicKey,\n        address indexed guardian,\n        uint64 validUntil\n    );\n    event RecoveryApprovalRevoked(\n        bytes indexed recoveryPublicKey,\n        address indexed guardian\n    );\n    event RecoveryCancellationApproved(\n        bytes indexed recoveryPublicKey,\n        address indexed guardian\n    );\n    event RecoveryHardstopped();\n\n    error AccountRecoveryFacet__CallerNotGuardian();\n    error AccountRecoveryFacet__InvalidRecoveryPublicKey();\n    error AccountRecoveryFacet__SignerInitializationFailure();\n    error AccountRecoveryFacet__SignerUninitializationFailure();\n    error AccountRecoveryFacet__InvalidArrayLength();\n    error AccountRecoveryFacet__InsufficientGuardians();\n    error AccountRecoveryFacet__RecoveryAlreadyOngoing();\n    error AccountRecoveryFacet__NonexistentRecovery();\n    error AccountRecoveryFacet__NonExistentApproval();\n    error AccountRecoveryFacet__RecoveryPeriodNotOver();\n    error AccountRecoveryFacet__InvalidLockPeriod();\n    error AccountRecoveryFacet__InvalidRecoveryPeriod();\n    error AccountRecoveryFacet__InvalidApprovalValidationPeriod();\n    error AccountRecoveryFacet__InvalidGuardian();\n    error AccountRecoveryFacet__InvalidGuardianSignature();\n    error AccountRecoveryFacet__InvalidOwnerSignature();\n    error AccountRecoveryFacet__CallNotSuccesful();\n    error AccountRecoveryFacet__DuplicateApproval();\n\n    function approveAccountRecovery(bytes calldata recoveryPublicKey) external;\n\n    function revokeAccountRecoveryApproval(\n        bytes calldata recoveryPublicKey\n    ) external;\n\n    function executeRecovery(\n        bytes calldata recoveryPublicKey,\n        address[] calldata guardians,\n        bytes[] calldata signatures\n    ) external;\n\n    function finalizeRecovery() external;\n\n    function approveCancelRecovery(bytes calldata recoveryPublicKey) external;\n\n    function cancelRecovery(\n        bytes calldata recoveryPublicKey,\n        address[] calldata guardians,\n        bytes[] calldata signatures\n    ) external;\n\n    function hardstopRecovery(bytes calldata signature) external;\n\n    function getApprovalRecoveryKeyHash(\n        bytes memory recoveryPublicKey,\n        string memory saltString\n    ) external view returns (bytes32);\n\n    function getRecoveryApprovalCountWithTimeValidity(\n        bytes32 recoveryPublicKeyHash\n    ) external view returns (uint256);\n\n    function isRecoveryApproved(\n        bytes32 recoveryPublicKeyHash,\n        address approver\n    ) external view returns (bool);\n\n    function getRecoveryNonce() external view returns (uint128);\n\n    function getPendingRecovery() external view returns (RecoveryConfig memory);\n}\n"
    },
    "contracts/facets/interfaces/IMultiSigFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Multi-sig facet Interface\n * @dev Interface of Multi-signature Facet with custom threshold.\n        Wallet that adds this facet becomes a multi-sig wallet\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IMultiSigFacet {\n    event ThresholdChanged(uint256 threshold);\n    event OwnerAdded(address indexed newOwner);\n    event OwnerRemoved(address indexed prevOwner);\n    event HashApproved(bytes32 hashToApprove, address indexed owner);\n\n    error MultiSigFacet__InvalidThreshold();\n    error MultisigFacet__InvalidOwnerCount();\n    error MultiSigFacet__InvalidRoute();\n    error MultiSigFacet__InsufficientSignerLength();\n    error MultiSigFacet__InvalidInitData();\n    error MultiSigFacet__InvalidOwnerAddress();\n    error MultiSigFacet__InvalidOwnerPair();\n    error MultiSigFacet__InvalidSignatureLength();\n    error MultiSigFacet__InvalidSignatureType();\n    error MultiSigFacet__DuplicateOwner();\n    error MultiSigFacet__OnlyOwner();\n\n    function checkSignatures(\n        bytes32 _dataHash,\n        bytes calldata _signatures,\n        uint256 _threshold\n    ) external view returns (uint256);\n\n    function splitSignatures(\n        bytes calldata _signatures,\n        uint256 _nextOffset\n    )\n        external\n        pure\n        returns (\n            address owner,\n            bytes memory signature,\n            uint256 signatureType,\n            uint256 nextOffset\n        );\n\n    function approveHash(bytes32 hashToApprove) external;\n\n    function addOwner(address newOwner, uint256 threshold) external;\n\n    function removeOwner(\n        address prevOwner,\n        address removedOwner,\n        uint256 threshold\n    ) external;\n\n    function swapOwner(\n        address prevOwner,\n        address oldOwner,\n        address newOwner\n    ) external;\n\n    function changeThreshold(uint256 _threshold) external;\n\n    function isOwner(address owner) external view returns (bool);\n\n    function getThreshold() external view returns (uint256);\n\n    function getOwners() external view returns (address[] memory);\n}\n"
    },
    "contracts/facets/interfaces/ISignatureMigrationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureMigrationConfig} from \"../../libraries/LibFacetStorage.sol\";\n\n/**\n * @title Signature Migration Facet Interface\n * @dev Interface of Signature Migration contract for migrating user signature scheme to a new scheme user sets\n *      Which could include\n *          - ECDSA on Secp256K1 Curve\n *          - ECDSA on Secp256R1 Curve\n *          - BLS, Schnorr, etc\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface ISignatureMigrationFacet {\n    event SignatureSchemeMigration(\n        address indexed prevVerificationFacet,\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors\n    );\n    event SignatureMigrationApproved(\n        bytes newPublicKey,\n        address indexed newVerificationFacet,\n        bytes4[] verificationFuncSelectors,\n        address indexed guardian,\n        uint128 approvalValidUntil\n    );\n    event SignatureMigrationApprovalRevoked(\n        bytes newPublicKey,\n        address indexed newVerificationFacet,\n        bytes4[] verificationFuncSelectors,\n        address indexed guardian\n    );\n    event SignatureMigrationExecuted(\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors,\n        uint128 migrateAfter\n    );\n    event SignatureMigrationCanceled(\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors\n    );\n    event SignatureMigrationCancellationApproved(\n        address indexed newVerificationFacet,\n        bytes newOwner,\n        bytes4[] verificationFuncSelectors\n    );\n\n    error SignatureMigrationFacet__SignerUninitializationFailure();\n    error SignatureMigrationFacet__InvalidRouteWithGuardian();\n    error SignatureMigrationFacet__InvalidKeyType();\n    error SignatureMigrationFacet__InsufficientApprovers();\n    error SignatureMigrationFacet__InvalidApproverSignature();\n    error SignatureMigrationFacet__InvalidGuardian();\n    error SignatureMigrationFacet__NonExistentApprover();\n    error SignatureMigrationFacet__InvalidMigrationPeriod();\n    error SignatureMigrationFacet__NonexistentMigration();\n    error SignatureMigrationFacet__MigrationPeriodNotOver();\n    error SignatureMigrationFacet__InvalidArrayLength();\n    error SignatureMigrationFacet__InvalidApprovalValidationPeriod();\n    error SignatureMigrationFacet__CannotRevokeUnapproved();\n    error SignatureMigrationFacet__LackOfOwnerApproval();\n    error SignatureMigrationFacet__OwnerAlreadyApproved();\n    error SignatureMigrationFacet__NonExistentVerificationFacet();\n    error SignatureMigrationFacet__DuplicateApproval();\n\n    function migrateSignatureScheme(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function migrateSignatureSchemeWithGuardian(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors,\n        address[] calldata approvers,\n        bytes[] calldata signatures\n    ) external;\n\n    function approveSignatureSchemeMigration(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function revokeSignatureMigrationApproval(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function finalizeSignatureMigration() external;\n\n    function approveCancelSignatureMigration(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors\n    ) external;\n\n    function cancelSignatureMigration(\n        address newVerificationFacet,\n        bytes calldata newPublicKey,\n        bytes4[] calldata newVerificationFuncSelectors,\n        address[] calldata guardians,\n        bytes[] calldata signatures\n    ) external;\n\n    function getApprovalMigrationKeyHash(\n        bytes memory recoveryPublicKey,\n        address newVerificationFacet,\n        bytes4[] memory newVerificationFuncSelectors,\n        string memory saltString\n    ) external view returns (bytes32);\n\n    function getMigrationOwnerApprovalWithTimeValidity(\n        bytes32 publicKeyHash\n    ) external view returns (bool);\n\n    function getMigrationApprovalCountWithTimeValidity(\n        bytes32 publicKeyHash\n    ) external view returns (uint256);\n\n    function isMigrationApproved(\n        bytes32 migrationPublicKeyHash,\n        address approver\n    ) external view returns (bool);\n\n    function getMigrationNonce() external view returns (uint128);\n\n    function isMigrationPending() external view returns (bool);\n\n    function getPendingMigration()\n        external\n        view\n        returns (SignatureMigrationConfig memory);\n}\n"
    },
    "contracts/facets/interfaces/IVerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {UserOperation} from \"../../aa-4337/interfaces/UserOperation.sol\";\n\n/**\n * @title Verification Facet Interface\n * @dev Implements logic for user ops signature verification\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ninterface IVerificationFacet {\n    event SignerInitialized(bytes);\n    event SignerUninitialized();\n\n    error VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n    error VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n    error VerificationFacet__InitializationFailure();\n    error VerificationFacet__InvalidFacetMapping();\n\n    function initializeSigner(bytes memory) external returns (uint256);\n\n    function uninitializeSigner() external returns (uint256);\n\n    function validateOwnerSignatureSelector() external view returns (bytes4);\n\n    function owner() external view returns (bytes memory);\n\n    function isValidKeyType(bytes calldata) external view returns (bool);\n\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/facets/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {BarzStorage} from \"../libraries/LibAppStorage.sol\";\nimport {IFacetRegistry} from \"../infrastructure/interfaces/IFacetRegistry.sol\";\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\n\n/**\n * @title Modifiers\n * @dev Responsible for providing modifiers/util functions to Facet contracts\n * @author David Yongjun Kim (@Powerstream3604)\n */\nabstract contract Modifiers is BarzStorage {\n    uint8 constant INNER_STRUCT = 0;\n\n    error CallerNotGuardian();\n    error CallerNotGuardianOrOwner();\n    error DuplicateApprover();\n    error ZeroApproverLength();\n    error UnregisteredFacetAndSelectors();\n\n    /**\n     * @notice Modifier to only allow guardian to make a call, reverts if any other entity is the caller\n     */\n    modifier onlyGuardian() {\n        if (!LibGuardian.isGuardian(msg.sender)) revert CallerNotGuardian();\n        _;\n    }\n\n    /**\n     * @notice Modifier to only allow guardian or owner to make a call, reverts if any other entity is the caller\n     */\n    modifier onlyGuardianOrOwner() {\n        if (!LibGuardian.isGuardian(msg.sender) && address(this) != msg.sender)\n            revert CallerNotGuardianOrOwner();\n        _;\n    }\n\n    /**\n     * @notice Checks if the approver address is the array is unique with no duplicate\n     * @dev This method loops through the array and checks if a duplicate address exists, it reverts if duplicate address exists\n     * @param approvers Array of address\n     */\n    function _checkApprover(\n        address[] memory approvers\n    ) internal pure returns (bool) {\n        uint256 approverLength = approvers.length;\n        if (0 == approverLength) revert ZeroApproverLength();\n        for (uint256 i; i < approverLength - 1; ) {\n            for (uint256 j = i + 1; j < approverLength; ) {\n                if (approvers[i] == approvers[j]) {\n                    revert DuplicateApprover(); // Found a duplicate\n                }\n                unchecked {\n                    ++j;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return false; // No duplicates found\n    }\n\n    /**\n     * @notice Checks if the facet getting added or replaced is registered to facet registry\n     * @dev This method loops through the cut and checks if the facet getting added/replaced is registered to facet registry\n     * @param _diamondCut Array of FacetCut, data for diamondCut defined in EIP-2535\n     */\n    function _checkFacetCutValidity(\n        IDiamondCut.FacetCut[] memory _diamondCut\n    ) internal view {\n        uint256 diamondCutLength = _diamondCut.length;\n        for (uint256 i; i < diamondCutLength; ) {\n            if (\n                _diamondCut[i].action == IDiamondCut.FacetCutAction.Add ||\n                _diamondCut[i].action == IDiamondCut.FacetCutAction.Replace\n            ) {\n                if (\n                    !s.facetRegistry.areFacetFunctionSelectorsRegistered(\n                        _diamondCut[i].facetAddress,\n                        _diamondCut[i].functionSelectors\n                    )\n                ) revert UnregisteredFacetAndSelectors();\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n}\n"
    },
    "contracts/facets/SignatureMigrationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {LibAppStorage} from \"../libraries/LibAppStorage.sol\";\nimport {LibFacetStorage, SignatureMigrationStorage, SignatureMigrationConfig, SignatureMigrationApprovalConfig, ApprovalConfig} from \"../libraries/LibFacetStorage.sol\";\nimport {LibDiamond} from \"../libraries/LibDiamond.sol\";\nimport {LibGuardian} from \"../libraries/LibGuardian.sol\";\nimport {LibLoupe} from \"../libraries/LibLoupe.sol\";\nimport {Modifiers} from \"./Modifiers.sol\";\nimport {ISecurityManager} from \"../infrastructure/interfaces/ISecurityManager.sol\";\nimport {IDiamondCut} from \"./base/interfaces/IDiamondCut.sol\";\nimport {IVerificationFacet} from \"./interfaces/IVerificationFacet.sol\";\nimport {ISignatureMigrationFacet} from \"./interfaces/ISignatureMigrationFacet.sol\";\n\n/**\n * @title Signature Migration Facet\n * @dev Responsible for migrating user signature scheme to a new scheme user sets\n *      Which could include\n *          - ECDSA on Secp256K1 Curve\n *          - ECDSA on Secp256R1 Curve\n *          - BLS, Schnorr, etc\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract SignatureMigrationFacet is ISignatureMigrationFacet, Modifiers {\n    bytes constant UNINIT_CALL =\n        abi.encodeWithSignature(\"uninitializeSigner()\");\n    ISecurityManager public immutable securityManager;\n\n    /**\n     * @notice This modifier verifies if the public key format matches with the new verification facet\n     * @param _publicKey Bytes of public key to be validated for the new verification facet\n     * @param _newVerificationFacet Address of new verification facet\n     */\n    modifier validateKeyType(\n        bytes memory _publicKey,\n        address _newVerificationFacet\n    ) {\n        if (\n            !IVerificationFacet(_newVerificationFacet).isValidKeyType(\n                _publicKey\n            )\n        ) revert SignatureMigrationFacet__InvalidKeyType();\n        _;\n    }\n\n    /**\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\n     *         Immutable variables do not impact the storage of diamond\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\n     */\n    constructor(address _securityManager) {\n        securityManager = ISecurityManager(_securityManager);\n    }\n\n    // IMPORTANT NOTE: In the client side when they call this function, the func selectors should be sorted in ascending order\n    // to prevent different hash with same items in the array\n    /**\n     * @notice Moves the state of migration to a pending state. When pending state is over after pending period time,\n     *         Migration can be finalized. This function can only be called by self and when the account is unlocked.\n     * @dev This method checks if the caller is self and if guardians exists. It migrates signature request to a pending state\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function migrateSignatureScheme(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        public\n        override\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        // Only self contract can call this function\n        LibDiamond.enforceIsSelf();\n        // Should revert if guardian exist\n        if (0 != LibGuardian.guardianCount())\n            revert SignatureMigrationFacet__InvalidRouteWithGuardian();\n        {\n            _checkMigrationCutValidity(\n                _newVerificationFacet,\n                _newVerificationFuncSelectors\n            );\n        }\n        _migrateSignatureScheme(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    // NOTE: Migration requires a pending period & confirmation from owner to prevent a\n    // single call changing the ownership of the wallet\n    /**\n     * @notice Migrate signature scheme when guardians exists. Verifies the signature of guardians and moves migration to pending state.\n     *       Which can then be finalized when pending period is over. Owner's approval is mandatory for migration to happen\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     * @param _approvers List of approvers. This could include owner\n     */\n    function migrateSignatureSchemeWithGuardian(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors,\n        address[] calldata _approvers,\n        bytes[] calldata _signatures\n    )\n        public\n        override\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        // Should revert if does not guardian exist\n        if (0 == LibGuardian.guardianCount())\n            revert SignatureMigrationFacet__InvalidRouteWithGuardian();\n        if (_approvers.length != _signatures.length)\n            revert SignatureMigrationFacet__InvalidArrayLength();\n\n        {\n            _checkMigrationCutValidity(\n                _newVerificationFacet,\n                _newVerificationFuncSelectors\n            );\n        }\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"MigrateSignature\"\n        );\n\n        _checkApprover(_approvers);\n        _checkDuplicateOnChainApprover(migrationPublicKeyHash, _approvers);\n\n        bool onChainOwnerApproval = getMigrationOwnerApprovalWithTimeValidity(\n            migrationPublicKeyHash\n        );\n        uint256 threshold = onChainOwnerApproval ? 0 : 1;\n\n        if (\n            _approvers.length +\n                getMigrationApprovalCountWithTimeValidity(\n                    migrationPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians() + threshold\n        ) revert SignatureMigrationFacet__InsufficientApprovers();\n        {\n            // To prevent Stack too deep\n            bool ownerApproved;\n            for (uint256 i; i < _approvers.length; ) {\n                if (\n                    !LibGuardian.isGuardian(_approvers[i]) &&\n                    address(this) != _approvers[i]\n                ) revert SignatureMigrationFacet__InvalidGuardian();\n                if (_approvers[i] == address(this)) {\n                    if (onChainOwnerApproval)\n                        revert SignatureMigrationFacet__OwnerAlreadyApproved();\n                    ownerApproved = true;\n                }\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        _approvers[i],\n                        migrationPublicKeyHash,\n                        _signatures[i]\n                    )\n                ) revert SignatureMigrationFacet__InvalidApproverSignature();\n                unchecked {\n                    ++i;\n                }\n            }\n\n            if (!ownerApproved && !onChainOwnerApproval)\n                revert SignatureMigrationFacet__LackOfOwnerApproval();\n        }\n        _migrateSignatureScheme(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    /**\n     * @notice Internal function that moves signature mgiration to a pending state.\n     * @dev This method increments migration nonce and sets the migration in the migration config. Emits events for migration execution\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function _migrateSignatureScheme(\n        address _newVerificationFacet,\n        bytes memory _newPublicKey,\n        bytes4[] memory _newVerificationFuncSelectors\n    ) internal {\n        SignatureMigrationStorage storage ms = LibFacetStorage\n            .migrationStorage();\n\n        ++ms.nonce;\n        uint64 migrateAfter = uint64(block.timestamp + getMigrationPeriod());\n\n        ms.migrationConfigs[INNER_STRUCT] = SignatureMigrationConfig(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            migrateAfter\n        );\n\n        emit SignatureMigrationExecuted(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors,\n            migrateAfter\n        );\n    }\n\n    /**\n     * @notice Approves signature scheme migration on-chain. This can be called by owner or guardian only when the account is unlocked.\n     *         When the threshold of the migration approval passed and owner approval is granted, it automatically moves migration to a pending state\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function approveSignatureSchemeMigration(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        public\n        override\n        onlyGuardianOrOwner\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        {\n            _checkMigrationCutValidity(\n                _newVerificationFacet,\n                _newVerificationFuncSelectors\n            );\n        }\n\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"MigrateSignature\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + getApprovalValidationPeriod()\n        );\n        ms.isMigrationApproved[migrationPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit SignatureMigrationApproved(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            msg.sender,\n            approvalValidUntil\n        );\n        if (\n            getMigrationApprovalCountWithTimeValidity(migrationPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians() &&\n            getMigrationOwnerApprovalWithTimeValidity(migrationPublicKeyHash)\n        )\n            _migrateSignatureScheme(\n                _newVerificationFacet,\n                _newPublicKey,\n                _newVerificationFuncSelectors\n            );\n    }\n\n    /**\n     * @notice Revokes the approval of signature migration done on-chain. Emits revoke event when revoked.\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function revokeSignatureMigrationApproval(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        external\n        override\n        onlyGuardianOrOwner\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"MigrateSignature\"\n        );\n        if (!isMigrationApproved(migrationPublicKeyHash, msg.sender))\n            revert SignatureMigrationFacet__CannotRevokeUnapproved();\n\n        ms.isMigrationApproved[migrationPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(false, 0);\n        emit SignatureMigrationApprovalRevoked(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            msg.sender\n        );\n    }\n\n    /**\n     * @notice Finalizes the pending signature scheme migration. This function can only be called by owner.\n     *         It removes the facets of the previous verification facet and adds the new verification facet.\n     *         After finalizing migration, it emits migration event which shows the change of the verification facet\n     */\n    function finalizeSignatureMigration() external override {\n        // NOTE: Only owner can call this function\n        LibDiamond.enforceIsSelf();\n\n        SignatureMigrationStorage storage ms = LibFacetStorage\n            .migrationStorage();\n\n        if (!isMigrationPending())\n            revert SignatureMigrationFacet__NonexistentMigration();\n\n        if (\n            uint64(block.timestamp) <=\n            ms.migrationConfigs[INNER_STRUCT].migrateAfter\n        ) revert SignatureMigrationFacet__MigrationPeriodNotOver();\n        address newVerificationFacet = ms\n            .migrationConfigs[INNER_STRUCT]\n            .migrationVerificationFacet;\n        bytes4[] memory newVerificationFuncSelectors = ms\n            .migrationConfigs[INNER_STRUCT]\n            .migrationSelectors;\n        bytes memory newPublicKey = ms\n            .migrationConfigs[INNER_STRUCT]\n            .migrationPublicKey;\n\n        address prevVerificationFacet = LibLoupe.facetAddress(\n            s.validateOwnerSignatureSelector\n        );\n        if (prevVerificationFacet == address(0))\n            revert SignatureMigrationFacet__NonExistentVerificationFacet();\n\n        IDiamondCut.FacetCut[] memory UninitCut;\n        IDiamondCut.FacetCut[] memory InitCut;\n        {\n            bytes4[] memory prevVerificationFuncSelectors = LibLoupe\n                .facetFunctionSelectors(prevVerificationFacet);\n\n            UninitCut = new IDiamondCut.FacetCut[](1);\n            InitCut = new IDiamondCut.FacetCut[](1);\n            UninitCut[0] = IDiamondCut.FacetCut({\n                facetAddress: address(0),\n                action: IDiamondCut.FacetCutAction.Remove,\n                functionSelectors: prevVerificationFuncSelectors\n            });\n            InitCut[0] = IDiamondCut.FacetCut({\n                facetAddress: newVerificationFacet,\n                action: IDiamondCut.FacetCutAction.Add,\n                functionSelectors: newVerificationFuncSelectors\n            });\n            {\n                IDiamondCut.FacetCut[]\n                    memory facetCuts = new IDiamondCut.FacetCut[](2);\n                facetCuts[0] = UninitCut[0];\n                facetCuts[1] = InitCut[0];\n                _checkFacetCutValidity(facetCuts);\n            }\n            LibAppStorage.initiateSignerMigration();\n            address verificationFacet = address(\n                bytes20(\n                    LibDiamond.diamondStorage().facets[\n                        s.validateOwnerSignatureSelector\n                    ]\n                )\n            );\n\n            (bool success, bytes memory result) = verificationFacet\n                .delegatecall(UNINIT_CALL);\n            require(success, \"MigrationFacet: uninitialize not successful\");\n            uint256 validationData = uint256(bytes32(result));\n            if (validationData == 0)\n                revert SignatureMigrationFacet__SignerUninitializationFailure();\n\n            LibDiamond.diamondCut(UninitCut, address(0), \"\");\n        }\n        {\n            bytes memory initCall = abi.encodeWithSignature(\n                \"initializeSigner(bytes)\",\n                newPublicKey\n            );\n\n            // Every Verification Facet should comply with initializeSigner(bytes)\n            // to be compatible with the Barz contract(for initialization)\n            LibDiamond.diamondCut(InitCut, newVerificationFacet, initCall);\n            LibAppStorage.finalizeSignerMigration();\n            emit SignatureSchemeMigration(\n                prevVerificationFacet,\n                newVerificationFacet,\n                newPublicKey,\n                newVerificationFuncSelectors\n            );\n        }\n    }\n\n    /**\n     * @notice Approve cancellation of signature migration. If cancellation approval passes guardian threshold with owner approval\n     *         it automatically cancels the migration.\n     * @dev This method checks if the caller is one of guardian or owner and sets true for the cancellation hash in the approval config.\n     *      It internally calls _cancelSignatureMigration for canceling the migration\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function approveCancelSignatureMigration(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors\n    )\n        external\n        override\n        onlyGuardianOrOwner\n        onlyWhenUnlocked\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n    {\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"CancelSignatureMigration\"\n        );\n        uint64 approvalValidUntil = uint64(\n            block.timestamp + getApprovalValidationPeriod()\n        );\n        ms.isMigrationApproved[migrationPublicKeyHash][\n            msg.sender\n        ] = ApprovalConfig(true, approvalValidUntil);\n        emit SignatureMigrationCancellationApproved(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n        if (\n            getMigrationApprovalCountWithTimeValidity(migrationPublicKeyHash) >=\n            LibGuardian.majorityOfGuardians() &&\n            getMigrationOwnerApprovalWithTimeValidity(migrationPublicKeyHash)\n        )\n            _cancelSignatureMigration(\n                _newVerificationFacet,\n                _newPublicKey,\n                _newVerificationFuncSelectors\n            );\n    }\n\n    /**\n     * @notice Verifies the signature of guardians/owner and cancels the signature migration.\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     * @param _approvers List of approvers. This could include owner\n     */\n    function cancelSignatureMigration(\n        address _newVerificationFacet,\n        bytes calldata _newPublicKey,\n        bytes4[] calldata _newVerificationFuncSelectors,\n        address[] calldata _approvers,\n        bytes[] calldata _signatures\n    )\n        external\n        override\n        validateKeyType(_newPublicKey, _newVerificationFacet)\n        onlyWhenUnlocked\n    {\n        if (_approvers.length != _signatures.length)\n            revert SignatureMigrationFacet__InvalidArrayLength();\n\n        bytes32 migrationPublicKeyHash = getApprovalMigrationKeyHash(\n            _newPublicKey,\n            _newVerificationFacet,\n            _newVerificationFuncSelectors,\n            \"CancelSignatureMigration\"\n        );\n\n        _checkApprover(_approvers);\n        _checkDuplicateOnChainApprover(migrationPublicKeyHash, _approvers);\n\n        bool onChainOwnerApproval = getMigrationOwnerApprovalWithTimeValidity(\n            migrationPublicKeyHash\n        );\n        uint256 threshold = onChainOwnerApproval ? 0 : 1;\n        if (\n            _approvers.length +\n                getMigrationApprovalCountWithTimeValidity(\n                    migrationPublicKeyHash\n                ) <\n            LibGuardian.majorityOfGuardians() + threshold\n        ) revert SignatureMigrationFacet__InsufficientApprovers();\n        {\n            // To prevent stack too deep\n            bool ownerApproved;\n            for (uint256 i; i < _approvers.length; ) {\n                if (\n                    !LibGuardian.isGuardian(_approvers[i]) &&\n                    address(this) != _approvers[i]\n                ) revert SignatureMigrationFacet__NonExistentApprover();\n                if (_approvers[i] == address(this)) {\n                    if (onChainOwnerApproval)\n                        revert SignatureMigrationFacet__OwnerAlreadyApproved();\n                    ownerApproved = true;\n                }\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        _approvers[i],\n                        migrationPublicKeyHash,\n                        _signatures[i]\n                    )\n                ) revert SignatureMigrationFacet__InvalidApproverSignature();\n                unchecked {\n                    ++i;\n                }\n            }\n            if (!ownerApproved && !onChainOwnerApproval)\n                revert SignatureMigrationFacet__LackOfOwnerApproval();\n        }\n        _cancelSignatureMigration(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    /**\n     * @notice Internal function that cancels signature migration.\n     * @dev This method increments migration nonce and deletes the migration from the migration config. Emits events for migration cancellation\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function _cancelSignatureMigration(\n        address _newVerificationFacet,\n        bytes memory _newPublicKey,\n        bytes4[] memory _newVerificationFuncSelectors\n    ) internal {\n        if (!isMigrationPending())\n            revert SignatureMigrationFacet__NonexistentMigration();\n        SignatureMigrationStorage storage ms = LibFacetStorage\n            .migrationStorage();\n        ++ms.nonce;\n        delete ms.migrationConfigs[INNER_STRUCT];\n        emit SignatureMigrationCanceled(\n            _newVerificationFacet,\n            _newPublicKey,\n            _newVerificationFuncSelectors\n        );\n    }\n\n    /**\n     * @notice Checks if the facets to be added from new verification facet is registered to facet registry\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     */\n    function _checkMigrationCutValidity(\n        address _newVerificationFacet,\n        bytes4[] memory _newVerificationFuncSelectors\n    ) internal view {\n        IDiamondCut.FacetCut[] memory facetCuts = new IDiamondCut.FacetCut[](1);\n        facetCuts[0] = IDiamondCut.FacetCut({\n            facetAddress: _newVerificationFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: _newVerificationFuncSelectors\n        });\n        _checkFacetCutValidity(facetCuts);\n    }\n\n    /**\n     * @notice Returns if the migration is pending of not\n     * @dev This method fetches the migration storage and checks if the migrate after is above 0 value\n     * @return isPending Bool value that shows if the migration is pending\n     */\n    function isMigrationPending()\n        public\n        view\n        override\n        returns (bool isPending)\n    {\n        SignatureMigrationStorage storage rs = LibFacetStorage\n            .migrationStorage();\n        isPending = rs.migrationConfigs[INNER_STRUCT].migrateAfter > 0;\n    }\n\n    /**\n     * @notice Returns the migration hash. This function ensures that this hash is safe from replay attack by including\n     *         public key, verification facet, function selectors, salt, address, chainId, and nonce.\n     * @param _newPublicKey Public key that will be used for the new verification facet that replaces the previous one\n     * @param _newVerificationFacet Verification facet that will replace the existing verification facet\n     * @param _newVerificationFuncSelectors Function Selectors of new verification facet that will be added to the diamond\n     * @param _saltString Salt value for generating the migration hash\n     * @return migrationKeyHash Bytes32 string of the migration key hash\n     */\n    function getApprovalMigrationKeyHash(\n        bytes memory _newPublicKey,\n        address _newVerificationFacet,\n        bytes4[] memory _newVerificationFuncSelectors,\n        string memory _saltString\n    ) public view override returns (bytes32 migrationKeyHash) {\n        migrationKeyHash = keccak256(\n            abi.encodePacked(\n                \"\\x19Ethereum Signed Message:\\n32\",\n                keccak256(\n                    abi.encode(\n                        _newPublicKey,\n                        _newVerificationFacet,\n                        keccak256(abi.encode(_newVerificationFuncSelectors)),\n                        _saltString,\n                        address(this),\n                        block.chainid,\n                        LibFacetStorage.migrationStorage().nonce\n                    )\n                )\n            )\n        );\n    }\n\n    /**\n     * @notice Checks if the owner approved the hash for migration\n     * @param _migrationPublicKeyHash Hash of the public key and configuration for migration\n     * @return isApprovedByOwner Bool value of showing if the owner approved it or not\n     */\n    function getMigrationOwnerApprovalWithTimeValidity(\n        bytes32 _migrationPublicKeyHash\n    ) public view override returns (bool isApprovedByOwner) {\n        isApprovedByOwner = isMigrationApproved(\n            _migrationPublicKeyHash,\n            address(this)\n        );\n    }\n\n    /**\n     * @notice Checks how many of the guardians approved the migration hash\n     * @param _migrationPublicKeyHash Hash of the public key and configuration for migration\n     * @return approvalCount Number of approvals\n     */\n    function getMigrationApprovalCountWithTimeValidity(\n        bytes32 _migrationPublicKeyHash\n    ) public view override returns (uint256 approvalCount) {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardiansLength = guardians.length;\n        for (uint256 i; i < guardiansLength; ) {\n            if (isMigrationApproved(_migrationPublicKeyHash, guardians[i])) {\n                unchecked {\n                    ++approvalCount;\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return approvalCount;\n    }\n\n    /**\n     * @notice Checks if the migration is approved by the given approver\n     * @param _migrationPublicKeyHash Hash of the public key and configuration for migration\n     * @param _approver Address of approver\n     * @return isApproved Bool value if migration hash is approved\n     */\n    function isMigrationApproved(\n        bytes32 _migrationPublicKeyHash,\n        address _approver\n    ) public view override returns (bool isApproved) {\n        SignatureMigrationApprovalConfig storage ms = LibFacetStorage\n            .migrationStorage()\n            .migrationApprovalConfigs[INNER_STRUCT];\n        isApproved = (ms\n        .isMigrationApproved[_migrationPublicKeyHash][_approver].isApproved &&\n            block.timestamp <\n            ms\n            .isMigrationApproved[_migrationPublicKeyHash][_approver]\n                .validUntil);\n    }\n\n    /**\n     * @notice Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval\n     *         Approvers who approved on-chain should not be included in the off-chain approval\n     * @param _migrationPublicKeyHash Hash of migration information\n     * @param _approvers List of approver addresses\n     */\n    function _checkDuplicateOnChainApprover(\n        bytes32 _migrationPublicKeyHash,\n        address[] memory _approvers\n    ) public view {\n        address[] memory guardians = LibGuardian.getGuardians();\n        uint256 guardianLength = guardians.length;\n        uint256 approversLength = _approvers.length;\n        for (uint256 i; i < guardianLength; ) {\n            if (isMigrationApproved(_migrationPublicKeyHash, guardians[i])) {\n                for (uint256 j; j < approversLength; ) {\n                    if (_approvers[j] == guardians[i])\n                        revert SignatureMigrationFacet__DuplicateApproval();\n                    unchecked {\n                        ++j;\n                    }\n                }\n            }\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /**\n     * @notice Returns the migration period of this wallet\n     * @dev This method fetches the migration period from the security manager\n     * @return migrationPeriod Migration period of Barz contract fetched from security manager\n     */\n    function getMigrationPeriod()\n        internal\n        view\n        returns (uint128 migrationPeriod)\n    {\n        migrationPeriod = securityManager.migrationPeriodOf(address(this));\n        if (migrationPeriod == 0)\n            revert SignatureMigrationFacet__InvalidMigrationPeriod();\n    }\n\n    /**\n     * @notice Returns the validation period of this wallet\n     * @dev This method fetches the validation period from the security manager\n     * @return approvalValidationPeriod Validation period of Barz contract fetched from security manager\n     */\n    function getApprovalValidationPeriod()\n        internal\n        view\n        returns (uint256 approvalValidationPeriod)\n    {\n        approvalValidationPeriod = securityManager.approvalValidationPeriodOf(\n            address(this)\n        );\n        if (approvalValidationPeriod == 0)\n            revert SignatureMigrationFacet__InvalidApprovalValidationPeriod();\n    }\n\n    /**\n     * @notice Returns the migration nonce of this wallet\n     * @dev This method fetches the nonce from migration storage\n     * @return migrationNonce Nonce of migration to protect from reply attacks\n     */\n    function getMigrationNonce()\n        public\n        view\n        override\n        returns (uint128 migrationNonce)\n    {\n        migrationNonce = LibFacetStorage.migrationStorage().nonce;\n    }\n\n    /**\n     * @notice Returns the migration configuration of this wallet\n     * @dev This method fetches the migration config from the migration storage\n     * @return pendingMigrationConfig Migration config currently pending for signature migration\n     */\n    function getPendingMigration()\n        external\n        view\n        override\n        returns (SignatureMigrationConfig memory pendingMigrationConfig)\n    {\n        pendingMigrationConfig = LibFacetStorage\n            .migrationStorage()\n            .migrationConfigs[INNER_STRUCT];\n    }\n}\n"
    },
    "contracts/facets/verification/MultiSigFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {SignatureChecker} from \"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\";\nimport {UserOperation} from \"../../aa-4337/interfaces/UserOperation.sol\";\nimport {LibDiamond} from \"../../libraries/LibDiamond.sol\";\nimport {LibLoupe} from \"../../libraries/LibLoupe.sol\";\nimport {LibAppStorage} from \"../../libraries/LibAppStorage.sol\";\nimport {LibMultiSigStorage, MultiSigStorage} from \"../../libraries/LibMultiSigStorage.sol\";\nimport {IERC1271} from \"../../interfaces/ERC/IERC1271.sol\";\nimport {IVerificationFacet} from \"../interfaces/IVerificationFacet.sol\";\nimport {IMultiSigFacet} from \"../interfaces/IMultiSigFacet.sol\";\n\n/**\n * @title Multi-sig facet\n * @dev Multi-signature Facet with custom threshold.\n *      Wallet that adds this facet becomes a multi-sig wallet.\n *      Reference signature_format.md documentation for Multi-sig facet details\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract MultiSigFacet is IMultiSigFacet, IVerificationFacet, IERC1271 {\n    using ECDSA for bytes32;\n\n    address public immutable self;\n\n    address internal constant SENTINEL_OWNERS = address(0x1);\n    uint256 internal constant ADDRESS = 20;\n    uint256 internal constant SIG_TYPE = 1;\n    uint256 internal constant SIG_LEN = 4;\n    uint256 internal constant THRESHOLD = 4;\n    uint256 internal constant INVALID_SIG = 1;\n    uint256 internal constant VALID_SIG = 0;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n        self = address(this);\n    }\n\n    /**\n     * @notice Initializes the signer in Multisig Facet Storage. This can only be called when the account is uninitialized or during signature migration.\n     * @dev This method checks if the signer has already been initialized. If already initialized, it reverts.\n     *      It checks if the public key is in the right format and initializes signer storage in k1 storage.\n     * @param _owners Bytes of owner public key\n     * @return initSuccess Uint value representing the success of init operation\n     */\n    function initializeSigner(\n        bytes calldata _owners\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceSignerInitialize();\n\n        if (!isValidKeyType(_owners)) revert MultiSigFacet__InvalidInitData();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        uint256 threshold = uint256(uint32(bytes4(_owners)));\n        uint256 ownerCount = (_owners.length - THRESHOLD) / ADDRESS;\n\n        if (threshold == 0) revert MultiSigFacet__InvalidThreshold();\n        if (ownerCount == 0) revert MultisigFacet__InvalidOwnerCount();\n\n        address currentOwner = SENTINEL_OWNERS;\n        uint256 ptr = THRESHOLD;\n        address owner_;\n        for (uint256 i; i < ownerCount; ) {\n            owner_ = address(bytes20(_owners[ptr:ptr + ADDRESS]));\n            ptr += ADDRESS;\n            if (\n                owner_ == address(0) ||\n                owner_ == SENTINEL_OWNERS ||\n                owner_ == address(this) ||\n                owner_ == currentOwner\n            ) revert MultiSigFacet__InvalidOwnerAddress();\n            if (ms.owners[owner_] != address(0))\n                revert MultiSigFacet__DuplicateOwner();\n\n            ms.owners[currentOwner] = owner_;\n            currentOwner = owner_;\n\n            unchecked {\n                ++i;\n            }\n        }\n        ms.owners[currentOwner] = SENTINEL_OWNERS;\n        ms.ownerCount = ownerCount;\n        ms.threshold = threshold;\n\n        bytes4 validateSelector = validateOwnerSignatureSelector();\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() != bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n        if (LibLoupe.facetAddress(validateSelector) != self)\n            revert VerificationFacet__InvalidFacetMapping();\n\n        // initialize verification function selector\n        LibAppStorage.setValidateOwnerSignatureSelector(validateSelector);\n\n        initSuccess = 1;\n\n        emit SignerInitialized(_owners);\n    }\n\n    /**\n     * @notice Uninitialize signer in K1 Facet Storage. This can only be called when the account is undergoing signature migration\n     *         and has already been initialized.\n     * @dev This method checks if the signature migration is undergoing, signer is initialized and sets the signer to zero value.\n     * @return uninitSuccess Uint value representing the success of uninit operation\n     */\n    function uninitializeSigner()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n        ++ms.counter;\n        address[] memory ownerlist = getOwners();\n        uint256 ownerlistLength = ownerlist.length;\n        for (uint256 i; i < ownerlistLength; ) {\n            ms.owners[ownerlist[i]] = address(0);\n            unchecked {\n                ++i;\n            }\n        }\n        ms.owners[SENTINEL_OWNERS] = address(0);\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    /**\n     * @notice Validates if the user operation is signed by the owner.\n     * @dev This method validates if the user operation is signed by the owner. It internally calls checkSignatures with\n     *      user operation hash and signature together with the threshold.\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @return validationData Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view override returns (uint256 validationData) {\n        // Data 1 is invalid, Data 0 is valid\n        validationData = checkSignatures(\n            userOpHash,\n            userOp.signature,\n            LibMultiSigStorage.multisigStorage().threshold\n        );\n    }\n\n    /**\n     * @notice Returns the selector of function to validate the signature of UserOperation\n     * @return ownerSignatureValidatorSelector Bytes4 selector of function signature to validate account owner's UserOperation signature\n     */\n    function validateOwnerSignatureSelector()\n        public\n        pure\n        override\n        returns (bytes4 ownerSignatureValidatorSelector)\n    {\n        return this.validateOwnerSignature.selector;\n        // The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    /**\n     * @notice Returns the owner of the account\n     * @return signer Bytes of owner address\n     */\n    function owner() public view override returns (bytes memory) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        uint totalLength = ms.ownerCount * ADDRESS;\n        bytes memory result = new bytes(totalLength);\n\n        // populate return array\n        uint256 index;\n        address currentOwner = ms.owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            assembly {\n                mstore(\n                    add(result, add(32, mul(index, ADDRESS))),\n                    shl(96, currentOwner)\n                )\n            }\n            currentOwner = ms.owners[currentOwner];\n            index++;\n        }\n\n        return result;\n    }\n\n    /**\n     * @notice Validates if the format of public key is valid for this verification facet\n     * @dev For this Secp256k1Verification Facet, the public key should comply with the format in the signature_format.md doc\n     * @param _publicKey Bytes of public key for format check\n     * @return isValid Boolean variable representing if the format of public key is valid\n     */\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure override returns (bool isValid) {\n        uint256 publicKeyLength = _publicKey.length;\n        if (\n            publicKeyLength < ADDRESS + THRESHOLD ||\n            (publicKeyLength - THRESHOLD) % ADDRESS != 0\n        ) return false;\n\n        uint256 threshold = uint256(uint32(bytes4(_publicKey)));\n        uint256 ownerCount = (publicKeyLength - THRESHOLD) / ADDRESS;\n\n        isValid = !(ownerCount < threshold || threshold == 0);\n    }\n\n    /**\n     * @notice Validates if the signature is valid. Function to be compatible with EIP-1271\n     * @dev This method verifies the signature if the owner indeed signed the hash. Returns magic value if true\n     * @param _hash Hash value the owner signed\n     * @param _signature Signature that signed the above hash\n     * @return magicValue Bytes4 value representing the success/failure of validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes calldata _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = (checkSignatures(\n            _hash,\n            _signature,\n            LibMultiSigStorage.multisigStorage().threshold\n        ) == VALID_SIG)\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n\n    /**\n     * @notice Validates the format of the signature and verifies if the signature is signed by the expected key.\n     *         Reference signature_format.md doc for details about signature format and signature types\n     * @param _dataHash Bytes value of data hash signed by the owners\n     * @param _signatures Bytes value of signature which should comply with signature format\n     * @param _threshold Uint256 value of current Multi-sig Barz's threshold\n     */\n    function checkSignatures(\n        bytes32 _dataHash,\n        bytes calldata _signatures,\n        uint256 _threshold\n    ) public view returns (uint256) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        address lastOwner = address(0);\n        address currentOwner;\n        bytes memory signature;\n        uint256 signatureType;\n        uint256 nextOffset;\n        uint256 i;\n        for (i; i < _threshold; ) {\n            (\n                currentOwner,\n                signature,\n                signatureType,\n                nextOffset\n            ) = splitSignatures(_signatures, nextOffset);\n            if (nextOffset == 0 && i + 1 < _threshold) return INVALID_SIG;\n            if (signatureType == 1) {\n                // If signatureType is 1 then it is default dataHash signed.\n                // This also includes the contract signature\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        currentOwner,\n                        _dataHash,\n                        signature\n                    )\n                ) return INVALID_SIG;\n            } else if (signatureType == 2) {\n                // If signatureType is 2 then it is an approved hash\n                if (ms.approvedHashes[ms.counter][currentOwner][_dataHash] == 0)\n                    return INVALID_SIG;\n            } else if (signatureType == 3) {\n                // If signatureType is 3 then it is a signed message hash\n                // This also includes the contract signature\n                bytes32 msgHash = _dataHash.toEthSignedMessageHash();\n                if (\n                    !SignatureChecker.isValidSignatureNow(\n                        currentOwner,\n                        msgHash,\n                        signature\n                    )\n                ) return INVALID_SIG;\n            } else revert MultiSigFacet__InvalidRoute();\n            if (\n                currentOwner <= lastOwner ||\n                ms.owners[currentOwner] == address(0) ||\n                currentOwner == SENTINEL_OWNERS\n            ) return INVALID_SIG;\n            lastOwner = currentOwner;\n\n            unchecked {\n                ++i;\n            }\n        }\n        return VALID_SIG;\n    }\n\n    /**\n     * @notice Split signatures into each individual signatures. Should comply with signature format to be split\n     * @param _signatures Bytes value of signature\n     * @param _nextOffset Uint256 value of next offset to start splitting the signature\n     */\n    function splitSignatures(\n        bytes calldata _signatures,\n        uint256 _nextOffset\n    )\n        public\n        pure\n        returns (\n            address owner_,\n            bytes memory signature,\n            uint256 signatureType,\n            uint256 nextOffset\n        )\n    {\n        uint256 signaturesLength = _signatures.length;\n\n        if (signaturesLength <= _nextOffset + ADDRESS + SIG_LEN)\n            revert MultiSigFacet__InsufficientSignerLength();\n\n        owner_ = address(\n            bytes20(_signatures[_nextOffset:_nextOffset + ADDRESS])\n        );\n\n        signatureType = uint256(\n            uint8(\n                bytes1(\n                    _signatures[_nextOffset + ADDRESS:_nextOffset +\n                        ADDRESS +\n                        SIG_TYPE]\n                )\n            )\n        );\n\n        if (signatureType > 3 || signatureType == 0)\n            revert MultiSigFacet__InvalidSignatureType();\n        uint256 offSet = _nextOffset + ADDRESS + SIG_TYPE;\n        uint256 siglen = uint256(\n            uint32(bytes4(_signatures[offSet:offSet + SIG_LEN]))\n        );\n        if (offSet + siglen > signaturesLength)\n            revert MultiSigFacet__InvalidSignatureLength();\n\n        offSet += SIG_LEN;\n        if (offSet + siglen == signaturesLength) nextOffset = 0;\n        else nextOffset = offSet + siglen;\n\n        signature = _signatures[offSet:offSet + siglen];\n    }\n\n    /**\n     * @notice Approves the hash of userOperation on-chain. This can only be called by owners.\n     * @param _hashToApprove Bytes value of UserOperation hash to approve\n     */\n    function approveHash(bytes32 _hashToApprove) external {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (ms.owners[msg.sender] == address(0))\n            revert MultiSigFacet__OnlyOwner();\n\n        ms.approvedHashes[ms.counter][msg.sender][_hashToApprove] = 1;\n        emit HashApproved(_hashToApprove, msg.sender);\n    }\n\n    /**\n     * @notice Add owner to Barz. Update thresold if threshold is given different from current threshold\n     * @dev This can only be done via a Self call.\n     * @param _newOwner Address of new owner to be added\n     * @param _threshold Uint256 value of threshold\n     */\n    function addOwner(address _newOwner, uint256 _threshold) external {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (\n            _newOwner == address(0) ||\n            _newOwner == SENTINEL_OWNERS ||\n            _newOwner == address(this)\n        ) revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_newOwner] != address(0))\n            revert MultiSigFacet__DuplicateOwner();\n\n        ms.owners[_newOwner] = ms.owners[SENTINEL_OWNERS];\n        ms.owners[SENTINEL_OWNERS] = _newOwner;\n        ++ms.ownerCount;\n        emit OwnerAdded(_newOwner);\n\n        if (ms.threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /**\n     * @notice Remove owner from Barz. Update thresold if threshold is given different from current threshold\n     * @dev This can only be done via a Self call.\n     * @param _prevOwner Address of owner located right behind the removed owner address in the linked list\n     * @param _removedOwner Address of owner to be removed\n     * @param _threshold Uint256 value of threshold\n     */\n    function removeOwner(\n        address _prevOwner,\n        address _removedOwner,\n        uint256 _threshold\n    ) external {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (ms.ownerCount - 1 < _threshold)\n            revert MultiSigFacet__InvalidThreshold();\n        if (_removedOwner == address(0) || _removedOwner == SENTINEL_OWNERS)\n            revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_prevOwner] != _removedOwner)\n            revert MultiSigFacet__InvalidOwnerPair();\n\n        ms.owners[_prevOwner] = ms.owners[_removedOwner];\n        ms.owners[_removedOwner] = address(0);\n        --ms.ownerCount;\n        emit OwnerRemoved(_removedOwner);\n\n        if (ms.threshold != _threshold) changeThreshold(_threshold);\n    }\n\n    /**\n     * @notice Swap owner in Barz.\n     * @dev This can only be done via a Self call.\n     * @param _prevOwner Address of owner located right behind the removed owner address in the linked list\n     * @param _oldOwner Address of owner to be removed\n     * @param _newOwner Address of owner to be added\n     */\n    function swapOwner(\n        address _prevOwner,\n        address _oldOwner,\n        address _newOwner\n    ) public {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (\n            _newOwner == address(0) ||\n            _newOwner == SENTINEL_OWNERS ||\n            _newOwner == address(this)\n        ) revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_newOwner] != address(0))\n            revert MultiSigFacet__DuplicateOwner();\n        if (_oldOwner == address(0) || _oldOwner == SENTINEL_OWNERS)\n            revert MultiSigFacet__InvalidOwnerAddress();\n        if (ms.owners[_prevOwner] != _oldOwner)\n            revert MultiSigFacet__InvalidOwnerPair();\n\n        ms.owners[_newOwner] = ms.owners[_oldOwner];\n        ms.owners[_prevOwner] = _newOwner;\n        ms.owners[_oldOwner] = address(0);\n        emit OwnerRemoved(_oldOwner);\n        emit OwnerAdded(_newOwner);\n    }\n\n    /**\n     * @notice Changes the threshold of the Barz to `_threshold`.\n     * @dev This can only be done via a Self call.\n     * @param _threshold New threshold\n     */\n    function changeThreshold(uint256 _threshold) public {\n        LibDiamond.enforceIsSelf();\n\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        if (_threshold > ms.ownerCount || _threshold == 0)\n            revert MultiSigFacet__InvalidThreshold();\n\n        ms.threshold = _threshold;\n        emit ThresholdChanged(_threshold);\n    }\n\n    /**\n     * @notice Checks if the given address is owner\n     * @param _owner Address to be checked if it's owner\n     * @return isOwner_ Bool value showing if it's owner address\n     */\n    function isOwner(address _owner) public view returns (bool isOwner_) {\n        isOwner_ = (_owner != SENTINEL_OWNERS &&\n            LibMultiSigStorage.multisigStorage().owners[_owner] != address(0));\n    }\n\n    /**\n     * @notice Returns the threshold of Barz\n     * @return threshold Threshold of the Barz account\n     */\n    function getThreshold() public view returns (uint256 threshold) {\n        threshold = LibMultiSigStorage.multisigStorage().threshold;\n    }\n\n    /**\n     * @notice Returns the list of owner addresses\n     * @return owners List of owners\n     */\n    function getOwners() public view returns (address[] memory owners) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n        owners = new address[](ms.ownerCount);\n\n        uint256 index;\n        address currentOwner = ms.owners[SENTINEL_OWNERS];\n        while (currentOwner != SENTINEL_OWNERS) {\n            owners[index] = currentOwner;\n            currentOwner = ms.owners[currentOwner];\n            index++;\n        }\n    }\n\n    /**\n     * @notice Returns the previous owner in the linked list\n     * @param _owner Address of owner\n     * @return prevOwner Address of previous owner\n     */\n    function getPrevOwner(\n        address _owner\n    ) public view returns (address prevOwner) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n\n        address currentOwner = ms.owners[SENTINEL_OWNERS];\n        if (currentOwner == _owner) return SENTINEL_OWNERS;\n        while (currentOwner != SENTINEL_OWNERS) {\n            if (ms.owners[currentOwner] == _owner) return currentOwner;\n\n            currentOwner = ms.owners[currentOwner];\n        }\n        return address(0);\n    }\n\n    /**\n     * @notice Returns of the owner is approved by given owner address\n     * @param _owner Address of owner\n     * @param _hash Hash of UserOperation\n     * @return isApproved Bool value showing if the hash is approved by owner\n     */\n    function isApprovedHash(\n        address _owner,\n        bytes32 _hash\n    ) public view returns (bool isApproved) {\n        MultiSigStorage storage ms = LibMultiSigStorage.multisigStorage();\n        isApproved = (ms.approvedHashes[ms.counter][_owner][_hash] == 1);\n    }\n}\n"
    },
    "contracts/facets/verification/secp256k1/Secp256k1VerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {UserOperation} from \"../../../aa-4337/interfaces/UserOperation.sol\";\nimport {LibAppStorage} from \"../../../libraries/LibAppStorage.sol\";\nimport {LibFacetStorage, Secp256k1VerificationStorage} from \"../../../libraries/LibFacetStorage.sol\";\nimport {LibLoupe} from \"../../../libraries/LibLoupe.sol\";\nimport {IERC1271} from \"../../../interfaces/ERC/IERC1271.sol\";\nimport {IVerificationFacet} from \"../../interfaces/IVerificationFacet.sol\";\n\n/**\n * @title Secp256k1 verification facet\n * @dev Default Ethereum's elliptic curve\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ncontract Secp256k1VerificationFacet is IVerificationFacet, IERC1271 {\n    using ECDSA for bytes32;\n    error Secp256k1VerificationFacet__InvalidSignerLength();\n    address public immutable self;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n        self = address(this);\n    }\n\n    /**\n     * @notice Initializes the signer in K1 Facet Storage. This can only be called when the account is uninitialized or during signature migration.\n     * @dev This method checks if the signer has already been initialized. If already initialized, it reverts.\n     *      It checks if the public key is in the light format and initializes signer storage in k1 storage.\n     * @param _publicKey Bytes of owner public key\n     * @return initSuccess Uint value representing the success of init operation\n     */\n    function initializeSigner(\n        bytes calldata _publicKey\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceSignerInitialize();\n        if (!isValidKeyType(_publicKey))\n            revert Secp256k1VerificationFacet__InvalidSignerLength();\n\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        k1Storage.signer = address(uint160(uint256(keccak256(_publicKey[1:]))));\n\n        bytes4 validateSelector = validateOwnerSignatureSelector();\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() != bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n        if (LibLoupe.facetAddress(validateSelector) != self)\n            revert VerificationFacet__InvalidFacetMapping();\n\n        // initialize verification function selector\n        LibAppStorage.setValidateOwnerSignatureSelector(validateSelector);\n\n        initSuccess = 1;\n\n        emit SignerInitialized(_publicKey);\n    }\n\n    /**\n     * @notice Uninitialize signer in K1 Facet Storage. This can only be called when the account is undergoing signature migration\n     *         and has already been initialized.\n     * @dev This method checks if the signature migration is undergoing, signer is initialized and sets the signer to zero value.\n     * @return uninitSuccess Uint value representing the success of uninit operation\n     */\n    function uninitializeSigner()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        k1Storage.signer = address(0);\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    /**\n     * @notice Validates if the user operation is signed by the owner.\n     * @dev This method validates if the user operation is signed by the owner. It internally calls validateSignature with\n     *      signer public key.\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @return validationData Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view override returns (uint256 validationData) {\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        validationData = validateSignature(\n            userOp,\n            userOpHash,\n            k1Storage.signer\n        );\n    }\n\n    /**\n     * @notice Validates if the signature of UserOperation is signed by the given signer\n     * @dev This method uses OpenZeppelin library to validate if the signature of UserOperation is signed by the signer address\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @param signer Address of signer who signed the contract, to be validated\n     * @return isValid Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        address signer\n    ) public pure returns (uint256 isValid) {\n        bytes32 hash = userOpHash.toEthSignedMessageHash();\n        isValid = (signer != hash.recover(userOp.signature)) ? 1 : 0;\n    }\n\n    /**\n     * @notice Returns the selector of function to validate the signature of UserOperation\n     * @return ownerSignatureValidatorSelector Bytes4 selector of function signature to validate account owner's UserOperation signature\n     */\n    function validateOwnerSignatureSelector()\n        public\n        pure\n        override\n        returns (bytes4 ownerSignatureValidatorSelector)\n    {\n        ownerSignatureValidatorSelector = this.validateOwnerSignature.selector;\n        // NOTE: The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    /**\n     * @notice Returns the owner of the account\n     * @return signer Bytes of owner address\n     */\n    function owner() public view override returns (bytes memory signer) {\n        Secp256k1VerificationStorage storage k1Storage = LibFacetStorage\n            .k1Storage();\n        signer = abi.encodePacked(k1Storage.signer);\n    }\n\n    /**\n     * @notice Validates if the format of public key is valid for this verification facet\n     * @dev For this Secp256k1Verification Facet, the public key length should be 65 in an uncompressed public key format\n     * @param _publicKey Bytes of public key for format check\n     * @return isValid Boolean variable representing if the format of public key is valid\n     */\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure override returns (bool isValid) {\n        isValid = (_publicKey.length == 65 && _publicKey[0] == 0x04);\n    }\n\n    /**\n     * @notice Validates if the signature is valid. Function to be compatible with EIP-1271\n     * @dev This method verifies the signature if the owner indeed signed the hash. Returns magic value if true\n     * @param _hash Hash value the owner signed\n     * @param _signature Signature that signed the above hash\n     * @return magicValue Bytes4 value representing the success/failure of validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = (_hash.recover(_signature) ==\n            LibFacetStorage.k1Storage().signer)\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n}\n"
    },
    "contracts/facets/verification/secp256r1/Secp256r1VerificationFacet.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {UserOperation} from \"../../../aa-4337/interfaces/UserOperation.sol\";\nimport {LibAppStorage} from \"../../../libraries/LibAppStorage.sol\";\nimport {LibLoupe} from \"../../../libraries/LibLoupe.sol\";\nimport {LibFacetStorage, Secp256r1VerificationStorage} from \"../../../libraries/LibFacetStorage.sol\";\nimport {Base64} from \"./utils/Base64.sol\";\nimport {LibSecp256r1} from \"./utils/LibSecp256r1.sol\";\nimport {IERC1271} from \"../../../interfaces/ERC/IERC1271.sol\";\nimport {IVerificationFacet} from \"../../interfaces/IVerificationFacet.sol\";\n\n/**\n * @title Secp256r1 verification facet\n * @dev Primarily used to verify user ops signed with passkeys\n * @author Ruslan Serebriakov (@rsrbk)\n * @author David Yongjun Kim (@Powerstream3604)\n */\ncontract Secp256r1VerificationFacet is IVerificationFacet, IERC1271 {\n    error Secp256r1VerificationFacet__InvalidSignerLength();\n    address public immutable self;\n\n    /**\n     * @notice This constructor ensures that this contract can only be used as singleton for Proxy contracts\n     */\n    constructor() {\n        LibAppStorage.enforceSignerInitialize();\n        self = address(this);\n    }\n\n    /**\n     * @notice Initializes the signer in R1 Facet Storage. This can only be called when the account is uninitialized or during signature migration.\n     * @dev This method checks if the signer has already been initialized. If already initialized, it reverts.\n     *      It checks if the public key is in the light format and initializes signer storage in k1 storage.\n     * @param _publicKey Bytes of owner public key\n     * @return initSuccess Uint value representing the success of init operation\n     */\n    function initializeSigner(\n        bytes calldata _publicKey\n    ) public override returns (uint256 initSuccess) {\n        LibAppStorage.enforceSignerInitialize();\n\n        if (!isValidKeyType(_publicKey))\n            revert Secp256r1VerificationFacet__InvalidSignerLength();\n\n        bytes memory publicKeyCoordinates = _publicKey[1:];\n        uint256[2] memory q;\n        assembly {\n            // Copy the bytes from the input data into the uint256 array\n            mstore(q, mload(add(publicKeyCoordinates, 32)))\n            mstore(add(q, 32), mload(add(publicKeyCoordinates, 64)))\n        }\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        r1Storage.q = q;\n\n        bytes4 validateSelector = validateOwnerSignatureSelector();\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() != bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorAlreadySet();\n        if (LibLoupe.facetAddress(validateSelector) != self)\n            revert VerificationFacet__InvalidFacetMapping();\n\n        // initialize verification function selector\n        LibAppStorage.setValidateOwnerSignatureSelector(validateSelector);\n\n        initSuccess = 1;\n\n        emit SignerInitialized(_publicKey);\n    }\n\n    /**\n     * @notice Uninitialize signer in R1 Facet Storage. This can only be called when the account is undergoing signature migration\n     *         and has already been initialized.\n     * @dev This method checks if the signature migration is undergoing, signer is initialized and sets the signer to zero value.\n     * @return uninitSuccess Uint value representing the success of uninit operation\n     */\n    function uninitializeSigner()\n        external\n        override\n        returns (uint256 uninitSuccess)\n    {\n        LibAppStorage.enforceSignerMigration();\n        LibAppStorage.setSignerUninitialized();\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        r1Storage.q = [0, 0];\n\n        if (LibAppStorage.getValidateOwnerSignatureSelector() == bytes4(0))\n            revert VerificationFacet__ValidateOwnerSignatureSelectorNotSet();\n        LibAppStorage.setValidateOwnerSignatureSelector(bytes4(0));\n\n        uninitSuccess = 1;\n\n        emit SignerUninitialized();\n    }\n\n    /**\n     * @notice Validates if the user operation is signed by the owner.\n     * @dev This method validates if the user operation is signed by the owner. It internally calls validateSignature with\n     *      signer public key.\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @return validationData Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateOwnerSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash\n    ) public view override returns (uint256 validationData) {\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        validationData = validateSignature(userOp, userOpHash, r1Storage.q);\n    }\n\n    /**\n     * @notice Validates if the signature of UserOperation is signed by the given signer\n     * @dev This method uses OpenZeppelin library to validate if the signature of UserOperation is signed by the signer address\n     * @param userOp UserOperation including all information for execution\n     * @param userOpHash Hash of UserOperation given from EntryPoint. This hash is used for signature validation\n     * @param q Public Key of signer who signed the contract, to be validated\n     * @return isValid Uint value representing whether the validation is successful. 0 for success, 1 for failure\n     */\n    function validateSignature(\n        UserOperation calldata userOp,\n        bytes32 userOpHash,\n        uint256[2] memory q\n    ) public view returns (uint256 isValid) {\n        isValid = (_validateSignature(q, userOpHash, userOp.signature)) ? 0 : 1;\n    }\n\n    /**\n     * @notice Returns the selector of function to validate the signature of UserOperation\n     * @return ownerSignatureValidatorSelector Bytes4 selector of function signature to validate account owner's UserOperation signature\n     */\n    function validateOwnerSignatureSelector()\n        public\n        pure\n        override\n        returns (bytes4 ownerSignatureValidatorSelector)\n    {\n        return this.validateOwnerSignature.selector; // validateOwnerSignature(UserOperation calldata userOp,bytes32 userOpHash)\n        // The signature name could change according to the facet but the param format(UserOp, UserOpHash) should not change\n    }\n\n    /**\n     * @notice Returns the owner of the account\n     * @return signer Bytes of owner address\n     */\n    function owner() public view override returns (bytes memory signer) {\n        Secp256r1VerificationStorage storage r1Storage = LibFacetStorage\n            .r1Storage();\n        signer = abi.encodePacked(r1Storage.q);\n    }\n\n    /**\n     * @notice Validates if the format of public key is valid for this verification facet\n     * @dev For this Secp256k1Verification Facet, the public key should in an uncompressed public key format\n     * @param _publicKey Bytes of public key for format check\n     * @return isValid Boolean variable representing if the format of public key is valid\n     */\n    function isValidKeyType(\n        bytes memory _publicKey\n    ) public pure override returns (bool isValid) {\n        isValid = (_publicKey.length == 65 && _publicKey[0] == 0x04);\n    }\n\n    /**\n     * @notice Validates if the signature is valid. Function to be compatible with EIP-1271\n     * @dev This method verifies the signature if the owner indeed signed the hash. Returns magic value if true\n     * @param _hash Hash value the owner signed\n     * @param _signature Signature that signed the above hash\n     * @return magicValue Bytes4 value representing the success/failure of validation\n     */\n    function isValidSignature(\n        bytes32 _hash,\n        bytes memory _signature\n    ) public view override returns (bytes4 magicValue) {\n        magicValue = _validateSignature(\n            LibFacetStorage.r1Storage().q,\n            _hash,\n            _signature\n        )\n            ? this.isValidSignature.selector\n            : bytes4(0xffffffff);\n    }\n\n    function _validateSignature(\n        uint256[2] memory q,\n        bytes32 _hash,\n        bytes memory _signature\n    ) internal view returns (bool) {\n        (\n            uint256 rValue,\n            uint256 sValue,\n            bytes memory authenticatorData,\n            string memory clientDataJSONPre,\n            string memory clientDataJSONPost\n        ) = abi.decode(_signature, (uint256, uint256, bytes, string, string));\n        bytes32 clientHash;\n        {\n            string memory opHashBase64 = Base64.encode(bytes.concat(_hash));\n            string memory clientDataJSON = string.concat(\n                clientDataJSONPre,\n                opHashBase64,\n                clientDataJSONPost\n            );\n            clientHash = sha256(bytes(clientDataJSON));\n        }\n        bytes32 sigHash = sha256(bytes.concat(authenticatorData, clientHash));\n        return LibSecp256r1.Verify(q, rValue, sValue, uint256(sigHash));\n    }\n}\n"
    },
    "contracts/facets/verification/secp256r1/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *  modified for base64url https://datatracker.ietf.org/doc/html/rfc4648#section-5\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE =\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        uint256 newlength = (data.length * 8) / 6;\n        if (data.length % 6 > 0) {\n            newlength++;\n        }\n        string memory result = new string(newlength);\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(18, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(12, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(\n                    resultPtr,\n                    mload(add(tablePtr, and(shr(6, input), 0x3F)))\n                )\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/facets/verification/secp256r1/utils/LibSecp256r1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.21;\n\n// Heavily inspired from\n// https://github.com/maxrobot/elliptic-solidity/blob/master/contracts/Secp256r1.sol\n// https://github.com/tdrerup/elliptic-curve-solidity/blob/master/contracts/curves/EllipticCurve.sol\n// modified to use precompile 0x05 modexp\n// and modified jacobian double\n// optimisations to avoid to an from from affine and jacobian coordinates\n\n// Additional Elliptic curve Public key / Signature validation added by\n// David Yonjun Kim (@Powerstream3604)\n\nstruct JPoint {\n    uint256 x;\n    uint256 y;\n    uint256 z;\n}\n\nlibrary LibSecp256r1 {\n    uint256 constant gx =\n        0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;\n    uint256 constant gy =\n        0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;\n    uint256 public constant pp =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF;\n\n    uint256 public constant nn =\n        0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;\n    uint256 constant a =\n        0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;\n    uint256 constant b =\n        0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;\n    uint256 constant MOST_SIGNIFICANT =\n        0xc000000000000000000000000000000000000000000000000000000000000000;\n\n    /*\n     * Verify\n     * @description - verifies that a public key has signed a given message\n     * @param Q - public key coordinates X & Y\n     * @param R - signature half R\n     * @param S - signature half S\n     * @param input - hashed message\n     */\n    function Verify(\n        uint256[2] memory q,\n        uint r,\n        uint s,\n        uint e\n    ) internal view returns (bool) {\n        if (q[0] > pp - 1 || q[1] > pp - 1) {\n            return false;\n        }\n        if (r == 0 || s == 0 || r >= nn || s >= nn) {\n            return false;\n        }\n        if (\n            mulmod(q[1], q[1], pp) !=\n            addmod(\n                addmod(\n                    mulmod(q[0], mulmod(q[0], q[0], pp), pp),\n                    mulmod(a, q[0], pp),\n                    pp\n                ),\n                b,\n                pp\n            )\n        ) {\n            return false;\n        }\n\n        JPoint[16] memory points = _preComputeJacobianPoints(q);\n        return VerifyWithPrecompute(points, r, s, e);\n    }\n\n    function VerifyWithPrecompute(\n        JPoint[16] memory points,\n        uint r,\n        uint s,\n        uint e\n    ) internal view returns (bool) {\n        if (r == 0 || s == 0 || r >= nn || s >= nn) {\n            return false;\n        }\n\n        uint w = _primemod(s, nn);\n\n        uint u1 = mulmod(e, w, nn);\n        uint u2 = mulmod(r, w, nn);\n\n        uint x;\n        uint y;\n\n        (x, y) = ShamirMultJacobian(points, u1, u2);\n        return (x == r);\n    }\n\n    /*\n     * Strauss Shamir trick for EC multiplication\n     * https://stackoverflow.com/questions/50993471/ec-scalar-multiplication-with-strauss-shamir-method\n     * we optimise on this a bit to do with 2 bits at a time rather than a single bit\n     * the individual points for a single pass are precomputed\n     * overall this reduces the number of additions while keeping the same number of doublings\n     */\n    function ShamirMultJacobian(\n        JPoint[16] memory points,\n        uint u1,\n        uint u2\n    ) internal view returns (uint, uint) {\n        uint x = 0;\n        uint y = 0;\n        uint z = 0;\n        uint bits = 128;\n        uint index = 0;\n\n        while (bits > 0) {\n            if (z > 0) {\n                (x, y, z) = _modifiedJacobianDouble(x, y, z);\n                (x, y, z) = _modifiedJacobianDouble(x, y, z);\n            }\n            index =\n                ((u1 & MOST_SIGNIFICANT) >> 252) |\n                ((u2 & MOST_SIGNIFICANT) >> 254);\n            if (index > 0) {\n                (x, y, z) = _jAdd(\n                    x,\n                    y,\n                    z,\n                    points[index].x,\n                    points[index].y,\n                    points[index].z\n                );\n            }\n            u1 <<= 2;\n            u2 <<= 2;\n            bits--;\n        }\n        (x, y) = _affineFromJacobian(x, y, z);\n        return (x, y);\n    }\n\n    function _preComputeJacobianPoints(\n        uint256[2] memory q\n    ) internal pure returns (JPoint[16] memory points) {\n        points[0] = JPoint(0, 0, 0);\n        points[1] = JPoint(q[0], q[1], 1); // u2\n        points[2] = _jPointDouble(points[1]);\n        points[3] = _jPointAdd(points[1], points[2]);\n\n        points[4] = JPoint(gx, gy, 1); // u1Points[1]\n        points[5] = _jPointAdd(points[4], points[1]);\n        points[6] = _jPointAdd(points[4], points[2]);\n        points[7] = _jPointAdd(points[4], points[3]);\n\n        points[8] = _jPointDouble(points[4]); // u1Points[2]\n        points[9] = _jPointAdd(points[8], points[1]);\n        points[10] = _jPointAdd(points[8], points[2]);\n        points[11] = _jPointAdd(points[8], points[3]);\n\n        points[12] = _jPointAdd(points[4], points[8]); // u1Points[3]\n        points[13] = _jPointAdd(points[12], points[1]);\n        points[14] = _jPointAdd(points[12], points[2]);\n        points[15] = _jPointAdd(points[12], points[3]);\n    }\n\n    function _jPointAdd(\n        JPoint memory p1,\n        JPoint memory p2\n    ) internal pure returns (JPoint memory) {\n        uint x;\n        uint y;\n        uint z;\n        (x, y, z) = _jAdd(p1.x, p1.y, p1.z, p2.x, p2.y, p2.z);\n        return JPoint(x, y, z);\n    }\n\n    function _jPointDouble(\n        JPoint memory p\n    ) internal pure returns (JPoint memory) {\n        uint x;\n        uint y;\n        uint z;\n        (x, y, z) = _modifiedJacobianDouble(p.x, p.y, p.z);\n        return JPoint(x, y, z);\n    }\n\n    /* _affineFromJacobian\n     * @desription returns affine coordinates from a jacobian input follows\n     * golang elliptic/crypto library\n     */\n    function _affineFromJacobian(\n        uint x,\n        uint y,\n        uint z\n    ) internal view returns (uint ax, uint ay) {\n        if (z == 0) {\n            return (0, 0);\n        }\n\n        uint zinv = _primemod(z, pp);\n        uint zinvsq = mulmod(zinv, zinv, pp);\n\n        ax = mulmod(x, zinvsq, pp);\n        ay = mulmod(y, mulmod(zinvsq, zinv, pp), pp);\n    }\n\n    /*\n     * _jAdd\n     * @description performs Jacobian addition as defined below:\n     * http://www.hyperelliptic.org/EFD/g1p/data/shortw/jacobian/addition/add-2007-bl\n     */\n    function _jAdd(\n        uint p1,\n        uint p2,\n        uint p3,\n        uint q1,\n        uint q2,\n        uint q3\n    ) internal pure returns (uint r1, uint r2, uint r3) {\n        if (p3 == 0) {\n            r1 = q1;\n            r2 = q2;\n            r3 = q3;\n\n            return (r1, r2, r3);\n        } else if (q3 == 0) {\n            r1 = p1;\n            r2 = p2;\n            r3 = p3;\n\n            return (r1, r2, r3);\n        }\n\n        assembly {\n            let\n                pd\n            := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z1z1 := mulmod(p3, p3, pd) // Z1Z1 = Z1^2\n            let z2z2 := mulmod(q3, q3, pd) // Z2Z2 = Z2^2\n\n            let u1 := mulmod(p1, z2z2, pd) // U1 = X1*Z2Z2\n            let u2 := mulmod(q1, z1z1, pd) // U2 = X2*Z1Z1\n\n            let s1 := mulmod(p2, mulmod(z2z2, q3, pd), pd) // S1 = Y1*Z2*Z2Z2\n            let s2 := mulmod(q2, mulmod(z1z1, p3, pd), pd) // S2 = Y2*Z1*Z1Z1\n\n            let p3q3 := addmod(p3, q3, pd)\n\n            if lt(u2, u1) {\n                u2 := add(pd, u2) // u2 = u2+pd\n            }\n            let h := sub(u2, u1) // H = U2-U1\n\n            let i := mulmod(0x02, h, pd)\n            i := mulmod(i, i, pd) // I = (2*H)^2\n\n            let j := mulmod(h, i, pd) // J = H*I\n            if lt(s2, s1) {\n                s2 := add(pd, s2) // u2 = u2+pd\n            }\n            let rr := mulmod(0x02, sub(s2, s1), pd) // r = 2*(S2-S1)\n            r1 := mulmod(rr, rr, pd) // X3 = R^2\n\n            let v := mulmod(u1, i, pd) // V = U1*I\n            let j2v := addmod(j, mulmod(0x02, v, pd), pd)\n            if lt(r1, j2v) {\n                r1 := add(pd, r1) // X3 = X3+pd\n            }\n            r1 := sub(r1, j2v)\n\n            // Y3 = r*(V-X3)-2*S1*J\n            let s12j := mulmod(mulmod(0x02, s1, pd), j, pd)\n\n            if lt(v, r1) {\n                v := add(pd, v)\n            }\n            r2 := mulmod(rr, sub(v, r1), pd)\n\n            if lt(r2, s12j) {\n                r2 := add(pd, r2)\n            }\n            r2 := sub(r2, s12j)\n\n            // Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H\n            z1z1 := addmod(z1z1, z2z2, pd)\n            j2v := mulmod(p3q3, p3q3, pd)\n            if lt(j2v, z1z1) {\n                j2v := add(pd, j2v)\n            }\n            r3 := mulmod(sub(j2v, z1z1), h, pd)\n        }\n        return (r1, r2, r3);\n    }\n\n    // Point doubling on the modified jacobian coordinates\n    // http://point-at-infinity.org/ecc/Prime_Curve_Modified_Jacobian_Coordinates.html\n    function _modifiedJacobianDouble(\n        uint x,\n        uint y,\n        uint z\n    ) internal pure returns (uint x3, uint y3, uint z3) {\n        if (y == 0) return (0, 0, 0);\n        assembly {\n            let\n                pd\n            := 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\n            let z2 := mulmod(z, z, pd)\n            let az4 := mulmod(\n                0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC,\n                mulmod(z2, z2, pd),\n                pd\n            )\n            let y2 := mulmod(y, y, pd)\n            let s := mulmod(0x04, mulmod(x, y2, pd), pd)\n            let u := mulmod(0x08, mulmod(y2, y2, pd), pd)\n            let m := addmod(mulmod(0x03, mulmod(x, x, pd), pd), az4, pd)\n            let twos := mulmod(0x02, s, pd)\n            let m2 := mulmod(m, m, pd)\n            if lt(m2, twos) {\n                m2 := add(pd, m2)\n            }\n            x3 := sub(m2, twos)\n            if lt(s, x3) {\n                s := add(pd, s)\n            }\n            y3 := mulmod(m, sub(s, x3), pd)\n            if lt(y3, u) {\n                y3 := add(pd, y3)\n            }\n            y3 := sub(y3, u)\n            z3 := mulmod(0x02, mulmod(y, z, pd), pd)\n        }\n    }\n\n    // Fermats little theorem https://en.wikipedia.org/wiki/Fermat%27s_little_theorem\n    // a^(p-1) = 1 mod p\n    // a^(-1) ≅ a^(p-2) (mod p)\n    // we then use the precompile bigModExp to compute a^(-1)\n    function _primemod(uint value, uint p) internal view returns (uint ret) {\n        ret = modexp(value, p - 2, p);\n        return ret;\n    }\n\n    // Wrapper for built-in BigNumber_modexp (contract 0x5) as described here. https://github.com/ethereum/EIPs/pull/198\n    function modexp(\n        uint _base,\n        uint _exp,\n        uint _mod\n    ) internal view returns (uint ret) {\n        // bigModExp(_base, _exp, _mod);\n        assembly {\n            if gt(_base, _mod) {\n                _base := mod(_base, _mod)\n            }\n            // Free memory pointer is always stored at 0x40\n            let freemem := mload(0x40)\n\n            mstore(freemem, 0x20)\n            mstore(add(freemem, 0x20), 0x20)\n            mstore(add(freemem, 0x40), 0x20)\n\n            mstore(add(freemem, 0x60), _base)\n            mstore(add(freemem, 0x80), _exp)\n            mstore(add(freemem, 0xa0), _mod)\n\n            let success := staticcall(14000, 0x5, freemem, 0xc0, freemem, 0x20)\n            switch success\n            case 0 {\n                revert(0x0, 0x0)\n            }\n            default {\n                ret := mload(freemem)\n            }\n        }\n    }\n}\n"
    },
    "contracts/infrastructure/interfaces/IFacetRegistry.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Facet Registry Interface\n * @dev Interface for Facet Registry contract to keep track of facets & function selectors addable to user wallets\n * @author David Yongjun Kim (@Powerstream3604)\n */\ninterface IFacetRegistry {\n    struct FacetRegistryConfig {\n        bytes4[] selectors;\n        mapping(bytes4 => FacetInfo) info;\n    }\n    struct FacetInfo {\n        bool exists;\n        uint128 index;\n    }\n\n    event FacetFunctionSelectorsRegistered(\n        address facet,\n        bytes4[] facetSelectors\n    );\n    event FacetFunctionSelectorsRemoved(address facet, bytes4[] facetSelectors);\n\n    error FacetRegistry__FacetSelectorAlreadyRegistered();\n    error FacetRegistry__UnregisteredFacetSelector();\n\n    function registerFacetFunctionSelectors(\n        address facet,\n        bytes4[] calldata facetSelectors\n    ) external;\n\n    function removeFacetFunctionSelectors(\n        address facet,\n        bytes4[] calldata facetSelectors\n    ) external;\n\n    function areFacetFunctionSelectorsRegistered(\n        address facet,\n        bytes4[] calldata facetSelectors\n    ) external view returns (bool);\n\n    function isFacetFunctionSelectorRegistered(\n        address facet,\n        bytes4 facetSelector\n    ) external view returns (bool);\n\n    function getFacetFunctionSelectors(\n        address facet\n    ) external view returns (bytes4[] memory);\n}\n"
    },
    "contracts/infrastructure/interfaces/ISecurityManager.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Facet Registry Interface\n * @dev Infrastructure contract to manage security parameters of users\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\ninterface ISecurityManager {\n    error SecurityManager__OutOfBoundary();\n    error SecurityManager__CallerNotWallet();\n    error SecurityManager__AlreadyIntialized();\n\n    function initializeAdditionSecurityPeriod(\n        uint128 defaultAdditionSecurityPeriod,\n        uint128 minAdditionSecurityPeriod,\n        uint128 maxAdditionSecurityPeriod\n    ) external;\n\n    function initializeRemovalSecurityPeriod(\n        uint128 defaultRemovalSecurityPeriod,\n        uint128 minRemovalSecurityPeriod,\n        uint128 maxRemovalSecurityPeriod\n    ) external;\n\n    function initializeApprovalValidationPeriod(\n        uint128 defaultApprovalValidationPeriod,\n        uint128 minApprovalValidationPeriod,\n        uint128 maxApprovalValidationPeriod\n    ) external;\n\n    function initializeMigrationPeriod(\n        uint128 defaultMigrationPeriod,\n        uint128 minMigrationPeriod,\n        uint128 maxMigrationPeriod\n    ) external;\n\n    function initializeLockPeriod(\n        uint128 defaultLockPeriod,\n        uint128 minLockPeriod,\n        uint128 maxLockPeriod\n    ) external;\n\n    function initializeRecoveryPeriod(\n        uint128 defaultRecoveryPeriod,\n        uint128 minRecoveryPeriod,\n        uint128 maxRecoveryPeriod\n    ) external;\n\n    function initializeSecurityWindow(\n        uint128 defaultSecurityWindow,\n        uint128 minSecurityWindow,\n        uint128 maxSecurityWindow\n    ) external;\n\n    function setAdditionSecurityPeriod(\n        address wallet,\n        uint128 additionSecurityPeriod\n    ) external;\n\n    function setRemovalSecurityPeriod(\n        address wallet,\n        uint128 removalSecurityPeriod\n    ) external;\n\n    function setSecurityWindow(address wallet, uint128 securityWindow) external;\n\n    function setRecoveryPeriod(address wallet, uint128 recoveryPeriod) external;\n\n    function setLockPeriod(address wallet, uint128 lockPeriod) external;\n\n    function setApprovalValidationPeriod(\n        address wallet,\n        uint128 approvalValidationPeriod\n    ) external;\n\n    function setMigrationPeriod(\n        address wallet,\n        uint128 migrationPeriod\n    ) external;\n\n    function additionSecurityPeriodOf(\n        address wallet\n    ) external view returns (uint128);\n\n    function removalSecurityPeriodOf(\n        address wallet\n    ) external view returns (uint128);\n\n    function securityWindowOf(address wallet) external view returns (uint128);\n\n    function recoveryPeriodOf(address wallet) external view returns (uint128);\n\n    function lockPeriodOf(address wallet) external view returns (uint128);\n\n    function migrationPeriodOf(address wallet) external view returns (uint128);\n\n    function approvalValidationPeriodOf(\n        address wallet\n    ) external view returns (uint128);\n}\n"
    },
    "contracts/interfaces/ERC/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\ninterface IERC1271 {\n    function isValidSignature(\n        bytes32 hash,\n        bytes memory signature\n    ) external view returns (bytes4);\n}\n"
    },
    "contracts/interfaces/ERC/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ERC/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\ninterface IERC677Receiver {\n    function onTokenTransfer(\n        address sender,\n        uint value,\n        bytes calldata data\n    ) external pure returns (bool);\n}\n"
    },
    "contracts/libraries/LibAppStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {SafeCast} from \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport {IEntryPoint} from \"../aa-4337/interfaces/IEntryPoint.sol\";\nimport {IFacetRegistry} from \"../infrastructure/interfaces/IFacetRegistry.sol\";\n\n/*\n * @title App Storage\n * @dev App storage for Barz contract to prevent storage collision\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\n\nstruct Lock {\n    uint64 release;\n    bytes4 locker;\n}\n\nstruct InitializersStorage {\n    // NOTE: initialized is a variable to make sure the initialization is only done once.\n    uint8 signerInitialized;\n    uint8 accountInitialized;\n    uint8 restrictionsInitialized;\n}\n\nstruct AppStorage {\n    mapping(uint256 => InitializersStorage) initStorage;\n    uint8 signerMigration;\n    bytes4 validateOwnerSignatureSelector;\n    IEntryPoint entryPoint;\n    IFacetRegistry facetRegistry;\n    mapping(uint256 => Lock) locks;\n}\n\nlibrary LibAppStorage {\n    error LibAppStorage__AccountAlreadyUninitialized();\n    error LibAppStorage__AccountMustBeUninitialized();\n    error LibAppStorage__SignerAlreadyUninitialized();\n    error LibAppStorage__SignerMustBeUninitialized();\n\n    function appStorage() internal pure returns (AppStorage storage ds) {\n        assembly {\n            ds.slot := 0\n        }\n    }\n\n    function setSignerUninitialized() internal {\n        AppStorage storage s = appStorage();\n        if (1 != s.initStorage[0].signerInitialized) {\n            revert LibAppStorage__SignerAlreadyUninitialized();\n        }\n        s.initStorage[0].signerInitialized = 0;\n    }\n\n    function getValidateOwnerSignatureSelector()\n        internal\n        view\n        returns (bytes4 selector)\n    {\n        selector = appStorage().validateOwnerSignatureSelector;\n    }\n\n    function setValidateOwnerSignatureSelector(\n        bytes4 _validateOwnerSignatureSelector\n    ) internal {\n        appStorage()\n            .validateOwnerSignatureSelector = _validateOwnerSignatureSelector;\n    }\n\n    function enforceSignerInitialize() internal {\n        AppStorage storage s = appStorage();\n        if (0 != s.initStorage[0].signerInitialized) {\n            revert LibAppStorage__SignerMustBeUninitialized();\n        }\n        s.initStorage[0].signerInitialized = 1;\n    }\n\n    function enforceAccountInitialize() internal {\n        AppStorage storage s = appStorage();\n        if (0 != s.initStorage[0].accountInitialized) {\n            revert LibAppStorage__AccountMustBeUninitialized();\n        }\n        s.initStorage[0].accountInitialized = 1;\n    }\n\n    function initiateSignerMigration() internal {\n        appStorage().signerMigration = 1;\n    }\n\n    function enforceSignerMigration() internal view {\n        if (1 != appStorage().signerMigration) {\n            revert LibAppStorage__AccountMustBeUninitialized();\n        }\n    }\n\n    function finalizeSignerMigration() internal {\n        appStorage().signerMigration = 0;\n    }\n\n    function setLock(uint256 _releaseAfter, bytes4 _locker) internal {\n        appStorage().locks[0] = Lock(SafeCast.toUint64(_releaseAfter), _locker);\n    }\n\n    function enforceRestrictionsInitialize() internal {\n        AppStorage storage s = appStorage();\n        if (0 != s.initStorage[0].restrictionsInitialized)\n            revert LibAppStorage__SignerMustBeUninitialized();\n        s.initStorage[0].restrictionsInitialized = 1;\n    }\n\n    function setRestrictionsUninitialized() internal {\n        AppStorage storage s = appStorage();\n        if (1 != s.initStorage[0].restrictionsInitialized)\n            revert LibAppStorage__AccountAlreadyUninitialized();\n        s.initStorage[0].restrictionsInitialized = 0;\n    }\n}\n\ncontract BarzStorage {\n    AppStorage internal s;\n    modifier onlyWhenUnlocked() {\n        require(\n            uint64(block.timestamp) >= s.locks[0].release,\n            \"Account Locked\"\n        );\n        _;\n    }\n    modifier onlyWhenLocked() {\n        require(\n            uint64(block.timestamp) < s.locks[0].release,\n            \"Account Unlocked\"\n        );\n        _;\n    }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondCut} from \"../facets/base/interfaces/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\n\nerror InitializationFunctionReverted(\n    address _initializationContractAddress,\n    bytes _calldata\n);\n\nlibrary LibDiamond {\n    bytes32 constant DIAMOND_STORAGE_POSITION =\n        keccak256(\"trustwallet.barz.diamond.storage\");\n    bytes4 constant RESTRICTIONS_FACET_SELECTOR =\n        bytes4(keccak256(\"verifyRestrictions(address,address,uint256,bytes)\"));\n    struct DiamondStorage {\n        // maps function selectors to the facets that execute the functions.\n        // and maps the selectors to their position in the selectorSlots array.\n        // func selector => address facet, selector position\n        mapping(bytes4 => bytes32) facets;\n        // array of slots of function selectors.\n        // each slot holds 8 function selectors.\n        mapping(uint256 => bytes32) selectorSlots;\n        // The number of function selectors in selectorSlots\n        uint16 selectorCount;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // Default Fallback Handler of the barz.\n        IDiamondLoupe defaultFallbackHandler;\n    }\n\n    function diamondStorage()\n        internal\n        pure\n        returns (DiamondStorage storage ds)\n    {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function enforceIsSelf() internal view {\n        require(msg.sender == address(this), \"LibDiamond: Caller not self\");\n    }\n\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    bytes32 constant CLEAR_ADDRESS_MASK =\n        bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        DiamondStorage storage ds = diamondStorage();\n        uint256 originalSelectorCount = ds.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            ds.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        DiamondStorage storage ds = diamondStorage();\n        require(\n            _selectors.length > 0,\n            \"LibDiamondCut: No selectors in facet to cut\"\n        );\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"LibDiamondCut: Add facet has no code\"\n            );\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                ds.facets[selector] =\n                    bytes20(_newFacetAddress) |\n                    bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot &\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(\n                _newFacetAddress,\n                \"LibDiamondCut: Replace facet has no code\"\n            );\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = ds.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(\n                    oldFacetAddress != address(this),\n                    \"LibDiamondCut: Can't replace immutable function\"\n                );\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(\n                    oldFacetAddress != address(0),\n                    \"LibDiamondCut: Can't replace function that doesn't exist\"\n                );\n                // replace old facet address\n                ds.facets[selector] =\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\n                    bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(\n                _newFacetAddress == address(0),\n                \"LibDiamondCut: Remove facet address must be address(0)\"\n            );\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = ds.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in ds.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(\n                        _selectorSlot << (selectorInSlotIndex << 5)\n                    );\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        ds.facets[lastSelector] =\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\n                            bytes20(ds.facets[lastSelector]);\n                    }\n                    delete ds.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\n                        oldSelectorsSlotCount\n                    ];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot &\n                            ~(CLEAR_SELECTOR_MASK >>\n                                oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete ds.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(\n            _init,\n            \"LibDiamondCut: _init address has no code\"\n        );\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(\n        address _contract,\n        string memory _errorMessage\n    ) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    function restrictionsFacet() internal view returns (address facetAddress_) {\n        facetAddress_ = address(\n            bytes20(\n                LibDiamond.diamondStorage().facets[RESTRICTIONS_FACET_SELECTOR]\n            )\n        );\n    }\n}\n"
    },
    "contracts/libraries/LibFacetStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Facet Storage\n * @dev Storage contract to store each facets variables with diamond storage\n * @author David Yongjun Kim (@Powerstream3604)\n * @author Ruslan Serebriakov (@rsrbk)\n */\n\nstruct Secp256k1VerificationStorage {\n    address signer;\n}\n\nstruct Secp256r1VerificationStorage {\n    uint256[2] q;\n}\n\nstruct GuardianStorage {\n    mapping(bytes32 => uint256) pending;\n    mapping(uint8 => StorageConfig) configs;\n}\n\nstruct Info {\n    bool exists;\n    uint128 index;\n}\n\nstruct StorageConfig {\n    address[] addresses;\n    mapping(address => Info) info;\n}\n\nstruct RecoveryConfig {\n    bytes recoveryPublicKey;\n    uint64 executeAfter;\n}\n\nstruct ApprovalConfig {\n    bool isApproved;\n    uint64 validUntil;\n}\n\nstruct RecoveryApprovalConfig {\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isNewOwnerApproved;\n}\n\nstruct RecoveryStorage {\n    mapping(uint8 => RecoveryConfig) recoveryConfigs;\n    mapping(uint8 => RecoveryApprovalConfig) recoveryApprovalConfigs;\n    uint128 nonce;\n}\n\nstruct RestrictionsStorage {\n    address[] restrictions;\n    mapping(address => bool) exists;\n}\n\nstruct SignatureMigrationConfig {\n    bytes migrationPublicKey;\n    address migrationVerificationFacet;\n    bytes4[] migrationSelectors;\n    uint64 migrateAfter;\n}\n\nstruct SignatureMigrationApprovalConfig {\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isMigrationApproved;\n}\n\nstruct SignatureMigrationStorage {\n    mapping(uint8 => SignatureMigrationConfig) migrationConfigs;\n    mapping(uint8 => SignatureMigrationApprovalConfig) migrationApprovalConfigs;\n    uint128 nonce;\n}\n\nstruct DiamondCutApprovalConfig {\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isDiamondCutApproved;\n}\n\nstruct DiamondCutStorage {\n    mapping(uint8 => DiamondCutApprovalConfig) diamondCutApprovalConfigs;\n    uint128 nonce;\n}\n\nstruct LockStorage {\n    uint128 nonce;\n}\n\nlibrary LibFacetStorage {\n    bytes32 constant K1_STORAGE_POSITION =\n        keccak256(\n            \"v0.trustwallet.diamond.storage.Secp256k1VerificationStorage\"\n        );\n    bytes32 constant R1_STORAGE_POSITION =\n        keccak256(\n            \"v0.trustwallet.diamond.storage.Secp256r1VerificationStorage\"\n        );\n    bytes32 constant GUARDIAN_STORAGE_POSITION =\n        keccak256(\"v0.trustwallet.diamond.storage.GuardianStorage\");\n    bytes32 constant RECOVERY_STORAGE_POSITION =\n        keccak256(\"v0.trustwallet.diamond.storage.RecoveryStorage\");\n    bytes32 constant RESTRICTION_STORAGE_POSITION =\n        keccak256(\"v0.trustwallet.diamond.storage.RestrictionsStorage\");\n    bytes32 constant MIGRATION_STORAGE_POSITION =\n        keccak256(\"v0.trustwallet.diamond.storage.SignatureMigrationStorage\");\n    bytes32 constant DIAMONDCUT_STORAGE_POSITION =\n        keccak256(\"v0.trustwallet.diamond.storage.DiamondCutStorage\");\n    bytes32 constant LOCK_STORAGE_POSITION =\n        keccak256(\"v0.trustwallet.diamond.storage.LockStorage\");\n\n    function k1Storage()\n        internal\n        pure\n        returns (Secp256k1VerificationStorage storage ds)\n    {\n        bytes32 storagePosition = K1_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function r1Storage()\n        internal\n        pure\n        returns (Secp256r1VerificationStorage storage ds)\n    {\n        bytes32 storagePosition = R1_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function guardianStorage()\n        internal\n        pure\n        returns (GuardianStorage storage ds)\n    {\n        bytes32 storagePosition = GUARDIAN_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function recoveryStorage()\n        internal\n        pure\n        returns (RecoveryStorage storage ds)\n    {\n        bytes32 storagePosition = RECOVERY_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function restrictionsStorage()\n        internal\n        pure\n        returns (RestrictionsStorage storage ds)\n    {\n        bytes32 storagePosition = RESTRICTION_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function migrationStorage()\n        internal\n        pure\n        returns (SignatureMigrationStorage storage ds)\n    {\n        bytes32 storagePosition = MIGRATION_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function diamondCutStorage()\n        internal\n        pure\n        returns (DiamondCutStorage storage ds)\n    {\n        bytes32 storagePosition = DIAMONDCUT_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n\n    function lockStorage() internal pure returns (LockStorage storage ds) {\n        bytes32 storagePosition = LOCK_STORAGE_POSITION;\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n}\n"
    },
    "contracts/libraries/LibGuardian.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {LibFacetStorage, StorageConfig} from \"./LibFacetStorage.sol\";\n\n/**\n * @title LibGuardian\n * @dev Internal Library to provide utility feature for Guardians stored in Guardian Facet Storage\n * @author David Yongjun Kim (@Powerstream3604)\n */\nlibrary LibGuardian {\n    function majorityOfGuardians()\n        internal\n        view\n        returns (uint256 guardianNumber)\n    {\n        uint256 guardianLength = guardianCount();\n        guardianNumber = (guardianLength == 0) ? 0 : guardianLength / 2 + 1;\n    }\n\n    function isGuardian(address _guardian) internal view returns (bool) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[0];\n        return config.info[_guardian].exists;\n    }\n\n    function guardianCount() internal view returns (uint256) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[0];\n        return config.addresses.length;\n    }\n\n    function getGuardians() internal view returns (address[] memory) {\n        StorageConfig storage config = LibFacetStorage\n            .guardianStorage()\n            .configs[0];\n        address[] memory addresses = new address[](config.addresses.length);\n        uint256 addressesLen = config.addresses.length;\n        for (uint256 i; i < addressesLen; ) {\n            addresses[i] = config.addresses[i];\n            unchecked {\n                ++i;\n            }\n        }\n        return addresses;\n    }\n}\n"
    },
    "contracts/libraries/LibLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\nimport {LibDiamond} from \"./LibDiamond.sol\";\n\n/**\n * @title LibLoupe\n * @dev Internal Library to provide utility feature for reading the state of diamond facets\n */\nlibrary LibLoupe {\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets()\n        internal\n        view\n        returns (IDiamondLoupe.Facet[] memory facets_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facets_ = new IDiamondLoupe.Facet[](ds.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[\n                            numFacetSelectors[facetIndex]\n                        ] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](\n                    ds.selectorCount\n                );\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(\n        address _facet\n    ) internal view returns (bytes4[] memory _facetFunctionSelectors) {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](ds.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(ds.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        internal\n        view\n        returns (address[] memory facetAddresses_)\n    {\n        LibDiamond.DiamondStorage storage ds = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](ds.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < ds.selectorCount; slotIndex++) {\n            bytes32 slot = ds.selectorSlots[slotIndex];\n            for (\n                uint256 selectorSlotIndex;\n                selectorSlotIndex < 8;\n                selectorSlotIndex++\n            ) {\n                selectorIndex++;\n                if (selectorIndex > ds.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(ds.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(\n        bytes4 _functionSelector\n    ) internal view returns (address facetAddress_) {\n        facetAddress_ = address(\n            bytes20(LibDiamond.diamondStorage().facets[_functionSelector])\n        );\n    }\n}\n"
    },
    "contracts/libraries/LibMultiSigStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\n/**\n * @title Multi-sig Storage\n * @dev Storage contract for storing Multi-sig Facet variables in diamond storage pattern\n * @author David Yongjun Kim (@Powerstream3604)\n */\n\nstruct MultiSigStorage {\n    mapping(address => address) owners;\n    mapping(uint256 => mapping(address => mapping(bytes32 => uint256))) approvedHashes;\n    uint256 ownerCount;\n    uint256 threshold;\n    uint256 counter;\n}\n\nlibrary LibMultiSigStorage {\n    function multisigStorage()\n        internal\n        pure\n        returns (MultiSigStorage storage ds)\n    {\n        bytes32 storagePosition = keccak256(\n            \"v0.trustwallet.diamond.storage.MultiSigStorage\"\n        );\n        assembly {\n            ds.slot := storagePosition\n        }\n    }\n}\n"
    },
    "contracts/libraries/LibUtils.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.8.21;\n\nimport {IDiamondLoupe} from \"../facets/base/interfaces/IDiamondLoupe.sol\";\n\nlibrary LibUtils {\n    // Internal utility functions\n    function mergeArrays(\n        bytes4[] memory _array1,\n        bytes4[] memory _array2\n    ) internal pure returns (bytes4[] memory) {\n        uint256 length1 = _array1.length;\n        uint256 length2 = _array2.length;\n        bytes4[] memory mergedArray = new bytes4[](length1 + length2);\n\n        for (uint256 i; i < length1; ) {\n            mergedArray[i] = _array1[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        for (uint256 i; i < length2; ) {\n            mergedArray[length1 + i] = _array2[i];\n            unchecked {\n                ++i;\n            }\n        }\n\n        return mergedArray;\n    }\n\n    function removeFacetElement(\n        IDiamondLoupe.Facet[] memory _facets,\n        uint256 _index\n    ) internal pure returns (IDiamondLoupe.Facet[] memory) {\n        require(_index < _facets.length, \"Invalid index\");\n        require(_facets.length != 0, \"Invalid array\");\n\n        // Create a new array with a length of `_facets.length - 1`\n        IDiamondLoupe.Facet[] memory newArray = new IDiamondLoupe.Facet[](\n            _facets.length - 1\n        );\n        uint256 newArrayLength = newArray.length;\n        // Iterate over the original array, skipping the element at the specified `index`\n        for (uint256 i; i < newArrayLength; ) {\n            if (i < _index) {\n                newArray[i] = _facets[i];\n            } else {\n                newArray[i] = _facets[i + 1];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return newArray;\n    }\n\n    function removeElement(\n        bytes4[] memory _array,\n        uint256 _index\n    ) internal pure returns (bytes4[] memory) {\n        require(_index < _array.length, \"Invalid index\");\n        require(_array.length != 0, \"Invalid array\");\n\n        bytes4[] memory newArray = new bytes4[](_array.length - 1);\n        uint256 newArrayLength = newArray.length;\n        for (uint256 i; i < newArrayLength; ) {\n            if (i < _index) {\n                newArray[i] = _array[i];\n            } else {\n                newArray[i] = _array[i + 1];\n            }\n            unchecked {\n                ++i;\n            }\n        }\n\n        return newArray;\n    }\n\n    function setValue(\n        bytes4[] memory _keys,\n        address[] memory _values,\n        bytes4 _key,\n        address _value\n    ) internal pure returns (bytes4[] memory, address[] memory) {\n        uint256 index = findIndex(_keys, _key);\n        uint256 keysLength = _keys.length;\n        if (index < keysLength) {\n            _values[index] = _value;\n        } else {\n            // Create new storage arrays\n            bytes4[] memory newKeys = new bytes4[](keysLength + 1);\n            address[] memory newValues = new address[](_values.length + 1);\n\n            // Copy values to the new storage arrays\n            for (uint256 i; i < keysLength; ) {\n                newKeys[i] = _keys[i];\n                newValues[i] = _values[i];\n\n                unchecked {\n                    ++i;\n                }\n            }\n\n            // Add the new key-value pair\n            newKeys[keysLength] = _key;\n            newValues[_values.length] = _value;\n\n            return (newKeys, newValues);\n        }\n\n        // If the key already exists, return the original arrays\n        return (_keys, _values);\n    }\n\n    function getValue(\n        bytes4[] memory _keys,\n        address[] memory _values,\n        bytes4 _key\n    ) internal pure returns (address) {\n        uint256 index = findIndex(_keys, _key);\n        if (index >= _keys.length) return address(0);\n\n        return _values[index];\n    }\n\n    function findIndex(\n        bytes4[] memory _keys,\n        bytes4 _key\n    ) internal pure returns (uint256) {\n        uint256 keysLength = _keys.length;\n        for (uint256 i; i < keysLength; ) {\n            if (_keys[i] == _key) {\n                return i;\n            }\n            unchecked {\n                ++i;\n            }\n        }\n        return keysLength;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}