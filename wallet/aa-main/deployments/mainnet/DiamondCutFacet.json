{
  "address": "0x0B9504140771C3688Ff041917192277D2f52E1e0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_securityManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "CallerNotGuardian",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "CallerNotGuardianOrOwner",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__CannotRevokeUnapproved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__DuplicateApproval",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InsufficientApprovers",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidApprovalValidationPeriod",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidApprover",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidApproverSignature",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidArrayLength",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidInitAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidRouteWithGuardian",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__InvalidRouteWithoutGuardian",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__LackOfOwnerApproval",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DiamondCutFacet__OwnerAlreadyApproved",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "DuplicateApprover",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_initializationContractAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "InitializationFunctionReverted",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnregisteredFacetAndSelectors",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroApproverLength",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_init",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "DiamondCut",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "diamondCut",
          "type": "tuple[]"
        }
      ],
      "name": "DiamondCutApprovalRevoked",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "diamondCut",
          "type": "tuple[]"
        }
      ],
      "name": "DiamondCutApproved",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "_lag",
          "type": "bool"
        }
      ],
      "name": "SupportsInterfaceUpdated",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_diamondCutHash",
          "type": "bytes32"
        },
        {
          "internalType": "address[]",
          "name": "_approvers",
          "type": "address[]"
        }
      ],
      "name": "_checkDuplicateOnChainApprover",
      "outputs": [],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        }
      ],
      "name": "approveDiamondCut",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "_init",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "diamondCut",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        },
        {
          "internalType": "address[]",
          "name": "_approvers",
          "type": "address[]"
        },
        {
          "internalType": "bytes[]",
          "name": "_signatures",
          "type": "bytes[]"
        }
      ],
      "name": "diamondCutWithGuardian",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_diamondCutHash",
          "type": "bytes32"
        }
      ],
      "name": "getDiamondCutApprovalCountWithTimeValidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "approvalCount",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        }
      ],
      "name": "getDiamondCutHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "cutHash",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDiamondCutNonce",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "cutNonce",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_diamondCutHash",
          "type": "bytes32"
        }
      ],
      "name": "getOwnerCutApprovalWithTimeValidity",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isApprovedByOwner",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "_diamondCutHash",
          "type": "bytes32"
        },
        {
          "internalType": "address",
          "name": "_approver",
          "type": "address"
        }
      ],
      "name": "isCutApproved",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isApproved",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        }
      ],
      "name": "revokeDiamondCutApproval",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "securityManager",
      "outputs": [
        {
          "internalType": "contract ISecurityManager",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_interfaceId",
          "type": "bytes4"
        },
        {
          "internalType": "bool",
          "name": "_flag",
          "type": "bool"
        }
      ],
      "name": "updateSupportsInterface",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x079e8c8c7c50724507b1e55159b29b915aabe3727561ff1172da76e018bedae6",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xd87dF9Fd27B9a30fe27E7b294CaAa4673F34B6b1",
    "contractAddress": null,
    "transactionIndex": 211,
    "gasUsed": "3079879",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x261997df08a5d156aed98f9cf76977437c8997658167cc4e7fce9bb2aeead461",
    "transactionHash": "0x079e8c8c7c50724507b1e55159b29b915aabe3727561ff1172da76e018bedae6",
    "logs": [],
    "blockNumber": 19517133,
    "cumulativeGasUsed": "16551536",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xcBe266adbfd7CB32988128e7f37b7c8b3C5521A8"
  ],
  "numDeployments": 1,
  "solcInputHash": "ad34345aa73d96f52b3e14df983b6b29",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_securityManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CallerNotGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CallerNotGuardianOrOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__CannotRevokeUnapproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__DuplicateApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InsufficientApprovers\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidApprovalValidationPeriod\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidApprover\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidApproverSignature\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidArrayLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidInitAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidRouteWithGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__InvalidRouteWithoutGuardian\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__LackOfOwnerApproval\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DiamondCutFacet__OwnerAlreadyApproved\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DuplicateApprover\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnregisteredFacetAndSelectors\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroApproverLength\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"diamondCut\",\"type\":\"tuple[]\"}],\"name\":\"DiamondCutApprovalRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"diamondCut\",\"type\":\"tuple[]\"}],\"name\":\"DiamondCutApproved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_lag\",\"type\":\"bool\"}],\"name\":\"SupportsInterfaceUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_diamondCutHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"_approvers\",\"type\":\"address[]\"}],\"name\":\"_checkDuplicateOnChainApprover\",\"outputs\":[],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"}],\"name\":\"approveDiamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"diamondCut\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"_approvers\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_signatures\",\"type\":\"bytes[]\"}],\"name\":\"diamondCutWithGuardian\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_diamondCutHash\",\"type\":\"bytes32\"}],\"name\":\"getDiamondCutApprovalCountWithTimeValidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"approvalCount\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"}],\"name\":\"getDiamondCutHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"cutHash\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDiamondCutNonce\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"cutNonce\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_diamondCutHash\",\"type\":\"bytes32\"}],\"name\":\"getOwnerCutApprovalWithTimeValidity\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApprovedByOwner\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_diamondCutHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"_approver\",\"type\":\"address\"}],\"name\":\"isCutApproved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isApproved\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"}],\"name\":\"revokeDiamondCutApproval\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"securityManager\",\"outputs\":[{\"internalType\":\"contract ISecurityManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_interfaceId\",\"type\":\"bytes4\"},{\"internalType\":\"bool\",\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"updateSupportsInterface\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"David Yongjun Kim (@Powerstream3604)\",\"details\":\"Responsible for adding/removing/replace facets in Barz\",\"kind\":\"dev\",\"methods\":{\"_checkDuplicateOnChainApprover(bytes32,address[])\":{\"params\":{\"_approvers\":\"List of approver addresses\",\"_diamondCutHash\":\"Hash of diamondCut information including the facet addresses and function selectors\"}},\"approveDiamondCut((address,uint8,bytes4[])[])\":{\"params\":{\"_diamondCut\":\"Contains the facet addresses and function selectors\"}},\"constructor\":{\"params\":{\"_securityManager\":\"Security Manager contract that holds the security related variables for all wallets\"}},\"diamondCut((address,uint8,bytes4[])[],address,bytes)\":{\"params\":{\"_diamondCut\":\"Contains the facet addresses and function selectors\",\"_init\":\"The address of the contract or facet to execute _calldata. It's prohibited in Barz\"}},\"diamondCutWithGuardian((address,uint8,bytes4[])[],address[],bytes[])\":{\"params\":{\"_approvers\":\"Guardian or owner address that approves the diamond cut\",\"_diamondCut\":\"Contains the facet addresses and function selectors\",\"_signatures\":\"Signature of Guardians or owner that approves the diamond cut\"}},\"getDiamondCutApprovalCountWithTimeValidity(bytes32)\":{\"params\":{\"_diamondCutHash\":\"Hash of diamondCut information including the facet addresses and function selectors\"}},\"getDiamondCutHash((address,uint8,bytes4[])[])\":{\"params\":{\"_diamondCut\":\"Contains the facet addresses and function selectors\"},\"returns\":{\"cutHash\":\"Diamond Cut Hash\"}},\"getDiamondCutNonce()\":{\"details\":\"This method fetches the nonce from diamond cut storage\",\"returns\":{\"cutNonce\":\"Nonce of diamond cut to protect from reply attacks\"}},\"getOwnerCutApprovalWithTimeValidity(bytes32)\":{\"params\":{\"_diamondCutHash\":\"Hash of diamondCut information including the facet addresses and function selectors\"},\"returns\":{\"isApprovedByOwner\":\"Bool value showing if the owner approved the cut\"}},\"isCutApproved(bytes32,address)\":{\"params\":{\"_approver\":\"Address of approver\",\"_diamondCutHash\":\"Hash of diamondCut information including the facet addresses and function selectors\"},\"returns\":{\"isApproved\":\"Bool value showing if the approver approved the cut\"}},\"revokeDiamondCutApproval((address,uint8,bytes4[])[])\":{\"params\":{\"_diamondCut\":\"Contains the facet addresses and function selectors\"}},\"updateSupportsInterface(bytes4,bool)\":{\"params\":{\"_flag\":\"Bool value to update the mapping of the given interface ID\",\"_interfaceId\":\"InterfaceID to update the mapping\"}}},\"title\":\"DiamondCut Facet\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_checkDuplicateOnChainApprover(bytes32,address[])\":{\"notice\":\"Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval         Approvers who approved on-chain should not be included in the off-chain approval\"},\"approveDiamondCut((address,uint8,bytes4[])[])\":{\"notice\":\"Approves diamond cut. This can only be called directly from guardian or owner\"},\"constructor\":{\"notice\":\"This constructor sets the Security Manager address which is an immutable variable.         Immutable variables do not impact the storage of diamond\"},\"diamondCut((address,uint8,bytes4[])[],address,bytes)\":{\"notice\":\"Add/replace/remove any number of functions and optionally execute         a function with delegatecall when guardians don't exist\"},\"diamondCutWithGuardian((address,uint8,bytes4[])[],address[],bytes[])\":{\"notice\":\"Add/replace/remove any number of functions and optionally execute         a function with delegatecall when guardians exist\"},\"getDiamondCutApprovalCountWithTimeValidity(bytes32)\":{\"notice\":\"Gets the number of approvals of diamond cut from guardians\"},\"getDiamondCutHash((address,uint8,bytes4[])[])\":{\"notice\":\"Returns the diamond cut hash. This function ensures that this hash is safe from replay attack by including         salt, address, chainId, and nonce, etc.\"},\"getDiamondCutNonce()\":{\"notice\":\"Returns the diamond cut nonce of this wallet\"},\"getOwnerCutApprovalWithTimeValidity(bytes32)\":{\"notice\":\"Returns if the owner has approved the diamond cut\"},\"isCutApproved(bytes32,address)\":{\"notice\":\"Returns if the given approver has approved the diamond cut\"},\"revokeDiamondCutApproval((address,uint8,bytes4[])[])\":{\"notice\":\"Revokes the approval of diamond cut. This can only be called directly from guardian or owner\"},\"updateSupportsInterface(bytes4,bool)\":{\"notice\":\"Updates the flag for the interfaceId\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/base/DiamondCutFacet.sol\":\"DiamondCutFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/interfaces/IERC1271.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC1271.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC1271 standard signature validation method for\\n * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC1271 {\\n    /**\\n     * @dev Should return whether the signature provided is valid for the provided data\\n     * @param hash      Hash of the data to be signed\\n     * @param signature Signature byte array associated with _data\\n     */\\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\\n}\\n\",\"keccak256\":\"0x0705a4b1b86d7b0bd8432118f226ba139c44b9dcaba0a6eafba2dd7d0639c544\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Strings.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./math/Math.sol\\\";\\nimport \\\"./math/SignedMath.sol\\\";\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n    uint8 private constant _ADDRESS_LENGTH = 20;\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            uint256 length = Math.log10(value) + 1;\\n            string memory buffer = new string(length);\\n            uint256 ptr;\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                ptr := add(buffer, add(32, length))\\n            }\\n            while (true) {\\n                ptr--;\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\\n                }\\n                value /= 10;\\n                if (value == 0) break;\\n            }\\n            return buffer;\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(int256 value) internal pure returns (string memory) {\\n        return string(abi.encodePacked(value < 0 ? \\\"-\\\" : \\\"\\\", toString(SignedMath.abs(value))));\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        unchecked {\\n            return toHexString(value, Math.log256(value) + 1);\\n        }\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(address addr) internal pure returns (string memory) {\\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\\n    }\\n\\n    /**\\n     * @dev Returns true if the two strings are equal.\\n     */\\n    function equal(string memory a, string memory b) internal pure returns (bool) {\\n        return keccak256(bytes(a)) == keccak256(bytes(b));\\n    }\\n}\\n\",\"keccak256\":\"0x3088eb2868e8d13d89d16670b5f8612c4ab9ff8956272837d8e90106c59c14a0\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV // Deprecated in v4.8\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \\u00f7 2 + 1, and for v in (302): v \\u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            mstore(0x00, \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\")\\n            mstore(0x1c, hash)\\n            message := keccak256(0x00, 0x3c)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            let ptr := mload(0x40)\\n            mstore(ptr, \\\"\\\\x19\\\\x01\\\")\\n            mstore(add(ptr, 0x02), domainSeparator)\\n            mstore(add(ptr, 0x22), structHash)\\n            data := keccak256(ptr, 0x42)\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\\n     * `validator` and `data` according to the version 0 of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x00\\\", validator, data));\\n    }\\n}\\n\",\"keccak256\":\"0x809bc3edb4bcbef8263fa616c1b60ee0004b50a8a1bfa164d8f57fd31f520c58\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/SignatureChecker.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./ECDSA.sol\\\";\\nimport \\\"../../interfaces/IERC1271.sol\\\";\\n\\n/**\\n * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support both ECDSA\\n * signatures from externally owned accounts (EOAs) as well as ERC1271 signatures from smart contract wallets like\\n * Argent and Gnosis Safe.\\n *\\n * _Available since v4.1._\\n */\\nlibrary SignatureChecker {\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. If the signer is a smart contract, the\\n     * signature is validated against that smart contract using ERC1271, otherwise it's validated using `ECDSA.recover`.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {\\n        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);\\n        return\\n            (error == ECDSA.RecoverError.NoError && recovered == signer) ||\\n            isValidERC1271SignatureNow(signer, hash, signature);\\n    }\\n\\n    /**\\n     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated\\n     * against the signer smart contract using ERC1271.\\n     *\\n     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus\\n     * change through time. It could return true at block N and false at block N+1 (or the opposite).\\n     */\\n    function isValidERC1271SignatureNow(\\n        address signer,\\n        bytes32 hash,\\n        bytes memory signature\\n    ) internal view returns (bool) {\\n        (bool success, bytes memory result) = signer.staticcall(\\n            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)\\n        );\\n        return (success &&\\n            result.length >= 32 &&\\n            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));\\n    }\\n}\\n\",\"keccak256\":\"0x3af3ca86df39aac39a0514c84459d691434a108d2151c8ce9d69f32e315cab80\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n    enum Rounding {\\n        Down, // Toward negative infinity\\n        Up, // Toward infinity\\n        Zero // Toward zero\\n    }\\n\\n    /**\\n     * @dev Returns the largest of two numbers.\\n     */\\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two numbers.\\n     */\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b) / 2 can overflow.\\n        return (a & b) + (a ^ b) / 2;\\n    }\\n\\n    /**\\n     * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n        // (a + b - 1) / b can overflow on addition, so we distribute.\\n        return a == 0 ? 0 : (a - 1) / b + 1;\\n    }\\n\\n    /**\\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\\n        unchecked {\\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n            // variables such that product = prod1 * 2^256 + prod0.\\n            uint256 prod0; // Least significant 256 bits of the product\\n            uint256 prod1; // Most significant 256 bits of the product\\n            assembly {\\n                let mm := mulmod(x, y, not(0))\\n                prod0 := mul(x, y)\\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n            }\\n\\n            // Handle non-overflow cases, 256 by 256 division.\\n            if (prod1 == 0) {\\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\\n                // The surrounding unchecked block does not change this fact.\\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\\n                return prod0 / denominator;\\n            }\\n\\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n            require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n            ///////////////////////////////////////////////\\n            // 512 by 256 division.\\n            ///////////////////////////////////////////////\\n\\n            // Make division exact by subtracting the remainder from [prod1 prod0].\\n            uint256 remainder;\\n            assembly {\\n                // Compute remainder using mulmod.\\n                remainder := mulmod(x, y, denominator)\\n\\n                // Subtract 256 bit number from 512 bit number.\\n                prod1 := sub(prod1, gt(remainder, prod0))\\n                prod0 := sub(prod0, remainder)\\n            }\\n\\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n            // See https://cs.stackexchange.com/q/138556/92363.\\n\\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\\n            uint256 twos = denominator & (~denominator + 1);\\n            assembly {\\n                // Divide denominator by twos.\\n                denominator := div(denominator, twos)\\n\\n                // Divide [prod1 prod0] by twos.\\n                prod0 := div(prod0, twos)\\n\\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n                twos := add(div(sub(0, twos), twos), 1)\\n            }\\n\\n            // Shift in bits from prod1 into prod0.\\n            prod0 |= prod1 * twos;\\n\\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n            // four bits. That is, denominator * inv = 1 mod 2^4.\\n            uint256 inverse = (3 * denominator) ^ 2;\\n\\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n            // in modular arithmetic, doubling the correct bits in each step.\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n            // is no longer required.\\n            result = prod0 * inverse;\\n            return result;\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\\n        uint256 result = mulDiv(x, y, denominator);\\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n            result += 1;\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n    function sqrt(uint256 a) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n        //\\n        // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n        //\\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n        // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n        // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n        //\\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n        uint256 result = 1 << (log2(a) >> 1);\\n\\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n        // into the expected uint128 result.\\n        unchecked {\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            result = (result + a / result) >> 1;\\n            return min(result, a / result);\\n        }\\n    }\\n\\n    /**\\n     * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = sqrt(a);\\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 128;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 64;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 32;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 16;\\n            }\\n            if (value >> 8 > 0) {\\n                value >>= 8;\\n                result += 8;\\n            }\\n            if (value >> 4 > 0) {\\n                value >>= 4;\\n                result += 4;\\n            }\\n            if (value >> 2 > 0) {\\n                value >>= 2;\\n                result += 2;\\n            }\\n            if (value >> 1 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log2(value);\\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >= 10 ** 64) {\\n                value /= 10 ** 64;\\n                result += 64;\\n            }\\n            if (value >= 10 ** 32) {\\n                value /= 10 ** 32;\\n                result += 32;\\n            }\\n            if (value >= 10 ** 16) {\\n                value /= 10 ** 16;\\n                result += 16;\\n            }\\n            if (value >= 10 ** 8) {\\n                value /= 10 ** 8;\\n                result += 8;\\n            }\\n            if (value >= 10 ** 4) {\\n                value /= 10 ** 4;\\n                result += 4;\\n            }\\n            if (value >= 10 ** 2) {\\n                value /= 10 ** 2;\\n                result += 2;\\n            }\\n            if (value >= 10 ** 1) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log10(value);\\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\\n        }\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n    function log256(uint256 value) internal pure returns (uint256) {\\n        uint256 result = 0;\\n        unchecked {\\n            if (value >> 128 > 0) {\\n                value >>= 128;\\n                result += 16;\\n            }\\n            if (value >> 64 > 0) {\\n                value >>= 64;\\n                result += 8;\\n            }\\n            if (value >> 32 > 0) {\\n                value >>= 32;\\n                result += 4;\\n            }\\n            if (value >> 16 > 0) {\\n                value >>= 16;\\n                result += 2;\\n            }\\n            if (value >> 8 > 0) {\\n                result += 1;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    /**\\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 result = log256(value);\\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xe4455ac1eb7fc497bb7402579e7b4d64d928b846fce7d2b6fde06d366f21c2b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\\n * checks.\\n *\\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\\n * easily result in undesired exploitation or bugs, since developers usually\\n * assume that overflows raise errors. `SafeCast` restores this intuition by\\n * reverting the transaction when such an operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n *\\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\\n * all math on `uint256` and `int256` and then downcasting.\\n */\\nlibrary SafeCast {\\n    /**\\n     * @dev Returns the downcasted uint248 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint248).\\n     *\\n     * Counterpart to Solidity's `uint248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint248(uint256 value) internal pure returns (uint248) {\\n        require(value <= type(uint248).max, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n        return uint248(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint240 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint240).\\n     *\\n     * Counterpart to Solidity's `uint240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint240(uint256 value) internal pure returns (uint240) {\\n        require(value <= type(uint240).max, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n        return uint240(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint232 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint232).\\n     *\\n     * Counterpart to Solidity's `uint232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint232(uint256 value) internal pure returns (uint232) {\\n        require(value <= type(uint232).max, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n        return uint232(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint224 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint224).\\n     *\\n     * Counterpart to Solidity's `uint224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint224(uint256 value) internal pure returns (uint224) {\\n        require(value <= type(uint224).max, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n        return uint224(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint216 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint216).\\n     *\\n     * Counterpart to Solidity's `uint216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint216(uint256 value) internal pure returns (uint216) {\\n        require(value <= type(uint216).max, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n        return uint216(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint208 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint208).\\n     *\\n     * Counterpart to Solidity's `uint208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint208(uint256 value) internal pure returns (uint208) {\\n        require(value <= type(uint208).max, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n        return uint208(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint200 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint200).\\n     *\\n     * Counterpart to Solidity's `uint200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint200(uint256 value) internal pure returns (uint200) {\\n        require(value <= type(uint200).max, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n        return uint200(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint192 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint192).\\n     *\\n     * Counterpart to Solidity's `uint192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint192(uint256 value) internal pure returns (uint192) {\\n        require(value <= type(uint192).max, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n        return uint192(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint184 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint184).\\n     *\\n     * Counterpart to Solidity's `uint184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint184(uint256 value) internal pure returns (uint184) {\\n        require(value <= type(uint184).max, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n        return uint184(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint176 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint176).\\n     *\\n     * Counterpart to Solidity's `uint176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint176(uint256 value) internal pure returns (uint176) {\\n        require(value <= type(uint176).max, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n        return uint176(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint168 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint168).\\n     *\\n     * Counterpart to Solidity's `uint168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint168(uint256 value) internal pure returns (uint168) {\\n        require(value <= type(uint168).max, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n        return uint168(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint160 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint160).\\n     *\\n     * Counterpart to Solidity's `uint160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint160(uint256 value) internal pure returns (uint160) {\\n        require(value <= type(uint160).max, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n        return uint160(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint152 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint152).\\n     *\\n     * Counterpart to Solidity's `uint152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint152(uint256 value) internal pure returns (uint152) {\\n        require(value <= type(uint152).max, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n        return uint152(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint144 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint144).\\n     *\\n     * Counterpart to Solidity's `uint144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint144(uint256 value) internal pure returns (uint144) {\\n        require(value <= type(uint144).max, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n        return uint144(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint136 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint136).\\n     *\\n     * Counterpart to Solidity's `uint136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint136(uint256 value) internal pure returns (uint136) {\\n        require(value <= type(uint136).max, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n        return uint136(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint128 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint128).\\n     *\\n     * Counterpart to Solidity's `uint128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint128(uint256 value) internal pure returns (uint128) {\\n        require(value <= type(uint128).max, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n        return uint128(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint120 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint120).\\n     *\\n     * Counterpart to Solidity's `uint120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint120(uint256 value) internal pure returns (uint120) {\\n        require(value <= type(uint120).max, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n        return uint120(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint112 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint112).\\n     *\\n     * Counterpart to Solidity's `uint112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint112(uint256 value) internal pure returns (uint112) {\\n        require(value <= type(uint112).max, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n        return uint112(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint104 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint104).\\n     *\\n     * Counterpart to Solidity's `uint104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint104(uint256 value) internal pure returns (uint104) {\\n        require(value <= type(uint104).max, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n        return uint104(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint96 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint96).\\n     *\\n     * Counterpart to Solidity's `uint96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.2._\\n     */\\n    function toUint96(uint256 value) internal pure returns (uint96) {\\n        require(value <= type(uint96).max, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n        return uint96(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint88 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint88).\\n     *\\n     * Counterpart to Solidity's `uint88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint88(uint256 value) internal pure returns (uint88) {\\n        require(value <= type(uint88).max, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n        return uint88(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint80 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint80).\\n     *\\n     * Counterpart to Solidity's `uint80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint80(uint256 value) internal pure returns (uint80) {\\n        require(value <= type(uint80).max, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n        return uint80(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint72 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint72).\\n     *\\n     * Counterpart to Solidity's `uint72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint72(uint256 value) internal pure returns (uint72) {\\n        require(value <= type(uint72).max, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n        return uint72(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint64 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint64).\\n     *\\n     * Counterpart to Solidity's `uint64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint64(uint256 value) internal pure returns (uint64) {\\n        require(value <= type(uint64).max, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n        return uint64(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint56 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint56).\\n     *\\n     * Counterpart to Solidity's `uint56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint56(uint256 value) internal pure returns (uint56) {\\n        require(value <= type(uint56).max, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n        return uint56(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint48 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint48).\\n     *\\n     * Counterpart to Solidity's `uint48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint48(uint256 value) internal pure returns (uint48) {\\n        require(value <= type(uint48).max, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n        return uint48(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint40 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint40).\\n     *\\n     * Counterpart to Solidity's `uint40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint40(uint256 value) internal pure returns (uint40) {\\n        require(value <= type(uint40).max, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n        return uint40(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint32 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint32).\\n     *\\n     * Counterpart to Solidity's `uint32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint32(uint256 value) internal pure returns (uint32) {\\n        require(value <= type(uint32).max, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n        return uint32(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint24 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint24).\\n     *\\n     * Counterpart to Solidity's `uint24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toUint24(uint256 value) internal pure returns (uint24) {\\n        require(value <= type(uint24).max, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n        return uint24(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint16 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint16).\\n     *\\n     * Counterpart to Solidity's `uint16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint16(uint256 value) internal pure returns (uint16) {\\n        require(value <= type(uint16).max, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n        return uint16(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted uint8 from uint256, reverting on\\n     * overflow (when the input is greater than largest uint8).\\n     *\\n     * Counterpart to Solidity's `uint8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v2.5._\\n     */\\n    function toUint8(uint256 value) internal pure returns (uint8) {\\n        require(value <= type(uint8).max, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n        return uint8(value);\\n    }\\n\\n    /**\\n     * @dev Converts a signed int256 into an unsigned uint256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be greater than or equal to 0.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toUint256(int256 value) internal pure returns (uint256) {\\n        require(value >= 0, \\\"SafeCast: value must be positive\\\");\\n        return uint256(value);\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int248 from int256, reverting on\\n     * overflow (when the input is less than smallest int248 or\\n     * greater than largest int248).\\n     *\\n     * Counterpart to Solidity's `int248` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 248 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\\n        downcasted = int248(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 248 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int240 from int256, reverting on\\n     * overflow (when the input is less than smallest int240 or\\n     * greater than largest int240).\\n     *\\n     * Counterpart to Solidity's `int240` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 240 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\\n        downcasted = int240(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 240 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int232 from int256, reverting on\\n     * overflow (when the input is less than smallest int232 or\\n     * greater than largest int232).\\n     *\\n     * Counterpart to Solidity's `int232` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 232 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\\n        downcasted = int232(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 232 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int224 from int256, reverting on\\n     * overflow (when the input is less than smallest int224 or\\n     * greater than largest int224).\\n     *\\n     * Counterpart to Solidity's `int224` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 224 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\\n        downcasted = int224(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 224 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int216 from int256, reverting on\\n     * overflow (when the input is less than smallest int216 or\\n     * greater than largest int216).\\n     *\\n     * Counterpart to Solidity's `int216` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 216 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\\n        downcasted = int216(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 216 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int208 from int256, reverting on\\n     * overflow (when the input is less than smallest int208 or\\n     * greater than largest int208).\\n     *\\n     * Counterpart to Solidity's `int208` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 208 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\\n        downcasted = int208(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 208 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int200 from int256, reverting on\\n     * overflow (when the input is less than smallest int200 or\\n     * greater than largest int200).\\n     *\\n     * Counterpart to Solidity's `int200` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 200 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\\n        downcasted = int200(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 200 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int192 from int256, reverting on\\n     * overflow (when the input is less than smallest int192 or\\n     * greater than largest int192).\\n     *\\n     * Counterpart to Solidity's `int192` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 192 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\\n        downcasted = int192(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 192 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int184 from int256, reverting on\\n     * overflow (when the input is less than smallest int184 or\\n     * greater than largest int184).\\n     *\\n     * Counterpart to Solidity's `int184` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 184 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\\n        downcasted = int184(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 184 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int176 from int256, reverting on\\n     * overflow (when the input is less than smallest int176 or\\n     * greater than largest int176).\\n     *\\n     * Counterpart to Solidity's `int176` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 176 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\\n        downcasted = int176(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 176 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int168 from int256, reverting on\\n     * overflow (when the input is less than smallest int168 or\\n     * greater than largest int168).\\n     *\\n     * Counterpart to Solidity's `int168` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 168 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\\n        downcasted = int168(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 168 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int160 from int256, reverting on\\n     * overflow (when the input is less than smallest int160 or\\n     * greater than largest int160).\\n     *\\n     * Counterpart to Solidity's `int160` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 160 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\\n        downcasted = int160(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 160 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int152 from int256, reverting on\\n     * overflow (when the input is less than smallest int152 or\\n     * greater than largest int152).\\n     *\\n     * Counterpart to Solidity's `int152` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 152 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\\n        downcasted = int152(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 152 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int144 from int256, reverting on\\n     * overflow (when the input is less than smallest int144 or\\n     * greater than largest int144).\\n     *\\n     * Counterpart to Solidity's `int144` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 144 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\\n        downcasted = int144(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 144 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int136 from int256, reverting on\\n     * overflow (when the input is less than smallest int136 or\\n     * greater than largest int136).\\n     *\\n     * Counterpart to Solidity's `int136` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 136 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\\n        downcasted = int136(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 136 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int128 from int256, reverting on\\n     * overflow (when the input is less than smallest int128 or\\n     * greater than largest int128).\\n     *\\n     * Counterpart to Solidity's `int128` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 128 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\\n        downcasted = int128(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 128 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int120 from int256, reverting on\\n     * overflow (when the input is less than smallest int120 or\\n     * greater than largest int120).\\n     *\\n     * Counterpart to Solidity's `int120` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 120 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\\n        downcasted = int120(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 120 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int112 from int256, reverting on\\n     * overflow (when the input is less than smallest int112 or\\n     * greater than largest int112).\\n     *\\n     * Counterpart to Solidity's `int112` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 112 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\\n        downcasted = int112(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 112 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int104 from int256, reverting on\\n     * overflow (when the input is less than smallest int104 or\\n     * greater than largest int104).\\n     *\\n     * Counterpart to Solidity's `int104` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 104 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\\n        downcasted = int104(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 104 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int96 from int256, reverting on\\n     * overflow (when the input is less than smallest int96 or\\n     * greater than largest int96).\\n     *\\n     * Counterpart to Solidity's `int96` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 96 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\\n        downcasted = int96(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 96 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int88 from int256, reverting on\\n     * overflow (when the input is less than smallest int88 or\\n     * greater than largest int88).\\n     *\\n     * Counterpart to Solidity's `int88` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 88 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\\n        downcasted = int88(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 88 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int80 from int256, reverting on\\n     * overflow (when the input is less than smallest int80 or\\n     * greater than largest int80).\\n     *\\n     * Counterpart to Solidity's `int80` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 80 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\\n        downcasted = int80(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 80 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int72 from int256, reverting on\\n     * overflow (when the input is less than smallest int72 or\\n     * greater than largest int72).\\n     *\\n     * Counterpart to Solidity's `int72` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 72 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\\n        downcasted = int72(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 72 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int64 from int256, reverting on\\n     * overflow (when the input is less than smallest int64 or\\n     * greater than largest int64).\\n     *\\n     * Counterpart to Solidity's `int64` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 64 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\\n        downcasted = int64(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 64 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int56 from int256, reverting on\\n     * overflow (when the input is less than smallest int56 or\\n     * greater than largest int56).\\n     *\\n     * Counterpart to Solidity's `int56` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 56 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\\n        downcasted = int56(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 56 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int48 from int256, reverting on\\n     * overflow (when the input is less than smallest int48 or\\n     * greater than largest int48).\\n     *\\n     * Counterpart to Solidity's `int48` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 48 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\\n        downcasted = int48(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 48 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int40 from int256, reverting on\\n     * overflow (when the input is less than smallest int40 or\\n     * greater than largest int40).\\n     *\\n     * Counterpart to Solidity's `int40` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 40 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\\n        downcasted = int40(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 40 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int32 from int256, reverting on\\n     * overflow (when the input is less than smallest int32 or\\n     * greater than largest int32).\\n     *\\n     * Counterpart to Solidity's `int32` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 32 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\\n        downcasted = int32(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 32 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int24 from int256, reverting on\\n     * overflow (when the input is less than smallest int24 or\\n     * greater than largest int24).\\n     *\\n     * Counterpart to Solidity's `int24` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 24 bits\\n     *\\n     * _Available since v4.7._\\n     */\\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\\n        downcasted = int24(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 24 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int16 from int256, reverting on\\n     * overflow (when the input is less than smallest int16 or\\n     * greater than largest int16).\\n     *\\n     * Counterpart to Solidity's `int16` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 16 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\\n        downcasted = int16(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 16 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Returns the downcasted int8 from int256, reverting on\\n     * overflow (when the input is less than smallest int8 or\\n     * greater than largest int8).\\n     *\\n     * Counterpart to Solidity's `int8` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - input must fit into 8 bits\\n     *\\n     * _Available since v3.1._\\n     */\\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\\n        downcasted = int8(value);\\n        require(downcasted == value, \\\"SafeCast: value doesn't fit in 8 bits\\\");\\n    }\\n\\n    /**\\n     * @dev Converts an unsigned uint256 into a signed int256.\\n     *\\n     * Requirements:\\n     *\\n     * - input must be less than or equal to maxInt256.\\n     *\\n     * _Available since v3.0._\\n     */\\n    function toInt256(uint256 value) internal pure returns (int256) {\\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\\n        require(value <= uint256(type(int256).max), \\\"SafeCast: value doesn't fit in an int256\\\");\\n        return int256(value);\\n    }\\n}\\n\",\"keccak256\":\"0x52a8cfb0f5239d11b457dcdd1b326992ef672714ca8da71a157255bddd13f3ad\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/math/SignedMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Standard signed math utilities missing in the Solidity language.\\n */\\nlibrary SignedMath {\\n    /**\\n     * @dev Returns the largest of two signed numbers.\\n     */\\n    function max(int256 a, int256 b) internal pure returns (int256) {\\n        return a > b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the smallest of two signed numbers.\\n     */\\n    function min(int256 a, int256 b) internal pure returns (int256) {\\n        return a < b ? a : b;\\n    }\\n\\n    /**\\n     * @dev Returns the average of two signed numbers without overflow.\\n     * The result is rounded towards zero.\\n     */\\n    function average(int256 a, int256 b) internal pure returns (int256) {\\n        // Formula from the book \\\"Hacker's Delight\\\"\\n        int256 x = (a & b) + ((a ^ b) >> 1);\\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\\n    }\\n\\n    /**\\n     * @dev Returns the absolute unsigned value of a signed value.\\n     */\\n    function abs(int256 n) internal pure returns (uint256) {\\n        unchecked {\\n            // must be unchecked in order to support `n = type(int256).min`\\n            return uint256(n >= 0 ? n : -n);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf92515413956f529d95977adc9b0567d583c6203fc31ab1c23824c35187e3ddc\",\"license\":\"MIT\"},\"contracts/aa-4337/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.21;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\nfunction _parseValidationData(\\n    uint validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n// intersect account and paymaster ranges.\\nfunction _intersectTimeRange(\\n    uint256 validationData,\\n    uint256 paymasterValidationData\\n) pure returns (ValidationData memory) {\\n    ValidationData memory accountValidationData = _parseValidationData(\\n        validationData\\n    );\\n    ValidationData memory pmValidationData = _parseValidationData(\\n        paymasterValidationData\\n    );\\n    address aggregator = accountValidationData.aggregator;\\n    if (aggregator == address(0)) {\\n        aggregator = pmValidationData.aggregator;\\n    }\\n    uint48 validAfter = accountValidationData.validAfter;\\n    uint48 validUntil = accountValidationData.validUntil;\\n    uint48 pmValidAfter = pmValidationData.validAfter;\\n    uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n    if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n    if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ? 1 : 0) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\nfunction calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n    assembly {\\n        let mem := mload(0x40)\\n        let len := data.length\\n        calldatacopy(mem, data.offset, len)\\n        ret := keccak256(mem, len)\\n    }\\n}\\n\",\"keccak256\":\"0xa79f06cd158ecb8c0da95493a2f348933b8627a63e228b99738bff3aa107942d\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(\\n        UserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(\\n        UserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(\\n        UserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0xdfdcd80568f037716674619b31be630fcd8316262f05a815b41d1e81782c966a\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo\\n    );\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo\\n    );\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(\\n        uint256 preOpGas,\\n        uint256 paid,\\n        uint48 validAfter,\\n        uint48 validUntil,\\n        bool targetSuccess,\\n        bytes targetResult\\n    );\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(\\n        UserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(\\n        UserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(\\n        UserOperation calldata op,\\n        address target,\\n        bytes calldata targetCallData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9ccb1b188eda8bbf5f6c2d01bd83c3d8b2b04fcf745283051d31fe96d1d8e40f\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface INonceManager {\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(\\n        address sender,\\n        uint192 key\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0xce478ad0fa0d18a3b785ac854623029e7ab463d05873dfaa365abfa1bf100912\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xadcea606c9b7aafe6645441f2154a60f271330b0eee5292a632aa71c1672d546\",\"license\":\"GPL-3.0-only\"},\"contracts/aa-4337/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor/\\n * @param callData the method call to execute on this account.\\n * @param callGasLimit the gas limit passed to the callData method call.\\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter.\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGasLimit;\\n    uint256 verificationGasLimit;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n    function getSender(\\n        UserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(\\n        UserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    function pack(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return\\n            abi.encode(\\n                sender,\\n                nonce,\\n                hashInitCode,\\n                hashCallData,\\n                callGasLimit,\\n                verificationGasLimit,\\n                preVerificationGas,\\n                maxFeePerGas,\\n                maxPriorityFeePerGas,\\n                hashPaymasterAndData\\n            );\\n    }\\n\\n    function hash(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x2429f5cc546bdee08c7e63858d0dda8491eaa3ab5194df884dc948c1154d2834\",\"license\":\"GPL-3.0\"},\"contracts/facets/Modifiers.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {LibGuardian} from \\\"../libraries/LibGuardian.sol\\\";\\nimport {BarzStorage} from \\\"../libraries/LibAppStorage.sol\\\";\\nimport {IDiamondCut} from \\\"../facets/base/interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title Modifiers\\n * @dev Responsible for providing modifiers/util functions to Facet contracts\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\nabstract contract Modifiers is BarzStorage {\\n    uint8 constant INNER_STRUCT = 0;\\n\\n    error CallerNotGuardian();\\n    error CallerNotGuardianOrOwner();\\n    error DuplicateApprover();\\n    error ZeroApproverLength();\\n    error UnregisteredFacetAndSelectors();\\n\\n    /**\\n     * @notice Modifier to only allow guardian to make a call, reverts if any other entity is the caller\\n     */\\n    modifier onlyGuardian() {\\n        if (!LibGuardian.isGuardian(msg.sender)) revert CallerNotGuardian();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Modifier to only allow guardian or owner to make a call, reverts if any other entity is the caller\\n     */\\n    modifier onlyGuardianOrOwner() {\\n        if (!LibGuardian.isGuardian(msg.sender) && address(this) != msg.sender)\\n            revert CallerNotGuardianOrOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @notice Checks if the approver address is the array is unique with no duplicate\\n     * @dev This method loops through the array and checks if a duplicate address exists, it reverts if duplicate address exists\\n     * @param approvers Array of address\\n     */\\n    function _checkApprover(\\n        address[] memory approvers\\n    ) internal pure returns (bool) {\\n        uint256 approverLength = approvers.length;\\n        if (0 == approverLength) revert ZeroApproverLength();\\n        for (uint256 i; i < approverLength - 1; ) {\\n            for (uint256 j = i + 1; j < approverLength; ) {\\n                if (approvers[i] == approvers[j]) {\\n                    revert DuplicateApprover(); // Found a duplicate\\n                }\\n                unchecked {\\n                    ++j;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return false; // No duplicates found\\n    }\\n\\n    /**\\n     * @notice Checks if the facet getting added or replaced is registered to facet registry\\n     * @dev This method loops through the cut and checks if the facet getting added/replaced is registered to facet registry\\n     * @param _diamondCut Array of FacetCut, data for diamondCut defined in EIP-2535\\n     */\\n    function _checkFacetCutValidity(\\n        IDiamondCut.FacetCut[] memory _diamondCut\\n    ) internal view {\\n        uint256 diamondCutLength = _diamondCut.length;\\n        for (uint256 i; i < diamondCutLength; ) {\\n            if (\\n                _diamondCut[i].action == IDiamondCut.FacetCutAction.Add ||\\n                _diamondCut[i].action == IDiamondCut.FacetCutAction.Replace\\n            ) {\\n                if (\\n                    !s.facetRegistry.areFacetFunctionSelectorsRegistered(\\n                        _diamondCut[i].facetAddress,\\n                        _diamondCut[i].functionSelectors\\n                    )\\n                ) revert UnregisteredFacetAndSelectors();\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xb42956323d199bdec243a5f9859439aae057fbfdd1d79e3a96afc857ecb3115f\",\"license\":\"Apache-2.0\"},\"contracts/facets/base/DiamondCutFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {LibDiamond} from \\\"../../libraries/LibDiamond.sol\\\";\\nimport {LibGuardian} from \\\"../../libraries/LibGuardian.sol\\\";\\nimport {ISecurityManager} from \\\"../../infrastructure/interfaces/ISecurityManager.sol\\\";\\nimport {SignatureChecker} from \\\"@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\\\";\\nimport {LibFacetStorage, DiamondCutApprovalConfig, ApprovalConfig} from \\\"../../libraries/LibFacetStorage.sol\\\";\\nimport {Modifiers} from \\\"../Modifiers.sol\\\";\\nimport {IDiamondCut} from \\\"./interfaces/IDiamondCut.sol\\\";\\n\\n/**\\n * @title DiamondCut Facet\\n * @dev Responsible for adding/removing/replace facets in Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ncontract DiamondCutFacet is Modifiers, IDiamondCut {\\n    ISecurityManager public immutable securityManager;\\n\\n    /**\\n     * @notice This constructor sets the Security Manager address which is an immutable variable.\\n     *         Immutable variables do not impact the storage of diamond\\n     * @param _securityManager Security Manager contract that holds the security related variables for all wallets\\n     */\\n    constructor(address _securityManager) {\\n        securityManager = ISecurityManager(_securityManager);\\n    }\\n\\n    /**\\n     * @notice Updates the flag for the interfaceId\\n     * @param _interfaceId InterfaceID to update the mapping\\n     * @param _flag Bool value to update the mapping of the given interface ID\\n     */\\n    function updateSupportsInterface(\\n        bytes4 _interfaceId,\\n        bool _flag\\n    ) external override onlyWhenUnlocked {\\n        LibDiamond.enforceIsSelf();\\n        LibDiamond.diamondStorage().supportedInterfaces[_interfaceId] = _flag;\\n        emit SupportsInterfaceUpdated(_interfaceId, _flag);\\n    }\\n\\n    /**\\n     * @notice Add/replace/remove any number of functions and optionally execute\\n     *         a function with delegatecall when guardians don't exist\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _init The address of the contract or facet to execute _calldata. It's prohibited in Barz\\n     */\\n    function diamondCut(\\n        FacetCut[] calldata _diamondCut,\\n        address _init,\\n        bytes calldata\\n    ) external override onlyWhenUnlocked {\\n        LibDiamond.enforceIsSelf();\\n\\n        _checkFacetCutValidity(_diamondCut);\\n        // require approval from guardian if guardian exists\\n        if (0 != LibGuardian.guardianCount())\\n            revert DiamondCutFacet__InvalidRouteWithGuardian();\\n        if (address(0) != _init) revert DiamondCutFacet__InvalidInitAddress();\\n\\n        unchecked {\\n            ++LibFacetStorage.diamondCutStorage().nonce;\\n        }\\n        LibDiamond.diamondCut(_diamondCut, address(0), \\\"\\\");\\n    }\\n\\n    /**\\n     * @notice Add/replace/remove any number of functions and optionally execute\\n     *         a function with delegatecall when guardians exist\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @param _approvers Guardian or owner address that approves the diamond cut\\n     * @param _signatures Signature of Guardians or owner that approves the diamond cut\\n     */\\n    function diamondCutWithGuardian(\\n        FacetCut[] calldata _diamondCut,\\n        address[] calldata _approvers,\\n        bytes[] calldata _signatures\\n    ) external override onlyWhenUnlocked {\\n        if (_approvers.length != _signatures.length)\\n            revert DiamondCutFacet__InvalidArrayLength();\\n        _checkFacetCutValidity(_diamondCut);\\n        if (0 == LibGuardian.guardianCount())\\n            revert DiamondCutFacet__InvalidRouteWithGuardian();\\n\\n        bytes32 cutHash = getDiamondCutHash(_diamondCut);\\n\\n        _checkApprover(_approvers);\\n        _checkDuplicateOnChainApprover(cutHash, _approvers);\\n\\n        bool onChainOwnerApproval = getOwnerCutApprovalWithTimeValidity(\\n            cutHash\\n        );\\n\\n        uint256 threshold = onChainOwnerApproval ? 0 : 1;\\n        if (\\n            _approvers.length +\\n                getDiamondCutApprovalCountWithTimeValidity(cutHash) <\\n            LibGuardian.majorityOfGuardians() + threshold\\n        ) revert DiamondCutFacet__InsufficientApprovers();\\n\\n        bool ownerApproved;\\n        for (uint256 i; i < _approvers.length; ) {\\n            if (\\n                !LibGuardian.isGuardian(_approvers[i]) &&\\n                _approvers[i] != address(this)\\n            ) revert DiamondCutFacet__InvalidApprover();\\n            if (_approvers[i] == address(this)) {\\n                if (onChainOwnerApproval)\\n                    revert DiamondCutFacet__OwnerAlreadyApproved();\\n                ownerApproved = true;\\n            }\\n            if (\\n                !SignatureChecker.isValidSignatureNow(\\n                    _approvers[i],\\n                    cutHash,\\n                    _signatures[i]\\n                )\\n            ) revert DiamondCutFacet__InvalidApproverSignature();\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        if (!ownerApproved && !onChainOwnerApproval)\\n            revert DiamondCutFacet__LackOfOwnerApproval();\\n\\n        unchecked {\\n            ++LibFacetStorage.diamondCutStorage().nonce;\\n        }\\n        LibDiamond.diamondCut(_diamondCut, address(0), \\\"\\\");\\n    }\\n\\n    /**\\n     * @notice Approves diamond cut. This can only be called directly from guardian or owner\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     */\\n    function approveDiamondCut(\\n        FacetCut[] calldata _diamondCut\\n    ) public override onlyGuardianOrOwner onlyWhenUnlocked {\\n        if (LibGuardian.guardianCount() == 0)\\n            revert DiamondCutFacet__InvalidRouteWithoutGuardian();\\n        DiamondCutApprovalConfig storage ds = LibFacetStorage\\n            .diamondCutStorage()\\n            .diamondCutApprovalConfigs[INNER_STRUCT];\\n        _checkFacetCutValidity(_diamondCut);\\n\\n        bytes32 cutHash = getDiamondCutHash(_diamondCut);\\n        uint64 approvalValidUntil = uint64(\\n            block.timestamp + getApprovalValidationPeriod()\\n        );\\n        ds.isDiamondCutApproved[cutHash][msg.sender] = ApprovalConfig(\\n            true,\\n            approvalValidUntil\\n        );\\n        emit DiamondCutApproved(_diamondCut);\\n        if (\\n            (getDiamondCutApprovalCountWithTimeValidity(cutHash) >=\\n                LibGuardian.majorityOfGuardians()) &&\\n            getOwnerCutApprovalWithTimeValidity(cutHash)\\n        ) {\\n            unchecked {\\n                ++LibFacetStorage.diamondCutStorage().nonce;\\n            }\\n            LibDiamond.diamondCut(_diamondCut, address(0), \\\"\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Revokes the approval of diamond cut. This can only be called directly from guardian or owner\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     */\\n    function revokeDiamondCutApproval(\\n        FacetCut[] calldata _diamondCut\\n    ) public override onlyGuardianOrOwner onlyWhenUnlocked {\\n        DiamondCutApprovalConfig storage ds = LibFacetStorage\\n            .diamondCutStorage()\\n            .diamondCutApprovalConfigs[INNER_STRUCT];\\n        bytes32 cutHash = getDiamondCutHash(_diamondCut);\\n        if (!ds.isDiamondCutApproved[cutHash][msg.sender].isApproved)\\n            revert DiamondCutFacet__CannotRevokeUnapproved();\\n        ds.isDiamondCutApproved[cutHash][msg.sender] = ApprovalConfig(false, 0);\\n        emit DiamondCutApprovalRevoked(_diamondCut);\\n    }\\n\\n    /**\\n     * @notice Gets the number of approvals of diamond cut from guardians\\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\\n     */\\n    function getDiamondCutApprovalCountWithTimeValidity(\\n        bytes32 _diamondCutHash\\n    ) public view override returns (uint256 approvalCount) {\\n        address[] memory guardians = LibGuardian.getGuardians();\\n        uint256 guardiansLength = guardians.length;\\n        for (uint256 i; i < guardiansLength; ) {\\n            if (isCutApproved(_diamondCutHash, guardians[i])) {\\n                unchecked {\\n                    ++approvalCount;\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return approvalCount;\\n    }\\n\\n    /**\\n     * @notice Returns if the owner has approved the diamond cut\\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\\n     * @return isApprovedByOwner Bool value showing if the owner approved the cut\\n     */\\n    function getOwnerCutApprovalWithTimeValidity(\\n        bytes32 _diamondCutHash\\n    ) public view override returns (bool isApprovedByOwner) {\\n        isApprovedByOwner = isCutApproved(_diamondCutHash, address(this));\\n    }\\n\\n    /**\\n     * @notice Returns if the given approver has approved the diamond cut\\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\\n     * @param _approver Address of approver\\n     * @return isApproved Bool value showing if the approver approved the cut\\n     */\\n    function isCutApproved(\\n        bytes32 _diamondCutHash,\\n        address _approver\\n    ) public view override returns (bool isApproved) {\\n        DiamondCutApprovalConfig storage ds = LibFacetStorage\\n            .diamondCutStorage()\\n            .diamondCutApprovalConfigs[INNER_STRUCT];\\n        isApproved = (ds\\n        .isDiamondCutApproved[_diamondCutHash][_approver].isApproved &&\\n            block.timestamp <\\n            ds.isDiamondCutApproved[_diamondCutHash][_approver].validUntil);\\n    }\\n\\n    /**\\n     * @notice Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval\\n     *         Approvers who approved on-chain should not be included in the off-chain approval\\n     * @param _diamondCutHash Hash of diamondCut information including the facet addresses and function selectors\\n     * @param _approvers List of approver addresses\\n     */\\n    function _checkDuplicateOnChainApprover(\\n        bytes32 _diamondCutHash,\\n        address[] memory _approvers\\n    ) public view {\\n        address[] memory guardians = LibGuardian.getGuardians();\\n        uint256 guardianLength = guardians.length;\\n        uint256 approversLength = _approvers.length;\\n        for (uint256 i; i < guardianLength; ) {\\n            if (isCutApproved(_diamondCutHash, guardians[i])) {\\n                for (uint256 j; j < approversLength; ) {\\n                    if (_approvers[j] == guardians[i])\\n                        revert DiamondCutFacet__DuplicateApproval();\\n                    unchecked {\\n                        ++j;\\n                    }\\n                }\\n            }\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the diamond cut hash. This function ensures that this hash is safe from replay attack by including\\n     *         salt, address, chainId, and nonce, etc.\\n     * @param _diamondCut Contains the facet addresses and function selectors\\n     * @return cutHash Diamond Cut Hash\\n     */\\n    function getDiamondCutHash(\\n        FacetCut[] calldata _diamondCut\\n    ) public view override returns (bytes32 cutHash) {\\n        cutHash = keccak256(\\n            abi.encodePacked(\\n                \\\"\\\\x19Ethereum Signed Message:\\\\n32\\\",\\n                keccak256(\\n                    abi.encode(\\n                        keccak256(abi.encode(_diamondCut)),\\n                        address(this),\\n                        block.chainid,\\n                        LibFacetStorage.diamondCutStorage().nonce\\n                    )\\n                )\\n            )\\n        );\\n    }\\n\\n    /**\\n     * @notice Returns the approval validation Period\\n     * @dev This method fetches the validation period from the security manager\\n     * @return approvalValidationPeriod Approval validation period of Barz contract fetched from security manager\\n     */\\n    function getApprovalValidationPeriod()\\n        internal\\n        view\\n        returns (uint256 approvalValidationPeriod)\\n    {\\n        approvalValidationPeriod = securityManager.approvalValidationPeriodOf(\\n            address(this)\\n        );\\n        if (approvalValidationPeriod <= 0)\\n            revert DiamondCutFacet__InvalidApprovalValidationPeriod();\\n    }\\n\\n    /**\\n     * @notice Returns the diamond cut nonce of this wallet\\n     * @dev This method fetches the nonce from diamond cut storage\\n     * @return cutNonce Nonce of diamond cut to protect from reply attacks\\n     */\\n    function getDiamondCutNonce()\\n        public\\n        view\\n        override\\n        returns (uint128 cutNonce)\\n    {\\n        cutNonce = LibFacetStorage.diamondCutStorage().nonce;\\n    }\\n}\\n\",\"keccak256\":\"0xe91a7dd2daabf2e989c94089f4f1eb0da94276c3070559ac8988838e10dd1f5d\",\"license\":\"Apache-2.0\"},\"contracts/facets/base/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title DiamondCut Facet Interface\\n * @dev Interface for DiamondCut Facet responsible for adding/removing/replace facets in Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IDiamondCut {\\n    error DiamondCutFacet__InvalidRouteWithGuardian();\\n    error DiamondCutFacet__InvalidRouteWithoutGuardian();\\n    error DiamondCutFacet__InvalidArrayLength();\\n    error DiamondCutFacet__InsufficientApprovers();\\n    error DiamondCutFacet__InvalidApprover();\\n    error DiamondCutFacet__InvalidApproverSignature();\\n    error DiamondCutFacet__InvalidApprovalValidationPeriod();\\n    error DiamondCutFacet__CannotRevokeUnapproved();\\n    error DiamondCutFacet__LackOfOwnerApproval();\\n    error DiamondCutFacet__OwnerAlreadyApproved();\\n    error DiamondCutFacet__DuplicateApproval();\\n    error DiamondCutFacet__InvalidInitAddress();\\n\\n    event DiamondCutApproved(FacetCut[] diamondCut);\\n    event DiamondCutApprovalRevoked(FacetCut[] diamondCut);\\n\\n    event SupportsInterfaceUpdated(bytes4 interfaceId, bool _lag);\\n\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param diamondCut Contains the facet addresses and function selectors\\n    /// @param init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    function updateSupportsInterface(bytes4 interfaceId, bool flag) external;\\n\\n    function diamondCutWithGuardian(\\n        FacetCut[] calldata diamondCut,\\n        address[] calldata approvers,\\n        bytes[] calldata signatures\\n    ) external;\\n\\n    function approveDiamondCut(FacetCut[] calldata diamondCut) external;\\n\\n    function revokeDiamondCutApproval(FacetCut[] calldata diamondCut) external;\\n\\n    function getDiamondCutApprovalCountWithTimeValidity(\\n        bytes32 diamondCutHash\\n    ) external view returns (uint256);\\n\\n    function getOwnerCutApprovalWithTimeValidity(\\n        bytes32 diamondCutHash\\n    ) external view returns (bool);\\n\\n    function isCutApproved(\\n        bytes32 diamondCutHash,\\n        address approver\\n    ) external view returns (bool);\\n\\n    function getDiamondCutHash(\\n        FacetCut[] calldata diamondCut\\n    ) external view returns (bytes32);\\n\\n    function getDiamondCutNonce() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0x8514213c7677c2122bda0721870b08decaddb68841cb1d6a87b89b04e8f43e1e\",\"license\":\"Apache-2.0\"},\"contracts/facets/base/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0xd84f7fbb1344f714bceab2c71e4a25a235e3c1457fe7eba6c5538cd95ef5fc0f\",\"license\":\"Apache-2.0\"},\"contracts/infrastructure/interfaces/IFacetRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title Facet Registry Interface\\n * @dev Interface for Facet Registry contract to keep track of facets & function selectors addable to user wallets\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IFacetRegistry {\\n    struct FacetRegistryConfig {\\n        bytes4[] selectors;\\n        mapping(bytes4 => FacetInfo) info;\\n    }\\n    struct FacetInfo {\\n        bool exists;\\n        uint128 index;\\n    }\\n\\n    event FacetFunctionSelectorsRegistered(\\n        address facet,\\n        bytes4[] facetSelectors\\n    );\\n    event FacetFunctionSelectorsRemoved(address facet, bytes4[] facetSelectors);\\n\\n    error FacetRegistry__FacetSelectorAlreadyRegistered();\\n    error FacetRegistry__UnregisteredFacetSelector();\\n\\n    function registerFacetFunctionSelectors(\\n        address facet,\\n        bytes4[] calldata facetSelectors\\n    ) external;\\n\\n    function removeFacetFunctionSelectors(\\n        address facet,\\n        bytes4[] calldata facetSelectors\\n    ) external;\\n\\n    function areFacetFunctionSelectorsRegistered(\\n        address facet,\\n        bytes4[] calldata facetSelectors\\n    ) external view returns (bool);\\n\\n    function isFacetFunctionSelectorRegistered(\\n        address facet,\\n        bytes4 facetSelector\\n    ) external view returns (bool);\\n\\n    function getFacetFunctionSelectors(\\n        address facet\\n    ) external view returns (bytes4[] memory);\\n}\\n\",\"keccak256\":\"0x6e6dd2cab346ef7c31230740ec48d2925e4a9ab24c2f2fb268baaf408dcf02ef\",\"license\":\"Apache-2.0\"},\"contracts/infrastructure/interfaces/ISecurityManager.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title Facet Registry Interface\\n * @dev Infrastructure contract to manage security parameters of users\\n * @author David Yongjun Kim (@Powerstream3604)\\n * @author Ruslan Serebriakov (@rsrbk)\\n */\\ninterface ISecurityManager {\\n    error SecurityManager__OutOfBoundary();\\n    error SecurityManager__CallerNotWallet();\\n    error SecurityManager__AlreadyIntialized();\\n\\n    function initializeAdditionSecurityPeriod(\\n        uint128 defaultAdditionSecurityPeriod,\\n        uint128 minAdditionSecurityPeriod,\\n        uint128 maxAdditionSecurityPeriod\\n    ) external;\\n\\n    function initializeRemovalSecurityPeriod(\\n        uint128 defaultRemovalSecurityPeriod,\\n        uint128 minRemovalSecurityPeriod,\\n        uint128 maxRemovalSecurityPeriod\\n    ) external;\\n\\n    function initializeApprovalValidationPeriod(\\n        uint128 defaultApprovalValidationPeriod,\\n        uint128 minApprovalValidationPeriod,\\n        uint128 maxApprovalValidationPeriod\\n    ) external;\\n\\n    function initializeMigrationPeriod(\\n        uint128 defaultMigrationPeriod,\\n        uint128 minMigrationPeriod,\\n        uint128 maxMigrationPeriod\\n    ) external;\\n\\n    function initializeLockPeriod(\\n        uint128 defaultLockPeriod,\\n        uint128 minLockPeriod,\\n        uint128 maxLockPeriod\\n    ) external;\\n\\n    function initializeRecoveryPeriod(\\n        uint128 defaultRecoveryPeriod,\\n        uint128 minRecoveryPeriod,\\n        uint128 maxRecoveryPeriod\\n    ) external;\\n\\n    function initializeSecurityWindow(\\n        uint128 defaultSecurityWindow,\\n        uint128 minSecurityWindow,\\n        uint128 maxSecurityWindow\\n    ) external;\\n\\n    function setAdditionSecurityPeriod(\\n        address wallet,\\n        uint128 additionSecurityPeriod\\n    ) external;\\n\\n    function setRemovalSecurityPeriod(\\n        address wallet,\\n        uint128 removalSecurityPeriod\\n    ) external;\\n\\n    function setSecurityWindow(address wallet, uint128 securityWindow) external;\\n\\n    function setRecoveryPeriod(address wallet, uint128 recoveryPeriod) external;\\n\\n    function setLockPeriod(address wallet, uint128 lockPeriod) external;\\n\\n    function setApprovalValidationPeriod(\\n        address wallet,\\n        uint128 approvalValidationPeriod\\n    ) external;\\n\\n    function setMigrationPeriod(\\n        address wallet,\\n        uint128 migrationPeriod\\n    ) external;\\n\\n    function additionSecurityPeriodOf(\\n        address wallet\\n    ) external view returns (uint128);\\n\\n    function removalSecurityPeriodOf(\\n        address wallet\\n    ) external view returns (uint128);\\n\\n    function securityWindowOf(address wallet) external view returns (uint128);\\n\\n    function recoveryPeriodOf(address wallet) external view returns (uint128);\\n\\n    function lockPeriodOf(address wallet) external view returns (uint128);\\n\\n    function migrationPeriodOf(address wallet) external view returns (uint128);\\n\\n    function approvalValidationPeriodOf(\\n        address wallet\\n    ) external view returns (uint128);\\n}\\n\",\"keccak256\":\"0x9ac6566033ef81ba5744c8ed2b08f130b781b498ab9245bcca87567669549552\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibAppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {SafeCast} from \\\"@openzeppelin/contracts/utils/math/SafeCast.sol\\\";\\nimport {IEntryPoint} from \\\"../aa-4337/interfaces/IEntryPoint.sol\\\";\\nimport {IFacetRegistry} from \\\"../infrastructure/interfaces/IFacetRegistry.sol\\\";\\n\\n/*\\n * @title App Storage\\n * @dev App storage for Barz contract to prevent storage collision\\n * @author David Yongjun Kim (@Powerstream3604)\\n * @author Ruslan Serebriakov (@rsrbk)\\n */\\n\\nstruct Lock {\\n    uint64 release;\\n    bytes4 locker;\\n}\\n\\nstruct InitializersStorage {\\n    // NOTE: initialized is a variable to make sure the initialization is only done once.\\n    uint8 signerInitialized;\\n    uint8 accountInitialized;\\n    uint8 restrictionsInitialized;\\n}\\n\\nstruct AppStorage {\\n    mapping(uint256 => InitializersStorage) initStorage;\\n    uint8 signerMigration;\\n    bytes4 validateOwnerSignatureSelector;\\n    IEntryPoint entryPoint;\\n    IFacetRegistry facetRegistry;\\n    mapping(uint256 => Lock) locks;\\n}\\n\\nlibrary LibAppStorage {\\n    error LibAppStorage__AccountAlreadyUninitialized();\\n    error LibAppStorage__AccountMustBeUninitialized();\\n    error LibAppStorage__SignerAlreadyUninitialized();\\n    error LibAppStorage__SignerMustBeUninitialized();\\n\\n    function appStorage() internal pure returns (AppStorage storage ds) {\\n        assembly {\\n            ds.slot := 0\\n        }\\n    }\\n\\n    function setSignerUninitialized() internal {\\n        AppStorage storage s = appStorage();\\n        if (1 != s.initStorage[0].signerInitialized) {\\n            revert LibAppStorage__SignerAlreadyUninitialized();\\n        }\\n        s.initStorage[0].signerInitialized = 0;\\n    }\\n\\n    function getValidateOwnerSignatureSelector()\\n        internal\\n        view\\n        returns (bytes4 selector)\\n    {\\n        selector = appStorage().validateOwnerSignatureSelector;\\n    }\\n\\n    function setValidateOwnerSignatureSelector(\\n        bytes4 _validateOwnerSignatureSelector\\n    ) internal {\\n        appStorage()\\n            .validateOwnerSignatureSelector = _validateOwnerSignatureSelector;\\n    }\\n\\n    function enforceSignerInitialize() internal {\\n        AppStorage storage s = appStorage();\\n        if (0 != s.initStorage[0].signerInitialized) {\\n            revert LibAppStorage__SignerMustBeUninitialized();\\n        }\\n        s.initStorage[0].signerInitialized = 1;\\n    }\\n\\n    function enforceAccountInitialize() internal {\\n        AppStorage storage s = appStorage();\\n        if (0 != s.initStorage[0].accountInitialized) {\\n            revert LibAppStorage__AccountMustBeUninitialized();\\n        }\\n        s.initStorage[0].accountInitialized = 1;\\n    }\\n\\n    function initiateSignerMigration() internal {\\n        appStorage().signerMigration = 1;\\n    }\\n\\n    function enforceSignerMigration() internal view {\\n        if (1 != appStorage().signerMigration) {\\n            revert LibAppStorage__AccountMustBeUninitialized();\\n        }\\n    }\\n\\n    function finalizeSignerMigration() internal {\\n        appStorage().signerMigration = 0;\\n    }\\n\\n    function setLock(uint256 _releaseAfter, bytes4 _locker) internal {\\n        appStorage().locks[0] = Lock(SafeCast.toUint64(_releaseAfter), _locker);\\n    }\\n\\n    function enforceRestrictionsInitialize() internal {\\n        AppStorage storage s = appStorage();\\n        if (0 != s.initStorage[0].restrictionsInitialized)\\n            revert LibAppStorage__SignerMustBeUninitialized();\\n        s.initStorage[0].restrictionsInitialized = 1;\\n    }\\n\\n    function setRestrictionsUninitialized() internal {\\n        AppStorage storage s = appStorage();\\n        if (1 != s.initStorage[0].restrictionsInitialized)\\n            revert LibAppStorage__AccountAlreadyUninitialized();\\n        s.initStorage[0].restrictionsInitialized = 0;\\n    }\\n}\\n\\ncontract BarzStorage {\\n    AppStorage internal s;\\n    modifier onlyWhenUnlocked() {\\n        require(\\n            uint64(block.timestamp) >= s.locks[0].release,\\n            \\\"Account Locked\\\"\\n        );\\n        _;\\n    }\\n    modifier onlyWhenLocked() {\\n        require(\\n            uint64(block.timestamp) < s.locks[0].release,\\n            \\\"Account Unlocked\\\"\\n        );\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x48524007862a6ce0e07f645950613ce6513ce073c37a109c75019683d42bae27\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {IDiamondCut} from \\\"../facets/base/interfaces/IDiamondCut.sol\\\";\\nimport {IDiamondLoupe} from \\\"../facets/base/interfaces/IDiamondLoupe.sol\\\";\\n\\nerror InitializationFunctionReverted(\\n    address _initializationContractAddress,\\n    bytes _calldata\\n);\\n\\nlibrary LibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"trustwallet.barz.diamond.storage\\\");\\n    bytes4 constant RESTRICTIONS_FACET_SELECTOR =\\n        bytes4(keccak256(\\\"verifyRestrictions(address,address,uint256,bytes)\\\"));\\n    struct DiamondStorage {\\n        // maps function selectors to the facets that execute the functions.\\n        // and maps the selectors to their position in the selectorSlots array.\\n        // func selector => address facet, selector position\\n        mapping(bytes4 => bytes32) facets;\\n        // array of slots of function selectors.\\n        // each slot holds 8 function selectors.\\n        mapping(uint256 => bytes32) selectorSlots;\\n        // The number of function selectors in selectorSlots\\n        uint16 selectorCount;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n        // Default Fallback Handler of the barz.\\n        IDiamondLoupe defaultFallbackHandler;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function enforceIsSelf() internal view {\\n        require(msg.sender == address(this), \\\"LibDiamond: Caller not self\\\");\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK =\\n        bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        DiamondStorage storage ds = diamondStorage();\\n        uint256 originalSelectorCount = ds.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = ds.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            ds.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            ds.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _selectors.length > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(\\n                _newFacetAddress,\\n                \\\"LibDiamondCut: Add facet has no code\\\"\\n            );\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"LibDiamondCut: Can't add function that already exists\\\"\\n                );\\n                // add facet for selector\\n                ds.facets[selector] =\\n                    bytes20(_newFacetAddress) |\\n                    bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot =\\n                    (_selectorSlot &\\n                        ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    ds.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(\\n                _newFacetAddress,\\n                \\\"LibDiamondCut: Replace facet has no code\\\"\\n            );\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = ds.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(\\n                    oldFacetAddress != address(this),\\n                    \\\"LibDiamondCut: Can't replace immutable function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"LibDiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(\\n                    oldFacetAddress != address(0),\\n                    \\\"LibDiamondCut: Can't replace function that doesn't exist\\\"\\n                );\\n                // replace old facet address\\n                ds.facets[selector] =\\n                    (oldFacet & CLEAR_ADDRESS_MASK) |\\n                    bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(\\n                _newFacetAddress == address(0),\\n                \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n            );\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = ds.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = ds.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"LibDiamondCut: Can't remove immutable function\\\"\\n                    );\\n                    // replace selector with last selector in ds.facets\\n                    // gets the last selector\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    lastSelector = bytes4(\\n                        _selectorSlot << (selectorInSlotIndex << 5)\\n                    );\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        ds.facets[lastSelector] =\\n                            (oldFacet & CLEAR_ADDRESS_MASK) |\\n                            bytes20(ds.facets[lastSelector]);\\n                    }\\n                    delete ds.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = ds.selectorSlots[\\n                        oldSelectorsSlotCount\\n                    ];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    ds.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot &\\n                            ~(CLEAR_SELECTOR_MASK >>\\n                                oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete ds.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(\\n            _init,\\n            \\\"LibDiamondCut: _init address has no code\\\"\\n        );\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n\\n    function restrictionsFacet() internal view returns (address facetAddress_) {\\n        facetAddress_ = address(\\n            bytes20(\\n                LibDiamond.diamondStorage().facets[RESTRICTIONS_FACET_SELECTOR]\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x2cabdc00de859c3a3170ce3bda5d0e5fd3933d47ce904fd1585f9818b02572f8\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibFacetStorage.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title Facet Storage\\n * @dev Storage contract to store each facets variables with diamond storage\\n * @author David Yongjun Kim (@Powerstream3604)\\n * @author Ruslan Serebriakov (@rsrbk)\\n */\\n\\nstruct Secp256k1VerificationStorage {\\n    address signer;\\n}\\n\\nstruct Secp256r1VerificationStorage {\\n    uint256[2] q;\\n}\\n\\nstruct GuardianStorage {\\n    mapping(bytes32 => uint256) pending;\\n    mapping(uint8 => StorageConfig) configs;\\n}\\n\\nstruct Info {\\n    bool exists;\\n    uint128 index;\\n}\\n\\nstruct StorageConfig {\\n    address[] addresses;\\n    mapping(address => Info) info;\\n}\\n\\nstruct RecoveryConfig {\\n    bytes recoveryPublicKey;\\n    uint64 executeAfter;\\n}\\n\\nstruct ApprovalConfig {\\n    bool isApproved;\\n    uint64 validUntil;\\n}\\n\\nstruct RecoveryApprovalConfig {\\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isNewOwnerApproved;\\n}\\n\\nstruct RecoveryStorage {\\n    mapping(uint8 => RecoveryConfig) recoveryConfigs;\\n    mapping(uint8 => RecoveryApprovalConfig) recoveryApprovalConfigs;\\n    uint128 nonce;\\n}\\n\\nstruct RestrictionsStorage {\\n    address[] restrictions;\\n    mapping(address => bool) exists;\\n}\\n\\nstruct SignatureMigrationConfig {\\n    bytes migrationPublicKey;\\n    address migrationVerificationFacet;\\n    bytes4[] migrationSelectors;\\n    uint64 migrateAfter;\\n}\\n\\nstruct SignatureMigrationApprovalConfig {\\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isMigrationApproved;\\n}\\n\\nstruct SignatureMigrationStorage {\\n    mapping(uint8 => SignatureMigrationConfig) migrationConfigs;\\n    mapping(uint8 => SignatureMigrationApprovalConfig) migrationApprovalConfigs;\\n    uint128 nonce;\\n}\\n\\nstruct DiamondCutApprovalConfig {\\n    mapping(bytes32 => mapping(address => ApprovalConfig)) isDiamondCutApproved;\\n}\\n\\nstruct DiamondCutStorage {\\n    mapping(uint8 => DiamondCutApprovalConfig) diamondCutApprovalConfigs;\\n    uint128 nonce;\\n}\\n\\nstruct LockStorage {\\n    uint128 nonce;\\n}\\n\\nlibrary LibFacetStorage {\\n    bytes32 constant K1_STORAGE_POSITION =\\n        keccak256(\\n            \\\"v0.trustwallet.diamond.storage.Secp256k1VerificationStorage\\\"\\n        );\\n    bytes32 constant R1_STORAGE_POSITION =\\n        keccak256(\\n            \\\"v0.trustwallet.diamond.storage.Secp256r1VerificationStorage\\\"\\n        );\\n    bytes32 constant GUARDIAN_STORAGE_POSITION =\\n        keccak256(\\\"v0.trustwallet.diamond.storage.GuardianStorage\\\");\\n    bytes32 constant RECOVERY_STORAGE_POSITION =\\n        keccak256(\\\"v0.trustwallet.diamond.storage.RecoveryStorage\\\");\\n    bytes32 constant RESTRICTION_STORAGE_POSITION =\\n        keccak256(\\\"v0.trustwallet.diamond.storage.RestrictionsStorage\\\");\\n    bytes32 constant MIGRATION_STORAGE_POSITION =\\n        keccak256(\\\"v0.trustwallet.diamond.storage.SignatureMigrationStorage\\\");\\n    bytes32 constant DIAMONDCUT_STORAGE_POSITION =\\n        keccak256(\\\"v0.trustwallet.diamond.storage.DiamondCutStorage\\\");\\n    bytes32 constant LOCK_STORAGE_POSITION =\\n        keccak256(\\\"v0.trustwallet.diamond.storage.LockStorage\\\");\\n\\n    function k1Storage()\\n        internal\\n        pure\\n        returns (Secp256k1VerificationStorage storage ds)\\n    {\\n        bytes32 storagePosition = K1_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function r1Storage()\\n        internal\\n        pure\\n        returns (Secp256r1VerificationStorage storage ds)\\n    {\\n        bytes32 storagePosition = R1_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function guardianStorage()\\n        internal\\n        pure\\n        returns (GuardianStorage storage ds)\\n    {\\n        bytes32 storagePosition = GUARDIAN_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function recoveryStorage()\\n        internal\\n        pure\\n        returns (RecoveryStorage storage ds)\\n    {\\n        bytes32 storagePosition = RECOVERY_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function restrictionsStorage()\\n        internal\\n        pure\\n        returns (RestrictionsStorage storage ds)\\n    {\\n        bytes32 storagePosition = RESTRICTION_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function migrationStorage()\\n        internal\\n        pure\\n        returns (SignatureMigrationStorage storage ds)\\n    {\\n        bytes32 storagePosition = MIGRATION_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function diamondCutStorage()\\n        internal\\n        pure\\n        returns (DiamondCutStorage storage ds)\\n    {\\n        bytes32 storagePosition = DIAMONDCUT_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n\\n    function lockStorage() internal pure returns (LockStorage storage ds) {\\n        bytes32 storagePosition = LOCK_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := storagePosition\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x87c85decfd943deda9540733e464cb1a92eba735a301e89ce6f798016e359761\",\"license\":\"Apache-2.0\"},\"contracts/libraries/LibGuardian.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {LibFacetStorage, StorageConfig} from \\\"./LibFacetStorage.sol\\\";\\n\\n/**\\n * @title LibGuardian\\n * @dev Internal Library to provide utility feature for Guardians stored in Guardian Facet Storage\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\nlibrary LibGuardian {\\n    function majorityOfGuardians()\\n        internal\\n        view\\n        returns (uint256 guardianNumber)\\n    {\\n        uint256 guardianLength = guardianCount();\\n        guardianNumber = (guardianLength == 0) ? 0 : guardianLength / 2 + 1;\\n    }\\n\\n    function isGuardian(address _guardian) internal view returns (bool) {\\n        StorageConfig storage config = LibFacetStorage\\n            .guardianStorage()\\n            .configs[0];\\n        return config.info[_guardian].exists;\\n    }\\n\\n    function guardianCount() internal view returns (uint256) {\\n        StorageConfig storage config = LibFacetStorage\\n            .guardianStorage()\\n            .configs[0];\\n        return config.addresses.length;\\n    }\\n\\n    function getGuardians() internal view returns (address[] memory) {\\n        StorageConfig storage config = LibFacetStorage\\n            .guardianStorage()\\n            .configs[0];\\n        address[] memory addresses = new address[](config.addresses.length);\\n        uint256 addressesLen = config.addresses.length;\\n        for (uint256 i; i < addressesLen; ) {\\n            addresses[i] = config.addresses[i];\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n        return addresses;\\n    }\\n}\\n\",\"keccak256\":\"0x6a620992d5535878fc03d1a27a6675f4c1509adfb3ddbbca1c52b546c25392dc\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b506040516200379b3803806200379b833981016040819052620000349162000046565b6001600160a01b031660805262000078565b6000602082840312156200005957600080fd5b81516001600160a01b03811681146200007157600080fd5b9392505050565b6080516137006200009b600039600081816101f10152611b2501526137006000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c806379c0d58d11610081578063afb877bb1161005b578063afb877bb146101d9578063de675a6d146101ec578063e33ecf0a1461023857600080fd5b806379c0d58d14610192578063836d6bfb146101b35780638824a0bb146101c657600080fd5b806326fc3ef4116100b257806326fc3ef4146101145780632f4d98ea1461015c5780633c0985681461017f57600080fd5b806313c34f4b146100d95780631c776dd5146100ee5780631f931c1c14610101575b600080fd5b6100ec6100e7366004612a97565b61024b565b005b6100ec6100fc366004612ad9565b6104df565b6100ec61010f366004612b9c565b610a76565b7f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9bf546040516fffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61016f61016a366004612c4a565b610c7b565b6040519015158152602001610153565b6100ec61018d366004612ca4565b610c8d565b6101a56101a0366004612c4a565b610df2565b604051908152602001610153565b61016f6101c1366004612cdb565b610e4c565b6100ec6101d4366004612dd2565b610eed565b6100ec6101e7366004612a97565b610fe1565b6102137f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610153565b6101a5610246366004612a97565b61130e565b3360009081527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b8602052604090205460ff1615801561028a5750303314155b156102c1576040517f6238ee3400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610369576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b656400000000000000000000000000000000000060448201526064015b60405180910390fd5b60008080527f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be6020527f653b0501de88979dae3f7a0c0d7d06b6188ed90f72b20793f210fd368861e5d3906103be848461130e565b60008181526020848152604080832033845290915290205490915060ff16610412576040517fedc5708300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60408051808201825260008082526020808301828152858352868252848320338452909152908390209151825491517fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000009092169015157fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000ff161761010067ffffffffffffffff90921691909102179055517f3c3d8c1f0b0faff6fe0ace6b485d0595a0106dce9e303f956fd941ebdbe9a98e906104d19086908690612f54565b60405180910390a150505050565b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610582576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b8281146105bb576040517fe854148500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105cd6105c886886130aa565b611435565b600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b754600003610650576040517fa788861700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061065c878761130e565b905061069a8585808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506115b392505050565b506106d881868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250610eed92505050565b60006106e382610c7b565b90506000816106f35760016106f6565b60005b60ff169050806107046116d0565b61070e9190613201565b61071784610df2565b6107219088613201565b1015610759576040517f709fb08000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000805b878110156109a0576107d989898381811061077a5761077a613214565b905060200201602081019061078f9190613243565b73ffffffffffffffffffffffffffffffffffffffff1660009081527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b8602052604090205460ff1690565b1580156108225750308989838181106107f4576107f4613214565b90506020020160208101906108099190613243565b73ffffffffffffffffffffffffffffffffffffffff1614155b15610859576040517f7b2cbbb400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3089898381811061086c5761086c613214565b90506020020160208101906108819190613243565b73ffffffffffffffffffffffffffffffffffffffff16036108d95783156108d4576040517fee21708000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600191505b6109628989838181106108ee576108ee613214565b90506020020160208101906109039190613243565b8689898581811061091657610916613214565b90506020028101906109289190613265565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061174f92505050565b610998576040517fac3d341600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60010161075d565b50801580156109ad575082155b156109e4576040517f6d21730400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9bf80546fffffffffffffffffffffffffffffffff808216600101167fffffffffffffffffffffffffffffffff00000000000000000000000000000000909116179055610a6a610a538a8c6130aa565b6000604051806020016040528060008152506117ca565b50505050505050505050565b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610b19576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b610b2161195f565b610b2e6105c885876130aa565b600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b75415610baf576040517fa788861700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff831615610bfd576040517f871cb76100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be5b600190810180547fffffffffffffffffffffffffffffffff0000000000000000000000000000000081166fffffffffffffffffffffffffffffffff91821690930116919091179055610c74610a5385876130aa565b5050505050565b6000610c878230610e4c565b92915050565b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610d30576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b610d3861195f565b7fffffffff00000000000000000000000000000000000000000000000000000000821660008181527f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4922602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001685151590811790915582519384529083015280517f4e6bd17989efa6d6a9607ccaac1bba27b29f99622bc830d99a3a9883b21a19c79281900390910190a15050565b600080610dfd6119ca565b805190915060005b81811015610e4457610e3085848381518110610e2357610e23613214565b6020026020010151610e4c565b15610e3c578360010193505b600101610e05565b505050919050565b60008281527f653b0501de88979dae3f7a0c0d7d06b6188ed90f72b20793f210fd368861e5d36020818152604080842073ffffffffffffffffffffffffffffffffffffffff8616855290915282205460ff168015610ee5575060008481526020828152604080832073ffffffffffffffffffffffffffffffffffffffff87168452909152902054610100900467ffffffffffffffff1642105b949350505050565b6000610ef76119ca565b805183519192509060005b82811015610fd957610f2086858381518110610e2357610e23613214565b15610fd15760005b82811015610fcf57848281518110610f4257610f42613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff16868281518110610f7257610f72613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1603610fc7576040517f50f5729f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600101610f28565b505b600101610f02565b505050505050565b3360009081527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b8602052604090205460ff161580156110205750303314155b15611057576040517f6238ee3400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff9081164290911610156110fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b75460000361117d576040517f3a76e1f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080527f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be6020527f653b0501de88979dae3f7a0c0d7d06b6188ed90f72b20793f210fd368861e5d36111d36105c883856130aa565b60006111df848461130e565b905060006111eb611af4565b6111f59042613201565b6040805180820182526001815267ffffffffffffffff838116602080840191825260008881528982528581203382529091528490209251835491517fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000009092169015157fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000ff16176101009190921602179055519091507f6248ff757895beed7d43d135bccf59a26b7fbdf0fe8233487c44e82c0f266ba3906112b89087908790612f54565b60405180910390a16112c86116d0565b6112d183610df2565b101580156112e357506112e382610c7b565b15610c74577f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be610c1f565b60008282604051602001611323929190612f54565b6040516020818303038152906040528051906020012030466113627f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be90565b6001015460408051602081019590955273ffffffffffffffffffffffffffffffffffffffff9093169284019290925260608301526fffffffffffffffffffffffffffffffff16608082015260a001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000091830191909152603c820152605c0160405160208183030381529060405280519060200120905092915050565b805160005b818110156115ae57600083828151811061145657611456613214565b602002602001015160200151600281111561147357611473612e8a565b14806114ad5750600183828151811061148e5761148e613214565b60200260200101516020015160028111156114ab576114ab612e8a565b145b156115a657600254835173ffffffffffffffffffffffffffffffffffffffff9091169063df871f72908590849081106114e8576114e8613214565b60200260200101516000015185848151811061150657611506613214565b6020026020010151604001516040518363ffffffff1660e01b815260040161152f92919061331c565b602060405180830381865afa15801561154c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611570919061334b565b6115a6576040517ff41a931c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60010161143a565b505050565b80516000908082036115f1576040517f3aee2eec00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b6115ff600183613368565b8110156116c6576000611613826001613201565b90505b828110156116bd5784818151811061163057611630613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1685838151811061166057611660613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff16036116b5576040517f8dd19e7d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600101611616565b506001016115f4565b5060009392505050565b600080611723600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b75490565b905080156117465761173660028261337b565b611741906001613201565b611749565b60005b91505090565b600080600061175e8585611bf6565b9092509050600081600481111561177757611777612e8a565b1480156117af57508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b806117c057506117c0868686611c3b565b9695505050505050565b7f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4921547f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f9061ffff8116908190600090600716156118395750600381901c60009081526001840160205260409020545b60005b87518110156118b6576118a983838a848151811061185c5761185c613214565b6020026020010151600001518b858151811061187a5761187a613214565b6020026020010151602001518c868151811061189857611898613214565b602002602001015160400151611d98565b909350915060010161183c565b508282146118ef576002840180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00001661ffff84161790555b600782161561191157600382901c600090815260018501602052604090208190555b7f8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb67387878760405161194493929190613424565b60405180910390a16119568686612829565b50505050505050565b3330146119c8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4c69624469616d6f6e643a2043616c6c6572206e6f742073656c6600000000006044820152606401610360565b565b60008080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b780546060929067ffffffffffffffff811115611a3257611a32612d07565b604051908082528060200260200182016040528015611a5b578160200160208202803683370190505b50825490915060005b81811015611aeb57836000018181548110611a8157611a81613214565b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16838281518110611abe57611abe613214565b73ffffffffffffffffffffffffffffffffffffffff90921660209283029190910190910152600101611a64565b50909392505050565b6040517f52430c8d0000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906352430c8d90602401602060405180830381865afa158015611b81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ba59190613510565b6fffffffffffffffffffffffffffffffff16905060008111611bf3576040517fdac5ec8b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b90565b6000808251604103611c2c5760208301516040840151606085015160001a611c2087828585612928565b94509450505050611c34565b506000905060025b9250929050565b60008060008573ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8686604051602401611c72929190613542565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051611cfb919061355b565b600060405180830381855afa9150503d8060008114611d36576040519150601f19603f3d011682016040523d82523d6000602084013e611d3b565b606091505b5091509150818015611d4f57506020815110155b80156117c0575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090611d8d9083016020908101908401613577565b149695505050505050565b600080807f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f90506000845111611e50576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610360565b6000856002811115611e6457611e64612e8a565b0361203457611e8b8660405180606001604052806024815260200161365760249139612a17565b60005b845181101561202e576000858281518110611eab57611eab613214565b6020908102919091018101517fffffffff000000000000000000000000000000000000000000000000000000008116600090815291859052604090912054909150606081901c15611f7e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774206164642066756e6374696f60448201527f6e207468617420616c72656164792065786973747300000000000000000000006064820152608401610360565b7fffffffff0000000000000000000000000000000000000000000000000000000080831660008181526020879052604090207fffffffffffffffffffffffffffffffffffffffff00000000000000000000000060608d901b168e17905560e060058e901b811692831c199c909c1690821c179a8190036120125760038c901c600090815260018601602052604081209b909b555b8b61201c81613590565b9c505060019093019250611e8e915050565b5061281d565b600185600281111561204857612048612e8a565b036123385761206f866040518060600160405280602881526020016136a360289139612a17565b60005b845181101561202e57600085828151811061208f5761208f613214565b6020908102919091018101517fffffffff000000000000000000000000000000000000000000000000000000008116600090815291859052604090912054909150606081901c308103612164576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4c69624469616d6f6e644375743a2043616e2774207265706c61636520696d6d60448201527f757461626c652066756e6374696f6e00000000000000000000000000000000006064820152608401610360565b8973ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361221f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e20776974682073616d652066756e6374696f6e00000000000000006064820152608401610360565b73ffffffffffffffffffffffffffffffffffffffff81166122c2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e207468617420646f65736e277420657869737400000000000000006064820152608401610360565b507fffffffff0000000000000000000000000000000000000000000000000000000090911660009081526020849052604090206bffffffffffffffffffffffff919091167fffffffffffffffffffffffffffffffffffffffff00000000000000000000000060608a901b16179055600101612072565b600285600281111561234c5761234c612e8a565b036127955773ffffffffffffffffffffffffffffffffffffffff8616156123f5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f4c69624469616d6f6e644375743a2052656d6f7665206661636574206164647260448201527f657373206d7573742062652061646472657373283029000000000000000000006064820152608401610360565b600388901c6007891660005b86518110156127755760008a900361243d578261241d816135c8565b60008181526001870160205260409020549b5093506007925061244b9050565b81612447816135c8565b9250505b6000806000808a858151811061246357612463613214565b6020908102919091018101517fffffffff0000000000000000000000000000000000000000000000000000000081166000908152918a9052604090912054909150606081901c612535576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603760248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f76652066756e6360448201527f74696f6e207468617420646f65736e27742065786973740000000000000000006064820152608401610360565b30606082901c036125c8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f766520696d6d7560448201527f7461626c652066756e6374696f6e0000000000000000000000000000000000006064820152608401610360565b600587901b8f901b94507fffffffff0000000000000000000000000000000000000000000000000000000080861690831614612666577fffffffff000000000000000000000000000000000000000000000000000000008516600090815260208a90526040902080547fffffffffffffffffffffffffffffffffffffffff000000000000000000000000166bffffffffffffffffffffffff83161790555b7fffffffff0000000000000000000000000000000000000000000000000000000091909116600090815260208990526040812055600381901c611fff16925060051b60e01690508582146126fb576000828152600188016020526040902080547fffffffff0000000000000000000000000000000000000000000000000000000080841c19909116908516831c17905561274c565b80837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c817fffffffff0000000000000000000000000000000000000000000000000000000060001b901c198e16179c505b8460000361276a57600086815260018801602052604081208190559c505b505050600101612401565b50806127828360086135fd565b61278c9190613201565b9950505061281d565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f4c69624469616d6f6e644375743a20496e636f7272656374204661636574437560448201527f74416374696f6e000000000000000000000000000000000000000000000000006064820152608401610360565b50959694955050505050565b73ffffffffffffffffffffffffffffffffffffffff8216612848575050565b61286a8260405180606001604052806028815260200161367b60289139612a17565b6000808373ffffffffffffffffffffffffffffffffffffffff1683604051612892919061355b565b600060405180830381855af49150503d80600081146128cd576040519150601f19603f3d011682016040523d82523d6000602084013e6128d2565b606091505b509150915081612922578051156128ec5780518082602001fd5b83836040517f192105d7000000000000000000000000000000000000000000000000000000008152600401610360929190613614565b50505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561295f5750600090506003612a0e565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156129b3573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116612a0757600060019250925050612a0e565b9150600090505b94509492505050565b813b8181612922576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103609190613643565b60008083601f840112612a6457600080fd5b50813567ffffffffffffffff811115612a7c57600080fd5b6020830191508360208260051b8501011115611c3457600080fd5b60008060208385031215612aaa57600080fd5b823567ffffffffffffffff811115612ac157600080fd5b612acd85828601612a52565b90969095509350505050565b60008060008060008060608789031215612af257600080fd5b863567ffffffffffffffff80821115612b0a57600080fd5b612b168a838b01612a52565b90985096506020890135915080821115612b2f57600080fd5b612b3b8a838b01612a52565b90965094506040890135915080821115612b5457600080fd5b50612b6189828a01612a52565b979a9699509497509295939492505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114612b9757600080fd5b919050565b600080600080600060608688031215612bb457600080fd5b853567ffffffffffffffff80821115612bcc57600080fd5b612bd889838a01612a52565b9097509550859150612bec60208901612b73565b94506040880135915080821115612c0257600080fd5b818801915088601f830112612c1657600080fd5b813581811115612c2557600080fd5b896020828501011115612c3757600080fd5b9699959850939650602001949392505050565b600060208284031215612c5c57600080fd5b5035919050565b80357fffffffff0000000000000000000000000000000000000000000000000000000081168114612b9757600080fd5b8015158114612ca157600080fd5b50565b60008060408385031215612cb757600080fd5b612cc083612c63565b91506020830135612cd081612c93565b809150509250929050565b60008060408385031215612cee57600080fd5b82359150612cfe60208401612b73565b90509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715612d5957612d59612d07565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715612da657612da6612d07565b604052919050565b600067ffffffffffffffff821115612dc857612dc8612d07565b5060051b60200190565b60008060408385031215612de557600080fd5b8235915060208084013567ffffffffffffffff811115612e0457600080fd5b8401601f81018613612e1557600080fd5b8035612e28612e2382612dae565b612d5f565b81815260059190911b82018301908381019088831115612e4757600080fd5b928401925b82841015612e6c57612e5d84612b73565b82529284019290840190612e4c565b80955050505050509250929050565b803560038110612b9757600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60038110612ef0577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9052565b8183526000602080850194508260005b85811015612f49577fffffffff00000000000000000000000000000000000000000000000000000000612f3683612c63565b1687529582019590820190600101612f04565b509495945050505050565b60208082528181018390526000906040808401600586811b8601830188865b8981101561309b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089840301855281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18c3603018112612fd457600080fd5b8b01606073ffffffffffffffffffffffffffffffffffffffff612ff683612b73565b168552613004898301612e7b565b6130108a870182612eb9565b50878201357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe183360301811261304557600080fd5b90910188810191903567ffffffffffffffff81111561306357600080fd5b80871b360383131561307457600080fd5b81898701526130868287018285612ef4565b978a0197955050509187019150600101612f73565b50909998505050505050505050565b60006130b8612e2384612dae565b83815260208082019190600586811b8601368111156130d657600080fd5b865b818110156131c557803567ffffffffffffffff808211156130f95760008081fd5b818a0191506060823603121561310f5760008081fd5b613117612d36565b61312083612b73565b815261312d878401612e7b565b87820152604080840135838111156131455760008081fd5b939093019236601f85011261315c57600092508283fd5b8335925061316c612e2384612dae565b83815292871b840188019288810190368511156131895760008081fd5b948901945b848610156131ae5761319f86612c63565b8252948901949089019061318e565b9183019190915250885250509483019483016130d8565b5092979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610c8757610c876131d2565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561325557600080fd5b61325e82612b73565b9392505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261329a57600080fd5b83018035915067ffffffffffffffff8211156132b557600080fd5b602001915036819003821315611c3457600080fd5b600081518084526020808501945080840160005b83811015612f495781517fffffffff0000000000000000000000000000000000000000000000000000000016875295820195908201906001016132de565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000610ee560408301846132ca565b60006020828403121561335d57600080fd5b815161325e81612c93565b81810381811115610c8757610c876131d2565b6000826133b1577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60005b838110156133d15781810151838201526020016133b9565b50506000910152565b600081518084526133f28160208601602086016133b6565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000606080830181845280875180835260808601915060808160051b87010192506020808a0160005b838110156134d4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80898703018552815173ffffffffffffffffffffffffffffffffffffffff8151168752838101516134a885890182612eb9565b506040908101519087018890526134c1878901826132ca565b965050938201939082019060010161344d565b505073ffffffffffffffffffffffffffffffffffffffff8916908701525050838103604085015261350581866133da565b979650505050505050565b60006020828403121561352257600080fd5b81516fffffffffffffffffffffffffffffffff8116811461325e57600080fd5b828152604060208201526000610ee560408301846133da565b6000825161356d8184602087016133b6565b9190910192915050565b60006020828403121561358957600080fd5b5051919050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036135c1576135c16131d2565b5060010190565b6000816135d7576135d76131d2565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b8082028115828204841417610c8757610c876131d2565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000610ee560408301846133da565b60208152600061325e60208301846133da56fe4c69624469616d6f6e644375743a2041646420666163657420686173206e6f20636f64654c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f64654c69624469616d6f6e644375743a205265706c61636520666163657420686173206e6f20636f6465a2646970667358221220c5a8c10b22f20cde3fe0431ff57305237423677a60888f5b349fc6751336ae1464736f6c63430008150033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100d45760003560e01c806379c0d58d11610081578063afb877bb1161005b578063afb877bb146101d9578063de675a6d146101ec578063e33ecf0a1461023857600080fd5b806379c0d58d14610192578063836d6bfb146101b35780638824a0bb146101c657600080fd5b806326fc3ef4116100b257806326fc3ef4146101145780632f4d98ea1461015c5780633c0985681461017f57600080fd5b806313c34f4b146100d95780631c776dd5146100ee5780631f931c1c14610101575b600080fd5b6100ec6100e7366004612a97565b61024b565b005b6100ec6100fc366004612ad9565b6104df565b6100ec61010f366004612b9c565b610a76565b7f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9bf546040516fffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61016f61016a366004612c4a565b610c7b565b6040519015158152602001610153565b6100ec61018d366004612ca4565b610c8d565b6101a56101a0366004612c4a565b610df2565b604051908152602001610153565b61016f6101c1366004612cdb565b610e4c565b6100ec6101d4366004612dd2565b610eed565b6100ec6101e7366004612a97565b610fe1565b6102137f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610153565b6101a5610246366004612a97565b61130e565b3360009081527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b8602052604090205460ff1615801561028a5750303314155b156102c1576040517f6238ee3400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610369576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b656400000000000000000000000000000000000060448201526064015b60405180910390fd5b60008080527f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be6020527f653b0501de88979dae3f7a0c0d7d06b6188ed90f72b20793f210fd368861e5d3906103be848461130e565b60008181526020848152604080832033845290915290205490915060ff16610412576040517fedc5708300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60408051808201825260008082526020808301828152858352868252848320338452909152908390209151825491517fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000009092169015157fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000ff161761010067ffffffffffffffff90921691909102179055517f3c3d8c1f0b0faff6fe0ace6b485d0595a0106dce9e303f956fd941ebdbe9a98e906104d19086908690612f54565b60405180910390a150505050565b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610582576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b8281146105bb576040517fe854148500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6105cd6105c886886130aa565b611435565b600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b754600003610650576040517fa788861700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061065c878761130e565b905061069a8585808060200260200160405190810160405280939291908181526020018383602002808284376000920191909152506115b392505050565b506106d881868680806020026020016040519081016040528093929190818152602001838360200280828437600092019190915250610eed92505050565b60006106e382610c7b565b90506000816106f35760016106f6565b60005b60ff169050806107046116d0565b61070e9190613201565b61071784610df2565b6107219088613201565b1015610759576040517f709fb08000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000805b878110156109a0576107d989898381811061077a5761077a613214565b905060200201602081019061078f9190613243565b73ffffffffffffffffffffffffffffffffffffffff1660009081527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b8602052604090205460ff1690565b1580156108225750308989838181106107f4576107f4613214565b90506020020160208101906108099190613243565b73ffffffffffffffffffffffffffffffffffffffff1614155b15610859576040517f7b2cbbb400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3089898381811061086c5761086c613214565b90506020020160208101906108819190613243565b73ffffffffffffffffffffffffffffffffffffffff16036108d95783156108d4576040517fee21708000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600191505b6109628989838181106108ee576108ee613214565b90506020020160208101906109039190613243565b8689898581811061091657610916613214565b90506020028101906109289190613265565b8080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061174f92505050565b610998576040517fac3d341600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60010161075d565b50801580156109ad575082155b156109e4576040517f6d21730400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9bf80546fffffffffffffffffffffffffffffffff808216600101167fffffffffffffffffffffffffffffffff00000000000000000000000000000000909116179055610a6a610a538a8c6130aa565b6000604051806020016040528060008152506117ca565b50505050505050505050565b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610b19576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b610b2161195f565b610b2e6105c885876130aa565b600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b75415610baf576040517fa788861700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b73ffffffffffffffffffffffffffffffffffffffff831615610bfd576040517f871cb76100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be5b600190810180547fffffffffffffffffffffffffffffffff0000000000000000000000000000000081166fffffffffffffffffffffffffffffffff91821690930116919091179055610c74610a5385876130aa565b5050505050565b6000610c878230610e4c565b92915050565b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff908116429091161015610d30576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b610d3861195f565b7fffffffff00000000000000000000000000000000000000000000000000000000821660008181527f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4922602090815260409182902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001685151590811790915582519384529083015280517f4e6bd17989efa6d6a9607ccaac1bba27b29f99622bc830d99a3a9883b21a19c79281900390910190a15050565b600080610dfd6119ca565b805190915060005b81811015610e4457610e3085848381518110610e2357610e23613214565b6020026020010151610e4c565b15610e3c578360010193505b600101610e05565b505050919050565b60008281527f653b0501de88979dae3f7a0c0d7d06b6188ed90f72b20793f210fd368861e5d36020818152604080842073ffffffffffffffffffffffffffffffffffffffff8616855290915282205460ff168015610ee5575060008481526020828152604080832073ffffffffffffffffffffffffffffffffffffffff87168452909152902054610100900467ffffffffffffffff1642105b949350505050565b6000610ef76119ca565b805183519192509060005b82811015610fd957610f2086858381518110610e2357610e23613214565b15610fd15760005b82811015610fcf57848281518110610f4257610f42613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff16868281518110610f7257610f72613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1603610fc7576040517f50f5729f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600101610f28565b505b600101610f02565b505050505050565b3360009081527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b8602052604090205460ff161580156110205750303314155b15611057576040517f6238ee3400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000805260036020527f3617319a054d772f909f7c479a2cebe5066e836a939412e32403c99029b92eff5467ffffffffffffffff9081164290911610156110fa576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f4163636f756e74204c6f636b65640000000000000000000000000000000000006044820152606401610360565b600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b75460000361117d576040517f3a76e1f300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080527f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be6020527f653b0501de88979dae3f7a0c0d7d06b6188ed90f72b20793f210fd368861e5d36111d36105c883856130aa565b60006111df848461130e565b905060006111eb611af4565b6111f59042613201565b6040805180820182526001815267ffffffffffffffff838116602080840191825260008881528982528581203382529091528490209251835491517fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000009092169015157fffffffffffffffffffffffffffffffffffffffffffffff0000000000000000ff16176101009190921602179055519091507f6248ff757895beed7d43d135bccf59a26b7fbdf0fe8233487c44e82c0f266ba3906112b89087908790612f54565b60405180910390a16112c86116d0565b6112d183610df2565b101580156112e357506112e382610c7b565b15610c74577f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be610c1f565b60008282604051602001611323929190612f54565b6040516020818303038152906040528051906020012030466113627f19a78b668040d166f9eab1e050eacb85cec34faf6ccf7ddbc201b33f8bb1f9be90565b6001015460408051602081019590955273ffffffffffffffffffffffffffffffffffffffff9093169284019290925260608301526fffffffffffffffffffffffffffffffff16608082015260a001604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905280516020918201207f19457468657265756d205369676e6564204d6573736167653a0a33320000000091830191909152603c820152605c0160405160208183030381529060405280519060200120905092915050565b805160005b818110156115ae57600083828151811061145657611456613214565b602002602001015160200151600281111561147357611473612e8a565b14806114ad5750600183828151811061148e5761148e613214565b60200260200101516020015160028111156114ab576114ab612e8a565b145b156115a657600254835173ffffffffffffffffffffffffffffffffffffffff9091169063df871f72908590849081106114e8576114e8613214565b60200260200101516000015185848151811061150657611506613214565b6020026020010151604001516040518363ffffffff1660e01b815260040161152f92919061331c565b602060405180830381865afa15801561154c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611570919061334b565b6115a6576040517ff41a931c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60010161143a565b505050565b80516000908082036115f1576040517f3aee2eec00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b6115ff600183613368565b8110156116c6576000611613826001613201565b90505b828110156116bd5784818151811061163057611630613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff1685838151811061166057611660613214565b602002602001015173ffffffffffffffffffffffffffffffffffffffff16036116b5576040517f8dd19e7d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600101611616565b506001016115f4565b5060009392505050565b600080611723600080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b75490565b905080156117465761173660028261337b565b611741906001613201565b611749565b60005b91505090565b600080600061175e8585611bf6565b9092509050600081600481111561177757611777612e8a565b1480156117af57508573ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16145b806117c057506117c0868686611c3b565b9695505050505050565b7f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4921547f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f9061ffff8116908190600090600716156118395750600381901c60009081526001840160205260409020545b60005b87518110156118b6576118a983838a848151811061185c5761185c613214565b6020026020010151600001518b858151811061187a5761187a613214565b6020026020010151602001518c868151811061189857611898613214565b602002602001015160400151611d98565b909350915060010161183c565b508282146118ef576002840180547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00001661ffff84161790555b600782161561191157600382901c600090815260018501602052604090208190555b7f8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb67387878760405161194493929190613424565b60405180910390a16119568686612829565b50505050505050565b3330146119c8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601b60248201527f4c69624469616d6f6e643a2043616c6c6572206e6f742073656c6600000000006044820152606401610360565b565b60008080527fec37c9d3f62cbc43363a007dfdea31702a2aae2ada4d4d880588e00ded24d6086020527f9d17c72553b2484e633bd2ba080be8cdbe1716b54e87f338837ad775aee316b780546060929067ffffffffffffffff811115611a3257611a32612d07565b604051908082528060200260200182016040528015611a5b578160200160208202803683370190505b50825490915060005b81811015611aeb57836000018181548110611a8157611a81613214565b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16838281518110611abe57611abe613214565b73ffffffffffffffffffffffffffffffffffffffff90921660209283029190910190910152600101611a64565b50909392505050565b6040517f52430c8d0000000000000000000000000000000000000000000000000000000081523060048201526000907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906352430c8d90602401602060405180830381865afa158015611b81573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ba59190613510565b6fffffffffffffffffffffffffffffffff16905060008111611bf3576040517fdac5ec8b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b90565b6000808251604103611c2c5760208301516040840151606085015160001a611c2087828585612928565b94509450505050611c34565b506000905060025b9250929050565b60008060008573ffffffffffffffffffffffffffffffffffffffff16631626ba7e60e01b8686604051602401611c72929190613542565b604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529181526020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff00000000000000000000000000000000000000000000000000000000909416939093179092529051611cfb919061355b565b600060405180830381855afa9150503d8060008114611d36576040519150601f19603f3d011682016040523d82523d6000602084013e611d3b565b606091505b5091509150818015611d4f57506020815110155b80156117c0575080517f1626ba7e0000000000000000000000000000000000000000000000000000000090611d8d9083016020908101908401613577565b149695505050505050565b600080807f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f90506000845111611e50576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f4c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e206660448201527f6163657420746f206375740000000000000000000000000000000000000000006064820152608401610360565b6000856002811115611e6457611e64612e8a565b0361203457611e8b8660405180606001604052806024815260200161365760249139612a17565b60005b845181101561202e576000858281518110611eab57611eab613214565b6020908102919091018101517fffffffff000000000000000000000000000000000000000000000000000000008116600090815291859052604090912054909150606081901c15611f7e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774206164642066756e6374696f60448201527f6e207468617420616c72656164792065786973747300000000000000000000006064820152608401610360565b7fffffffff0000000000000000000000000000000000000000000000000000000080831660008181526020879052604090207fffffffffffffffffffffffffffffffffffffffff00000000000000000000000060608d901b168e17905560e060058e901b811692831c199c909c1690821c179a8190036120125760038c901c600090815260018601602052604081209b909b555b8b61201c81613590565b9c505060019093019250611e8e915050565b5061281d565b600185600281111561204857612048612e8a565b036123385761206f866040518060600160405280602881526020016136a360289139612a17565b60005b845181101561202e57600085828151811061208f5761208f613214565b6020908102919091018101517fffffffff000000000000000000000000000000000000000000000000000000008116600090815291859052604090912054909150606081901c308103612164576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602f60248201527f4c69624469616d6f6e644375743a2043616e2774207265706c61636520696d6d60448201527f757461626c652066756e6374696f6e00000000000000000000000000000000006064820152608401610360565b8973ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff160361221f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e20776974682073616d652066756e6374696f6e00000000000000006064820152608401610360565b73ffffffffffffffffffffffffffffffffffffffff81166122c2576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603860248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e207468617420646f65736e277420657869737400000000000000006064820152608401610360565b507fffffffff0000000000000000000000000000000000000000000000000000000090911660009081526020849052604090206bffffffffffffffffffffffff919091167fffffffffffffffffffffffffffffffffffffffff00000000000000000000000060608a901b16179055600101612072565b600285600281111561234c5761234c612e8a565b036127955773ffffffffffffffffffffffffffffffffffffffff8616156123f5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603660248201527f4c69624469616d6f6e644375743a2052656d6f7665206661636574206164647260448201527f657373206d7573742062652061646472657373283029000000000000000000006064820152608401610360565b600388901c6007891660005b86518110156127755760008a900361243d578261241d816135c8565b60008181526001870160205260409020549b5093506007925061244b9050565b81612447816135c8565b9250505b6000806000808a858151811061246357612463613214565b6020908102919091018101517fffffffff0000000000000000000000000000000000000000000000000000000081166000908152918a9052604090912054909150606081901c612535576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603760248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f76652066756e6360448201527f74696f6e207468617420646f65736e27742065786973740000000000000000006064820152608401610360565b30606082901c036125c8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602e60248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f766520696d6d7560448201527f7461626c652066756e6374696f6e0000000000000000000000000000000000006064820152608401610360565b600587901b8f901b94507fffffffff0000000000000000000000000000000000000000000000000000000080861690831614612666577fffffffff000000000000000000000000000000000000000000000000000000008516600090815260208a90526040902080547fffffffffffffffffffffffffffffffffffffffff000000000000000000000000166bffffffffffffffffffffffff83161790555b7fffffffff0000000000000000000000000000000000000000000000000000000091909116600090815260208990526040812055600381901c611fff16925060051b60e01690508582146126fb576000828152600188016020526040902080547fffffffff0000000000000000000000000000000000000000000000000000000080841c19909116908516831c17905561274c565b80837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c817fffffffff0000000000000000000000000000000000000000000000000000000060001b901c198e16179c505b8460000361276a57600086815260018801602052604081208190559c505b505050600101612401565b50806127828360086135fd565b61278c9190613201565b9950505061281d565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602760248201527f4c69624469616d6f6e644375743a20496e636f7272656374204661636574437560448201527f74416374696f6e000000000000000000000000000000000000000000000000006064820152608401610360565b50959694955050505050565b73ffffffffffffffffffffffffffffffffffffffff8216612848575050565b61286a8260405180606001604052806028815260200161367b60289139612a17565b6000808373ffffffffffffffffffffffffffffffffffffffff1683604051612892919061355b565b600060405180830381855af49150503d80600081146128cd576040519150601f19603f3d011682016040523d82523d6000602084013e6128d2565b606091505b509150915081612922578051156128ec5780518082602001fd5b83836040517f192105d7000000000000000000000000000000000000000000000000000000008152600401610360929190613614565b50505050565b6000807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a083111561295f5750600090506003612a0e565b6040805160008082526020820180845289905260ff881692820192909252606081018690526080810185905260019060a0016020604051602081039080840390855afa1580156129b3573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116612a0757600060019250925050612a0e565b9150600090505b94509492505050565b813b8181612922576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016103609190613643565b60008083601f840112612a6457600080fd5b50813567ffffffffffffffff811115612a7c57600080fd5b6020830191508360208260051b8501011115611c3457600080fd5b60008060208385031215612aaa57600080fd5b823567ffffffffffffffff811115612ac157600080fd5b612acd85828601612a52565b90969095509350505050565b60008060008060008060608789031215612af257600080fd5b863567ffffffffffffffff80821115612b0a57600080fd5b612b168a838b01612a52565b90985096506020890135915080821115612b2f57600080fd5b612b3b8a838b01612a52565b90965094506040890135915080821115612b5457600080fd5b50612b6189828a01612a52565b979a9699509497509295939492505050565b803573ffffffffffffffffffffffffffffffffffffffff81168114612b9757600080fd5b919050565b600080600080600060608688031215612bb457600080fd5b853567ffffffffffffffff80821115612bcc57600080fd5b612bd889838a01612a52565b9097509550859150612bec60208901612b73565b94506040880135915080821115612c0257600080fd5b818801915088601f830112612c1657600080fd5b813581811115612c2557600080fd5b896020828501011115612c3757600080fd5b9699959850939650602001949392505050565b600060208284031215612c5c57600080fd5b5035919050565b80357fffffffff0000000000000000000000000000000000000000000000000000000081168114612b9757600080fd5b8015158114612ca157600080fd5b50565b60008060408385031215612cb757600080fd5b612cc083612c63565b91506020830135612cd081612c93565b809150509250929050565b60008060408385031215612cee57600080fd5b82359150612cfe60208401612b73565b90509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715612d5957612d59612d07565b60405290565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715612da657612da6612d07565b604052919050565b600067ffffffffffffffff821115612dc857612dc8612d07565b5060051b60200190565b60008060408385031215612de557600080fd5b8235915060208084013567ffffffffffffffff811115612e0457600080fd5b8401601f81018613612e1557600080fd5b8035612e28612e2382612dae565b612d5f565b81815260059190911b82018301908381019088831115612e4757600080fd5b928401925b82841015612e6c57612e5d84612b73565b82529284019290840190612e4c565b80955050505050509250929050565b803560038110612b9757600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60038110612ef0577f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b9052565b8183526000602080850194508260005b85811015612f49577fffffffff00000000000000000000000000000000000000000000000000000000612f3683612c63565b1687529582019590820190600101612f04565b509495945050505050565b60208082528181018390526000906040808401600586811b8601830188865b8981101561309b577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089840301855281357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa18c3603018112612fd457600080fd5b8b01606073ffffffffffffffffffffffffffffffffffffffff612ff683612b73565b168552613004898301612e7b565b6130108a870182612eb9565b50878201357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe183360301811261304557600080fd5b90910188810191903567ffffffffffffffff81111561306357600080fd5b80871b360383131561307457600080fd5b81898701526130868287018285612ef4565b978a0197955050509187019150600101612f73565b50909998505050505050505050565b60006130b8612e2384612dae565b83815260208082019190600586811b8601368111156130d657600080fd5b865b818110156131c557803567ffffffffffffffff808211156130f95760008081fd5b818a0191506060823603121561310f5760008081fd5b613117612d36565b61312083612b73565b815261312d878401612e7b565b87820152604080840135838111156131455760008081fd5b939093019236601f85011261315c57600092508283fd5b8335925061316c612e2384612dae565b83815292871b840188019288810190368511156131895760008081fd5b948901945b848610156131ae5761319f86612c63565b8252948901949089019061318e565b9183019190915250885250509483019483016130d8565b5092979650505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820180821115610c8757610c876131d2565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006020828403121561325557600080fd5b61325e82612b73565b9392505050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe184360301811261329a57600080fd5b83018035915067ffffffffffffffff8211156132b557600080fd5b602001915036819003821315611c3457600080fd5b600081518084526020808501945080840160005b83811015612f495781517fffffffff0000000000000000000000000000000000000000000000000000000016875295820195908201906001016132de565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000610ee560408301846132ca565b60006020828403121561335d57600080fd5b815161325e81612c93565b81810381811115610c8757610c876131d2565b6000826133b1577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60005b838110156133d15781810151838201526020016133b9565b50506000910152565b600081518084526133f28160208601602086016133b6565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6000606080830181845280875180835260808601915060808160051b87010192506020808a0160005b838110156134d4577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80898703018552815173ffffffffffffffffffffffffffffffffffffffff8151168752838101516134a885890182612eb9565b506040908101519087018890526134c1878901826132ca565b965050938201939082019060010161344d565b505073ffffffffffffffffffffffffffffffffffffffff8916908701525050838103604085015261350581866133da565b979650505050505050565b60006020828403121561352257600080fd5b81516fffffffffffffffffffffffffffffffff8116811461325e57600080fd5b828152604060208201526000610ee560408301846133da565b6000825161356d8184602087016133b6565b9190910192915050565b60006020828403121561358957600080fd5b5051919050565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036135c1576135c16131d2565b5060010190565b6000816135d7576135d76131d2565b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0190565b8082028115828204841417610c8757610c876131d2565b73ffffffffffffffffffffffffffffffffffffffff83168152604060208201526000610ee560408301846133da565b60208152600061325e60208301846133da56fe4c69624469616d6f6e644375743a2041646420666163657420686173206e6f20636f64654c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f64654c69624469616d6f6e644375743a205265706c61636520666163657420686173206e6f20636f6465a2646970667358221220c5a8c10b22f20cde3fe0431ff57305237423677a60888f5b349fc6751336ae1464736f6c63430008150033",
  "devdoc": {
    "author": "David Yongjun Kim (@Powerstream3604)",
    "details": "Responsible for adding/removing/replace facets in Barz",
    "kind": "dev",
    "methods": {
      "_checkDuplicateOnChainApprover(bytes32,address[])": {
        "params": {
          "_approvers": "List of approver addresses",
          "_diamondCutHash": "Hash of diamondCut information including the facet addresses and function selectors"
        }
      },
      "approveDiamondCut((address,uint8,bytes4[])[])": {
        "params": {
          "_diamondCut": "Contains the facet addresses and function selectors"
        }
      },
      "constructor": {
        "params": {
          "_securityManager": "Security Manager contract that holds the security related variables for all wallets"
        }
      },
      "diamondCut((address,uint8,bytes4[])[],address,bytes)": {
        "params": {
          "_diamondCut": "Contains the facet addresses and function selectors",
          "_init": "The address of the contract or facet to execute _calldata. It's prohibited in Barz"
        }
      },
      "diamondCutWithGuardian((address,uint8,bytes4[])[],address[],bytes[])": {
        "params": {
          "_approvers": "Guardian or owner address that approves the diamond cut",
          "_diamondCut": "Contains the facet addresses and function selectors",
          "_signatures": "Signature of Guardians or owner that approves the diamond cut"
        }
      },
      "getDiamondCutApprovalCountWithTimeValidity(bytes32)": {
        "params": {
          "_diamondCutHash": "Hash of diamondCut information including the facet addresses and function selectors"
        }
      },
      "getDiamondCutHash((address,uint8,bytes4[])[])": {
        "params": {
          "_diamondCut": "Contains the facet addresses and function selectors"
        },
        "returns": {
          "cutHash": "Diamond Cut Hash"
        }
      },
      "getDiamondCutNonce()": {
        "details": "This method fetches the nonce from diamond cut storage",
        "returns": {
          "cutNonce": "Nonce of diamond cut to protect from reply attacks"
        }
      },
      "getOwnerCutApprovalWithTimeValidity(bytes32)": {
        "params": {
          "_diamondCutHash": "Hash of diamondCut information including the facet addresses and function selectors"
        },
        "returns": {
          "isApprovedByOwner": "Bool value showing if the owner approved the cut"
        }
      },
      "isCutApproved(bytes32,address)": {
        "params": {
          "_approver": "Address of approver",
          "_diamondCutHash": "Hash of diamondCut information including the facet addresses and function selectors"
        },
        "returns": {
          "isApproved": "Bool value showing if the approver approved the cut"
        }
      },
      "revokeDiamondCutApproval((address,uint8,bytes4[])[])": {
        "params": {
          "_diamondCut": "Contains the facet addresses and function selectors"
        }
      },
      "updateSupportsInterface(bytes4,bool)": {
        "params": {
          "_flag": "Bool value to update the mapping of the given interface ID",
          "_interfaceId": "InterfaceID to update the mapping"
        }
      }
    },
    "title": "DiamondCut Facet",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_checkDuplicateOnChainApprover(bytes32,address[])": {
        "notice": "Checks if their is duplicate approver is included in off-chain approval verification and on-chain approval         Approvers who approved on-chain should not be included in the off-chain approval"
      },
      "approveDiamondCut((address,uint8,bytes4[])[])": {
        "notice": "Approves diamond cut. This can only be called directly from guardian or owner"
      },
      "constructor": {
        "notice": "This constructor sets the Security Manager address which is an immutable variable.         Immutable variables do not impact the storage of diamond"
      },
      "diamondCut((address,uint8,bytes4[])[],address,bytes)": {
        "notice": "Add/replace/remove any number of functions and optionally execute         a function with delegatecall when guardians don't exist"
      },
      "diamondCutWithGuardian((address,uint8,bytes4[])[],address[],bytes[])": {
        "notice": "Add/replace/remove any number of functions and optionally execute         a function with delegatecall when guardians exist"
      },
      "getDiamondCutApprovalCountWithTimeValidity(bytes32)": {
        "notice": "Gets the number of approvals of diamond cut from guardians"
      },
      "getDiamondCutHash((address,uint8,bytes4[])[])": {
        "notice": "Returns the diamond cut hash. This function ensures that this hash is safe from replay attack by including         salt, address, chainId, and nonce, etc."
      },
      "getDiamondCutNonce()": {
        "notice": "Returns the diamond cut nonce of this wallet"
      },
      "getOwnerCutApprovalWithTimeValidity(bytes32)": {
        "notice": "Returns if the owner has approved the diamond cut"
      },
      "isCutApproved(bytes32,address)": {
        "notice": "Returns if the given approver has approved the diamond cut"
      },
      "revokeDiamondCutApproval((address,uint8,bytes4[])[])": {
        "notice": "Revokes the approval of diamond cut. This can only be called directly from guardian or owner"
      },
      "updateSupportsInterface(bytes4,bool)": {
        "notice": "Updates the flag for the interfaceId"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 27866,
        "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)27613_storage"
      }
    ],
    "types": {
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_contract(IEntryPoint)12286": {
        "encoding": "inplace",
        "label": "contract IEntryPoint",
        "numberOfBytes": "20"
      },
      "t_contract(IFacetRegistry)26148": {
        "encoding": "inplace",
        "label": "contract IFacetRegistry",
        "numberOfBytes": "20"
      },
      "t_mapping(t_uint256,t_struct(InitializersStorage)27592_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct InitializersStorage)",
        "numberOfBytes": "32",
        "value": "t_struct(InitializersStorage)27592_storage"
      },
      "t_mapping(t_uint256,t_struct(Lock)27585_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Lock)",
        "numberOfBytes": "32",
        "value": "t_struct(Lock)27585_storage"
      },
      "t_struct(AppStorage)27613_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 27597,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "initStorage",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_uint256,t_struct(InitializersStorage)27592_storage)"
          },
          {
            "astId": 27599,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "signerMigration",
            "offset": 0,
            "slot": "1",
            "type": "t_uint8"
          },
          {
            "astId": 27601,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "validateOwnerSignatureSelector",
            "offset": 1,
            "slot": "1",
            "type": "t_bytes4"
          },
          {
            "astId": 27604,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "entryPoint",
            "offset": 5,
            "slot": "1",
            "type": "t_contract(IEntryPoint)12286"
          },
          {
            "astId": 27607,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "facetRegistry",
            "offset": 0,
            "slot": "2",
            "type": "t_contract(IFacetRegistry)26148"
          },
          {
            "astId": 27612,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "locks",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_uint256,t_struct(Lock)27585_storage)"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_struct(InitializersStorage)27592_storage": {
        "encoding": "inplace",
        "label": "struct InitializersStorage",
        "members": [
          {
            "astId": 27587,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "signerInitialized",
            "offset": 0,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 27589,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "accountInitialized",
            "offset": 1,
            "slot": "0",
            "type": "t_uint8"
          },
          {
            "astId": 27591,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "restrictionsInitialized",
            "offset": 2,
            "slot": "0",
            "type": "t_uint8"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_struct(Lock)27585_storage": {
        "encoding": "inplace",
        "label": "struct Lock",
        "members": [
          {
            "astId": 27582,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "release",
            "offset": 0,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 27584,
            "contract": "contracts/facets/base/DiamondCutFacet.sol:DiamondCutFacet",
            "label": "locker",
            "offset": 8,
            "slot": "0",
            "type": "t_bytes4"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}