{
  "address": "0x2e7f1dAe1F3799d20f5c31bEFdc7A620f664728D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_diamondCutFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_accountFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_tokenReceiverFacet",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_diamondLoupeFacet",
          "type": "address"
        }
      ],
      "stateMutability": "payable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_initializationContractAddress",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "InitializationFunctionReverted",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "enum IDiamondCut.FacetCutAction",
              "name": "action",
              "type": "uint8"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "indexed": false,
          "internalType": "struct IDiamondCut.FacetCut[]",
          "name": "_diamondCut",
          "type": "tuple[]"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_init",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bytes",
          "name": "_calldata",
          "type": "bytes"
        }
      ],
      "name": "DiamondCut",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "_functionSelector",
          "type": "bytes4"
        }
      ],
      "name": "facetAddress",
      "outputs": [
        {
          "internalType": "address",
          "name": "facetAddress_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facetAddresses",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "facetAddresses_",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_facet",
          "type": "address"
        }
      ],
      "name": "facetFunctionSelectors",
      "outputs": [
        {
          "internalType": "bytes4[]",
          "name": "facetFunctionSelectors_",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "facets",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "facetAddress",
              "type": "address"
            },
            {
              "internalType": "bytes4[]",
              "name": "functionSelectors",
              "type": "bytes4[]"
            }
          ],
          "internalType": "struct IDiamondLoupe.Facet[]",
          "name": "facets_",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xde4fe864bb60e7fafbe1cc44c4165a36db83a7d9ab7cadbd45a2a645afdeae81",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0xd87dF9Fd27B9a30fe27E7b294CaAa4673F34B6b1",
    "contractAddress": null,
    "transactionIndex": 4,
    "gasUsed": "1439057",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000001000000000800002000000000000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000",
    "blockHash": "0x4505c73ff1a4115f8d944ec1337d369d35a05f8614128414de98829341cc6bd0",
    "transactionHash": "0xde4fe864bb60e7fafbe1cc44c4165a36db83a7d9ab7cadbd45a2a645afdeae81",
    "logs": [
      {
        "transactionIndex": 4,
        "blockNumber": 1317801,
        "transactionHash": "0xde4fe864bb60e7fafbe1cc44c4165a36db83a7d9ab7cadbd45a2a645afdeae81",
        "address": "0x2e7f1dAe1F3799d20f5c31bEFdc7A620f664728D",
        "topics": [
          "0x8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb673"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000580000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000800000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000003600000000000000000000000000b9504140771c3688ff041917192277d2f52e1e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000011f931c1c00000000000000000000000000000000000000000000000000000000000000000000000000000000fde53272dcd7938d16e031a6989753c321728332000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000005b61d27f60000000000000000000000000000000000000000000000000000000047e1da2a000000000000000000000000000000000000000000000000000000003a871cdd00000000000000000000000000000000000000000000000000000000d087d28800000000000000000000000000000000000000000000000000000000b0d691fe000000000000000000000000000000000000000000000000000000000000000000000000000000003143e1c0af0cdc153423863923cf4e3818e34daa000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000005150b7a0200000000000000000000000000000000000000000000000000000000f23a6e6100000000000000000000000000000000000000000000000000000000bc197c81000000000000000000000000000000000000000000000000000000000023de2900000000000000000000000000000000000000000000000000000000a4c0ed3600000000000000000000000000000000000000000000000000000000000000000000000000000000ce36b85d12d81cd619c745c7717f3396e184ac7c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000097a0ed62700000000000000000000000000000000000000000000000000000000adfca15e0000000000000000000000000000000000000000000000000000000052ef6b2c00000000000000000000000000000000000000000000000000000000cdffacc60000000000000000000000000000000000000000000000000000000001ffc9a700000000000000000000000000000000000000000000000000000000f9796ccf0000000000000000000000000000000000000000000000000000000001a5502200000000000000000000000000000000000000000000000000000000d42139a900000000000000000000000000000000000000000000000000000000e3a2f6fe000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
        "logIndex": 18,
        "blockHash": "0x4505c73ff1a4115f8d944ec1337d369d35a05f8614128414de98829341cc6bd0"
      }
    ],
    "blockNumber": 1317801,
    "cumulativeGasUsed": "2220102",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x0B9504140771C3688Ff041917192277D2f52E1e0",
    "0xFde53272dcd7938d16E031A6989753c321728332",
    "0x3143E1C0Af0Cdc153423863923Cf4e3818e34Daa",
    "0xCe36b85d12D81cd619C745c7717f3396E184Ac7C"
  ],
  "numDeployments": 1,
  "solcInputHash": "ad34345aa73d96f52b3e14df983b6b29",
  "metadata": "{\"compiler\":{\"version\":\"0.8.21+commit.d9974bed\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_diamondCutFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_accountFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_tokenReceiverFacet\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_diamondLoupeFacet\",\"type\":\"address\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_initializationContractAddress\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"InitializationFunctionReverted\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"enum IDiamondCut.FacetCutAction\",\"name\":\"action\",\"type\":\"uint8\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"indexed\":false,\"internalType\":\"struct IDiamondCut.FacetCut[]\",\"name\":\"_diamondCut\",\"type\":\"tuple[]\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_init\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"DiamondCut\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"_functionSelector\",\"type\":\"bytes4\"}],\"name\":\"facetAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"facetAddress_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facetAddresses\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"facetAddresses_\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_facet\",\"type\":\"address\"}],\"name\":\"facetFunctionSelectors\",\"outputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"facetFunctionSelectors_\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"facets\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"facetAddress\",\"type\":\"address\"},{\"internalType\":\"bytes4[]\",\"name\":\"functionSelectors\",\"type\":\"bytes4[]\"}],\"internalType\":\"struct IDiamondLoupe.Facet[]\",\"name\":\"facets_\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"David Yongjun Kim (@Powerstream3604)\",\"details\":\"A default fallback handler for Barz\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"This contract is also a diamond that holds the default facets to reduce gas cost for wallet activation.      Within the constructor this conducts diamond cut to initially setup the diamond. This is a non-upgradeable contract\",\"params\":{\"_accountFacet\":\"Address account facet\",\"_diamondCutFacet\":\"Address if diamond cut facet\",\"_diamondLoupeFacet\":\"Address of diamond loupe facet\",\"_tokenReceiverFacet\":\"Address of token receiver facet\"}},\"facetAddress(bytes4)\":{\"details\":\"If facet is not found return address(0).\",\"params\":{\"_functionSelector\":\"The function selector.\"},\"returns\":{\"facetAddress_\":\"The facet address.\"}},\"facetAddresses()\":{\"returns\":{\"facetAddresses_\":\"facetAddresses_\"}},\"facetFunctionSelectors(address)\":{\"params\":{\"_facet\":\"The facet address.\"},\"returns\":{\"facetFunctionSelectors_\":\"facetFunctionSelectors_\"}},\"facets()\":{\"returns\":{\"facets_\":\"The facet struct array including all facet information\"}}},\"title\":\"DefaultFallbackHandler\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Sets the middleware diamond for Barz wallet as a fallback handler\"},\"facetAddress(bytes4)\":{\"notice\":\"Gets the facet that supports the given selector.\"},\"facetAddresses()\":{\"notice\":\"Get all the facet addresses used by a diamond.\"},\"facetFunctionSelectors(address)\":{\"notice\":\"Gets all the function selectors provided by a facet.\"},\"facets()\":{\"notice\":\"Returns the facet information of call facets registered to this diamond.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/infrastructure/DefaultFallbackHandler.sol\":\"DefaultFallbackHandler\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":999999},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev _Available since v3.1._\\n */\\ninterface IERC1155Receiver is IERC165 {\\n    /**\\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\\n     *\\n     * NOTE: To accept the transfer, this must return\\n     * `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`\\n     * (i.e. 0xf23a6e61, or its own function selector).\\n     *\\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param id The ID of the token being transferred\\n     * @param value The amount of tokens being transferred\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    /**\\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\\n     * been updated.\\n     *\\n     * NOTE: To accept the transfer(s), this must return\\n     * `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`\\n     * (i.e. 0xbc197c81, or its own function selector).\\n     *\\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\\n     * @param from The address which previously owned the token\\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\\n     * @param data Additional data with no specified format\\n     * @return `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))` if transfer is allowed\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xeb373f1fdc7b755c6a750123a9b9e3a8a02c1470042fd6505d875000a80bde0b\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721Receiver {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0xa82b58eca1ee256be466e536706850163d2ec7821945abd6b4778cfb3bee37da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC777/IERC777Recipient.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC777TokensRecipient standard as defined in the EIP.\\n *\\n * Accounts can be notified of {IERC777} tokens being sent to them by having a\\n * contract implement this interface (contract holders can be their own\\n * implementer) and registering it on the\\n * https://eips.ethereum.org/EIPS/eip-1820[ERC1820 global registry].\\n *\\n * See {IERC1820Registry} and {ERC1820Implementer}.\\n */\\ninterface IERC777Recipient {\\n    /**\\n     * @dev Called by an {IERC777} token contract whenever tokens are being\\n     * moved or created into a registered account (`to`). The type of operation\\n     * is conveyed by `from` being the zero address or not.\\n     *\\n     * This call occurs _after_ the token contract's state is updated, so\\n     * {IERC777-balanceOf}, etc., can be used to query the post-operation state.\\n     *\\n     * This function may revert to prevent the operation from being executed.\\n     */\\n    function tokensReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 amount,\\n        bytes calldata userData,\\n        bytes calldata operatorData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1a5d61db2733202ba361e6d6741cd2e662380e22b80e987eacfc91973f2267dc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"contracts/aa-4337/core/BaseAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.21;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-empty-blocks */\\n\\nimport \\\"../interfaces/IAccount.sol\\\";\\nimport \\\"../interfaces/IEntryPoint.sol\\\";\\nimport \\\"./Helpers.sol\\\";\\n\\n/**\\n * Basic account implementation.\\n * this contract provides the basic logic for implementing the IAccount interface  - validateUserOp\\n * specific account implementation should inherit it and provide the account-specific logic\\n */\\nabstract contract BaseAccount is IAccount {\\n    using UserOperationLib for UserOperation;\\n\\n    //return value in case of signature failure, with no time-range.\\n    // equivalent to _packValidationData(true,0,0);\\n    uint256 internal constant SIG_VALIDATION_FAILED = 1;\\n\\n    /**\\n     * Return the account nonce.\\n     * This method returns the next sequential nonce.\\n     * For a nonce of a specific key, use `entrypoint.getNonce(account, key)`\\n     */\\n    function getNonce() public view virtual returns (uint256) {\\n        return entryPoint().getNonce(address(this), 0);\\n    }\\n\\n    /**\\n     * return the entryPoint used by this account.\\n     * subclass should return the current entryPoint used by this account.\\n     */\\n    function entryPoint() public view virtual returns (IEntryPoint);\\n\\n    /**\\n     * Validate user's signature and nonce.\\n     * subclass doesn't need to override this method. Instead, it should override the specific internal validation methods.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external virtual override returns (uint256 validationData) {\\n        _requireFromEntryPoint();\\n        validationData = _validateSignature(userOp, userOpHash);\\n        _validateNonce(userOp.nonce);\\n        _payPrefund(missingAccountFunds);\\n    }\\n\\n    /**\\n     * ensure the request comes from the known entrypoint.\\n     */\\n    function _requireFromEntryPoint() internal view virtual {\\n        require(\\n            msg.sender == address(entryPoint()),\\n            \\\"account: not from EntryPoint\\\"\\n        );\\n    }\\n\\n    /**\\n     * validate the signature is valid for this message.\\n     * @param userOp validate the userOp.signature field\\n     * @param userOpHash convenient field: the hash of the request, to check the signature against\\n     *          (also hashes the entrypoint and chain id)\\n     * @return validationData signature and time-range of this operation\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\n     *      If the account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function _validateSignature(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash\\n    ) internal virtual returns (uint256 validationData);\\n\\n    /**\\n     * Validate the nonce of the UserOperation.\\n     * This method may validate the nonce requirement of this account.\\n     * e.g.\\n     * To limit the nonce to use sequenced UserOps only (no \\\"out of order\\\" UserOps):\\n     *      `require(nonce < type(uint64).max)`\\n     * For a hypothetical account that *requires* the nonce to be out-of-order:\\n     *      `require(nonce & type(uint64).max == 0)`\\n     *\\n     * The actual nonce uniqueness is managed by the EntryPoint, and thus no other\\n     * action is needed by the account itself.\\n     *\\n     * @param nonce to validate\\n     *\\n     * solhint-disable-next-line no-empty-blocks\\n     */\\n    function _validateNonce(uint256 nonce) internal view virtual {}\\n\\n    /**\\n     * sends to the entrypoint (msg.sender) the missing funds for this transaction.\\n     * subclass MAY override this method for better funds management\\n     * (e.g. send to the entryPoint more than the minimum required, so that in future transactions\\n     * it will not be required to send again)\\n     * @param missingAccountFunds the minimum value this method should send the entrypoint.\\n     *  this value MAY be zero, in case there is enough deposit, or the userOp has a paymaster.\\n     */\\n    function _payPrefund(uint256 missingAccountFunds) internal virtual {\\n        if (missingAccountFunds != 0) {\\n            (bool success, ) = payable(msg.sender).call{\\n                value: missingAccountFunds,\\n                gas: type(uint256).max\\n            }(\\\"\\\");\\n            (success);\\n            //ignore failure (its EntryPoint's job to verify, not account.)\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa0dcc386b0f04711db3e394fb50e55a3b3b1a4d19fac1f10895844e1aa4e3d5c\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/core/Helpers.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity 0.8.21;\\n\\n/* solhint-disable no-inline-assembly */\\n\\n/**\\n * returned data from validateUserOp.\\n * validateUserOp returns a uint256, with is created by `_packedValidationData` and parsed by `_parseValidationData`\\n * @param aggregator - address(0) - the account validated the signature by itself.\\n *              address(1) - the account failed to validate the signature.\\n *              otherwise - this is an address of a signature aggregator that must be used to validate the signature.\\n * @param validAfter - this UserOp is valid only after this timestamp.\\n * @param validaUntil - this UserOp is valid only up to this timestamp.\\n */\\nstruct ValidationData {\\n    address aggregator;\\n    uint48 validAfter;\\n    uint48 validUntil;\\n}\\n\\n//extract sigFailed, validAfter, validUntil.\\n// also convert zero validUntil to type(uint48).max\\nfunction _parseValidationData(\\n    uint validationData\\n) pure returns (ValidationData memory data) {\\n    address aggregator = address(uint160(validationData));\\n    uint48 validUntil = uint48(validationData >> 160);\\n    if (validUntil == 0) {\\n        validUntil = type(uint48).max;\\n    }\\n    uint48 validAfter = uint48(validationData >> (48 + 160));\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n// intersect account and paymaster ranges.\\nfunction _intersectTimeRange(\\n    uint256 validationData,\\n    uint256 paymasterValidationData\\n) pure returns (ValidationData memory) {\\n    ValidationData memory accountValidationData = _parseValidationData(\\n        validationData\\n    );\\n    ValidationData memory pmValidationData = _parseValidationData(\\n        paymasterValidationData\\n    );\\n    address aggregator = accountValidationData.aggregator;\\n    if (aggregator == address(0)) {\\n        aggregator = pmValidationData.aggregator;\\n    }\\n    uint48 validAfter = accountValidationData.validAfter;\\n    uint48 validUntil = accountValidationData.validUntil;\\n    uint48 pmValidAfter = pmValidationData.validAfter;\\n    uint48 pmValidUntil = pmValidationData.validUntil;\\n\\n    if (validAfter < pmValidAfter) validAfter = pmValidAfter;\\n    if (validUntil > pmValidUntil) validUntil = pmValidUntil;\\n    return ValidationData(aggregator, validAfter, validUntil);\\n}\\n\\n/**\\n * helper to pack the return value for validateUserOp\\n * @param data - the ValidationData to pack\\n */\\nfunction _packValidationData(\\n    ValidationData memory data\\n) pure returns (uint256) {\\n    return\\n        uint160(data.aggregator) |\\n        (uint256(data.validUntil) << 160) |\\n        (uint256(data.validAfter) << (160 + 48));\\n}\\n\\n/**\\n * helper to pack the return value for validateUserOp, when not using an aggregator\\n * @param sigFailed - true for signature failure, false for success\\n * @param validUntil last timestamp this UserOperation is valid (or zero for infinite)\\n * @param validAfter first timestamp this UserOperation is valid\\n */\\nfunction _packValidationData(\\n    bool sigFailed,\\n    uint48 validUntil,\\n    uint48 validAfter\\n) pure returns (uint256) {\\n    return\\n        (sigFailed ? 1 : 0) |\\n        (uint256(validUntil) << 160) |\\n        (uint256(validAfter) << (160 + 48));\\n}\\n\\n/**\\n * keccak function over calldata.\\n * @dev copy calldata into memory, do keccak and drop allocated memory. Strangely, this is more efficient than letting solidity do it.\\n */\\nfunction calldataKeccak(bytes calldata data) pure returns (bytes32 ret) {\\n    assembly {\\n        let mem := mload(0x40)\\n        let len := data.length\\n        calldatacopy(mem, data.offset, len)\\n        ret := keccak256(mem, len)\\n    }\\n}\\n\",\"keccak256\":\"0xa79f06cd158ecb8c0da95493a2f348933b8627a63e228b99738bff3aa107942d\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IAccount.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\ninterface IAccount {\\n    /**\\n     * Validate user's signature and nonce\\n     * the entryPoint will make the call to the recipient only if this validation call returns successfully.\\n     * signature failure should be reported by returning SIG_VALIDATION_FAILED (1).\\n     * This allows making a \\\"simulation call\\\" without a valid signature\\n     * Other failures (e.g. nonce mismatch, or invalid signature format) should still revert to signal failure.\\n     *\\n     * @dev Must validate caller is the entryPoint.\\n     *      Must validate the signature and nonce\\n     * @param userOp the operation that is about to be executed.\\n     * @param userOpHash hash of the user's request data. can be used as the basis for signature.\\n     * @param missingAccountFunds missing funds on the account's deposit in the entrypoint.\\n     *      This is the minimum amount to transfer to the sender(entryPoint) to be able to make the call.\\n     *      The excess is left as a deposit in the entrypoint, for future calls.\\n     *      can be withdrawn anytime using \\\"entryPoint.withdrawTo()\\\"\\n     *      In case there is a paymaster in the request (or the current deposit is high enough), this value will be zero.\\n     * @return validationData packaged ValidationData structure. use `_packValidationData` and `_unpackValidationData` to encode and decode\\n     *      <20-byte> sigAuthorizer - 0 for valid signature, 1 to mark signature failure,\\n     *         otherwise, an address of an \\\"authorizer\\\" contract.\\n     *      <6-byte> validUntil - last timestamp this operation is valid. 0 for \\\"indefinite\\\"\\n     *      <6-byte> validAfter - first timestamp this operation is valid\\n     *      If an account doesn't use time-range, it is enough to return SIG_VALIDATION_FAILED value (1) for signature failure.\\n     *      Note that the validation code cannot use block.timestamp (or block.number) directly.\\n     */\\n    function validateUserOp(\\n        UserOperation calldata userOp,\\n        bytes32 userOpHash,\\n        uint256 missingAccountFunds\\n    ) external returns (uint256 validationData);\\n}\\n\",\"keccak256\":\"0xcbc4b0973cf954c5895b7796335f651fbfcfb55f67dfa789a3d354f8e23c4f2b\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IAggregator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\nimport \\\"./UserOperation.sol\\\";\\n\\n/**\\n * Aggregated Signatures validator.\\n */\\ninterface IAggregator {\\n    /**\\n     * validate aggregated signature.\\n     * revert if the aggregated signature does not match the given list of operations.\\n     */\\n    function validateSignatures(\\n        UserOperation[] calldata userOps,\\n        bytes calldata signature\\n    ) external view;\\n\\n    /**\\n     * validate signature of a single userOp\\n     * This method is should be called by bundler after EntryPoint.simulateValidation() returns (reverts) with ValidationResultWithAggregation\\n     * First it validates the signature over the userOp. Then it returns data to be used when creating the handleOps.\\n     * @param userOp the userOperation received from the user.\\n     * @return sigForUserOp the value to put into the signature field of the userOp when calling handleOps.\\n     *    (usually empty, unless account and aggregator support some kind of \\\"multisig\\\"\\n     */\\n    function validateUserOpSignature(\\n        UserOperation calldata userOp\\n    ) external view returns (bytes memory sigForUserOp);\\n\\n    /**\\n     * aggregate multiple signatures into a single value.\\n     * This method is called off-chain to calculate the signature to pass with handleOps()\\n     * bundler MAY use optimized custom code perform this aggregation\\n     * @param userOps array of UserOperations to collect the signatures from.\\n     * @return aggregatedSignature the aggregated signature\\n     */\\n    function aggregateSignatures(\\n        UserOperation[] calldata userOps\\n    ) external view returns (bytes memory aggregatedSignature);\\n}\\n\",\"keccak256\":\"0xdfdcd80568f037716674619b31be630fcd8316262f05a815b41d1e81782c966a\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IEntryPoint.sol\":{\"content\":\"/**\\n ** Account-Abstraction (EIP-4337) singleton EntryPoint implementation.\\n ** Only one instance required on each chain.\\n **/\\n// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable avoid-low-level-calls */\\n/* solhint-disable no-inline-assembly */\\n/* solhint-disable reason-string */\\n\\nimport \\\"./UserOperation.sol\\\";\\nimport \\\"./IStakeManager.sol\\\";\\nimport \\\"./IAggregator.sol\\\";\\nimport \\\"./INonceManager.sol\\\";\\n\\ninterface IEntryPoint is IStakeManager, INonceManager {\\n    /***\\n     * An event emitted after each successful request\\n     * @param userOpHash - unique identifier for the request (hash its entire content, except signature).\\n     * @param sender - the account that generates this request.\\n     * @param paymaster - if non-null, the paymaster that pays for this request.\\n     * @param nonce - the nonce value from the request.\\n     * @param success - true if the sender transaction succeeded, false if reverted.\\n     * @param actualGasCost - actual amount paid (by account or paymaster) for this UserOperation.\\n     * @param actualGasUsed - total gas used by this UserOperation (including preVerification, creation, validation and execution).\\n     */\\n    event UserOperationEvent(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address indexed paymaster,\\n        uint256 nonce,\\n        bool success,\\n        uint256 actualGasCost,\\n        uint256 actualGasUsed\\n    );\\n\\n    /**\\n     * account \\\"sender\\\" was deployed.\\n     * @param userOpHash the userOp that deployed this account. UserOperationEvent will follow.\\n     * @param sender the account that is deployed\\n     * @param factory the factory used to deploy this account (in the initCode)\\n     * @param paymaster the paymaster used by this UserOp\\n     */\\n    event AccountDeployed(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        address factory,\\n        address paymaster\\n    );\\n\\n    /**\\n     * An event emitted if the UserOperation \\\"callData\\\" reverted with non-zero length\\n     * @param userOpHash the request unique identifier.\\n     * @param sender the sender of this request\\n     * @param nonce the nonce used in the request\\n     * @param revertReason - the return bytes from the (reverted) call to \\\"callData\\\".\\n     */\\n    event UserOperationRevertReason(\\n        bytes32 indexed userOpHash,\\n        address indexed sender,\\n        uint256 nonce,\\n        bytes revertReason\\n    );\\n\\n    /**\\n     * an event emitted by handleOps(), before starting the execution loop.\\n     * any event emitted before this event, is part of the validation.\\n     */\\n    event BeforeExecution();\\n\\n    /**\\n     * signature aggregator used by the following UserOperationEvents within this bundle.\\n     */\\n    event SignatureAggregatorChanged(address indexed aggregator);\\n\\n    /**\\n     * a custom revert error of handleOps, to identify the offending op.\\n     *  NOTE: if simulateValidation passes successfully, there should be no reason for handleOps to fail on it.\\n     *  @param opIndex - index into the array of ops to the failed one (in simulateValidation, this is always zero)\\n     *  @param reason - revert reason\\n     *      The string starts with a unique code \\\"AAmn\\\", where \\\"m\\\" is \\\"1\\\" for factory, \\\"2\\\" for account and \\\"3\\\" for paymaster issues,\\n     *      so a failure can be attributed to the correct entity.\\n     *   Should be caught in off-chain handleOps simulation and not happen on-chain.\\n     *   Useful for mitigating DoS attempts against batchers or for troubleshooting of factory/account/paymaster reverts.\\n     */\\n    error FailedOp(uint256 opIndex, string reason);\\n\\n    /**\\n     * error case when a signature aggregator fails to verify the aggregated signature it had created.\\n     */\\n    error SignatureValidationFailed(address aggregator);\\n\\n    /**\\n     * Successful result from simulateValidation.\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     */\\n    error ValidationResult(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo\\n    );\\n\\n    /**\\n     * Successful result from simulateValidation, if the account returns a signature aggregator\\n     * @param returnInfo gas and time-range returned values\\n     * @param senderInfo stake information about the sender\\n     * @param factoryInfo stake information about the factory (if any)\\n     * @param paymasterInfo stake information about the paymaster (if any)\\n     * @param aggregatorInfo signature aggregation info (if the account requires signature aggregator)\\n     *      bundler MUST use it to verify the signature, or reject the UserOperation\\n     */\\n    error ValidationResultWithAggregation(\\n        ReturnInfo returnInfo,\\n        StakeInfo senderInfo,\\n        StakeInfo factoryInfo,\\n        StakeInfo paymasterInfo,\\n        AggregatorStakeInfo aggregatorInfo\\n    );\\n\\n    /**\\n     * return value of getSenderAddress\\n     */\\n    error SenderAddressResult(address sender);\\n\\n    /**\\n     * return value of simulateHandleOp\\n     */\\n    error ExecutionResult(\\n        uint256 preOpGas,\\n        uint256 paid,\\n        uint48 validAfter,\\n        uint48 validUntil,\\n        bool targetSuccess,\\n        bytes targetResult\\n    );\\n\\n    //UserOps handled, per aggregator\\n    struct UserOpsPerAggregator {\\n        UserOperation[] userOps;\\n        // aggregator address\\n        IAggregator aggregator;\\n        // aggregated signature\\n        bytes signature;\\n    }\\n\\n    /**\\n     * Execute a batch of UserOperation.\\n     * no signature aggregator is used.\\n     * if any account requires an aggregator (that is, it returned an aggregator when\\n     * performing simulateValidation), then handleAggregatedOps() must be used instead.\\n     * @param ops the operations to execute\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleOps(\\n        UserOperation[] calldata ops,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * Execute a batch of UserOperation with Aggregators\\n     * @param opsPerAggregator the operations to execute, grouped by aggregator (or address(0) for no-aggregator accounts)\\n     * @param beneficiary the address to receive the fees\\n     */\\n    function handleAggregatedOps(\\n        UserOpsPerAggregator[] calldata opsPerAggregator,\\n        address payable beneficiary\\n    ) external;\\n\\n    /**\\n     * generate a request Id - unique identifier for this request.\\n     * the request ID is a hash over the content of the userOp (except the signature), the entrypoint and the chainid.\\n     */\\n    function getUserOpHash(\\n        UserOperation calldata userOp\\n    ) external view returns (bytes32);\\n\\n    /**\\n     * Simulate a call to account.validateUserOp and paymaster.validatePaymasterUserOp.\\n     * @dev this method always revert. Successful result is ValidationResult error. other errors are failures.\\n     * @dev The node must also verify it doesn't use banned opcodes, and that it doesn't reference storage outside the account's data.\\n     * @param userOp the user operation to validate.\\n     */\\n    function simulateValidation(UserOperation calldata userOp) external;\\n\\n    /**\\n     * gas and return values during simulation\\n     * @param preOpGas the gas used for validation (including preValidationGas)\\n     * @param prefund the required prefund for this operation\\n     * @param sigFailed validateUserOp's (or paymaster's) signature check failed\\n     * @param validAfter - first timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param validUntil - last timestamp this UserOp is valid (merging account and paymaster time-range)\\n     * @param paymasterContext returned by validatePaymasterUserOp (to be passed into postOp)\\n     */\\n    struct ReturnInfo {\\n        uint256 preOpGas;\\n        uint256 prefund;\\n        bool sigFailed;\\n        uint48 validAfter;\\n        uint48 validUntil;\\n        bytes paymasterContext;\\n    }\\n\\n    /**\\n     * returned aggregated signature info.\\n     * the aggregator returned by the account, and its current stake.\\n     */\\n    struct AggregatorStakeInfo {\\n        address aggregator;\\n        StakeInfo stakeInfo;\\n    }\\n\\n    /**\\n     * Get counterfactual sender address.\\n     *  Calculate the sender contract address that will be generated by the initCode and salt in the UserOperation.\\n     * this method always revert, and returns the address in SenderAddressResult error\\n     * @param initCode the constructor code to be passed into the UserOperation.\\n     */\\n    function getSenderAddress(bytes memory initCode) external;\\n\\n    /**\\n     * simulate full execution of a UserOperation (including both validation and target execution)\\n     * this method will always revert with \\\"ExecutionResult\\\".\\n     * it performs full validation of the UserOperation, but ignores signature error.\\n     * an optional target address is called after the userop succeeds, and its value is returned\\n     * (before the entire call is reverted)\\n     * Note that in order to collect the the success/failure of the target call, it must be executed\\n     * with trace enabled to track the emitted events.\\n     * @param op the UserOperation to simulate\\n     * @param target if nonzero, a target address to call after userop simulation. If called, the targetSuccess and targetResult\\n     *        are set to the return from that call.\\n     * @param targetCallData callData to pass to target address\\n     */\\n    function simulateHandleOp(\\n        UserOperation calldata op,\\n        address target,\\n        bytes calldata targetCallData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9ccb1b188eda8bbf5f6c2d01bd83c3d8b2b04fcf745283051d31fe96d1d8e40f\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/INonceManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\ninterface INonceManager {\\n    /**\\n     * Return the next nonce for this sender.\\n     * Within a given key, the nonce values are sequenced (starting with zero, and incremented by one on each userop)\\n     * But UserOp with different keys can come with arbitrary order.\\n     *\\n     * @param sender the account address\\n     * @param key the high 192 bit of the nonce\\n     * @return nonce a full nonce to pass for next UserOp with this sender.\\n     */\\n    function getNonce(\\n        address sender,\\n        uint192 key\\n    ) external view returns (uint256 nonce);\\n\\n    /**\\n     * Manually increment the nonce of the sender.\\n     * This method is exposed just for completeness..\\n     * Account does NOT need to call it, neither during validation, nor elsewhere,\\n     * as the EntryPoint will update the nonce regardless.\\n     * Possible use-case is call it with various keys to \\\"initialize\\\" their nonces to one, so that future\\n     * UserOperations will not pay extra for the first transaction with a given key.\\n     */\\n    function incrementNonce(uint192 key) external;\\n}\\n\",\"keccak256\":\"0xce478ad0fa0d18a3b785ac854623029e7ab463d05873dfaa365abfa1bf100912\",\"license\":\"GPL-3.0\"},\"contracts/aa-4337/interfaces/IStakeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.12;\\n\\n/**\\n * manage deposits and stakes.\\n * deposit is just a balance used to pay for UserOperations (either by a paymaster or an account)\\n * stake is value locked for at least \\\"unstakeDelay\\\" by the staked entity.\\n */\\ninterface IStakeManager {\\n    event Deposited(address indexed account, uint256 totalDeposit);\\n\\n    event Withdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /// Emitted when stake or unstake delay are modified\\n    event StakeLocked(\\n        address indexed account,\\n        uint256 totalStaked,\\n        uint256 unstakeDelaySec\\n    );\\n\\n    /// Emitted once a stake is scheduled for withdrawal\\n    event StakeUnlocked(address indexed account, uint256 withdrawTime);\\n\\n    event StakeWithdrawn(\\n        address indexed account,\\n        address withdrawAddress,\\n        uint256 amount\\n    );\\n\\n    /**\\n     * @param deposit the entity's deposit\\n     * @param staked true if this entity is staked.\\n     * @param stake actual amount of ether staked for this entity.\\n     * @param unstakeDelaySec minimum delay to withdraw the stake.\\n     * @param withdrawTime - first block timestamp where 'withdrawStake' will be callable, or zero if already locked\\n     * @dev sizes were chosen so that (deposit,staked, stake) fit into one cell (used during handleOps)\\n     *    and the rest fit into a 2nd cell.\\n     *    112 bit allows for 10^15 eth\\n     *    48 bit for full timestamp\\n     *    32 bit allows 150 years for unstake delay\\n     */\\n    struct DepositInfo {\\n        uint112 deposit;\\n        bool staked;\\n        uint112 stake;\\n        uint32 unstakeDelaySec;\\n        uint48 withdrawTime;\\n    }\\n\\n    //API struct used by getStakeInfo and simulateValidation\\n    struct StakeInfo {\\n        uint256 stake;\\n        uint256 unstakeDelaySec;\\n    }\\n\\n    /// @return info - full deposit information of given account\\n    function getDepositInfo(\\n        address account\\n    ) external view returns (DepositInfo memory info);\\n\\n    /// @return the deposit (for gas payment) of the account\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * add to the deposit of the given account\\n     */\\n    function depositTo(address account) external payable;\\n\\n    /**\\n     * add to the account's stake - amount and delay\\n     * any pending unstake is first cancelled.\\n     * @param _unstakeDelaySec the new lock duration before the deposit can be withdrawn.\\n     */\\n    function addStake(uint32 _unstakeDelaySec) external payable;\\n\\n    /**\\n     * attempt to unlock the stake.\\n     * the value can be withdrawn (using withdrawStake) after the unstake delay.\\n     */\\n    function unlockStake() external;\\n\\n    /**\\n     * withdraw from the (unlocked) stake.\\n     * must first call unlockStake and wait for the unstakeDelay to pass\\n     * @param withdrawAddress the address to send withdrawn value.\\n     */\\n    function withdrawStake(address payable withdrawAddress) external;\\n\\n    /**\\n     * withdraw from the deposit.\\n     * @param withdrawAddress the address to send withdrawn value.\\n     * @param withdrawAmount the amount to withdraw.\\n     */\\n    function withdrawTo(\\n        address payable withdrawAddress,\\n        uint256 withdrawAmount\\n    ) external;\\n}\\n\",\"keccak256\":\"0xadcea606c9b7aafe6645441f2154a60f271330b0eee5292a632aa71c1672d546\",\"license\":\"GPL-3.0-only\"},\"contracts/aa-4337/interfaces/UserOperation.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\npragma solidity ^0.8.12;\\n\\n/* solhint-disable no-inline-assembly */\\n\\nimport {calldataKeccak} from \\\"../core/Helpers.sol\\\";\\n\\n/**\\n * User Operation struct\\n * @param sender the sender account of this request.\\n * @param nonce unique value the sender uses to verify it is not a replay.\\n * @param initCode if set, the account contract will be created by this constructor/\\n * @param callData the method call to execute on this account.\\n * @param callGasLimit the gas limit passed to the callData method call.\\n * @param verificationGasLimit gas used for validateUserOp and validatePaymasterUserOp.\\n * @param preVerificationGas gas not calculated by the handleOps method, but added to the gas paid. Covers batch overhead.\\n * @param maxFeePerGas same as EIP-1559 gas parameter.\\n * @param maxPriorityFeePerGas same as EIP-1559 gas parameter.\\n * @param paymasterAndData if set, this field holds the paymaster address and paymaster-specific data. the paymaster will pay for the transaction instead of the sender.\\n * @param signature sender-verified signature over the entire request, the EntryPoint address and the chain ID.\\n */\\nstruct UserOperation {\\n    address sender;\\n    uint256 nonce;\\n    bytes initCode;\\n    bytes callData;\\n    uint256 callGasLimit;\\n    uint256 verificationGasLimit;\\n    uint256 preVerificationGas;\\n    uint256 maxFeePerGas;\\n    uint256 maxPriorityFeePerGas;\\n    bytes paymasterAndData;\\n    bytes signature;\\n}\\n\\n/**\\n * Utility functions helpful when working with UserOperation structs.\\n */\\nlibrary UserOperationLib {\\n    function getSender(\\n        UserOperation calldata userOp\\n    ) internal pure returns (address) {\\n        address data;\\n        //read sender from userOp, which is first userOp member (saves 800 gas...)\\n        assembly {\\n            data := calldataload(userOp)\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    //relayer/block builder might submit the TX with higher priorityFee, but the user should not\\n    // pay above what he signed for.\\n    function gasPrice(\\n        UserOperation calldata userOp\\n    ) internal view returns (uint256) {\\n        unchecked {\\n            uint256 maxFeePerGas = userOp.maxFeePerGas;\\n            uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n            if (maxFeePerGas == maxPriorityFeePerGas) {\\n                //legacy mode (for networks that don't support basefee opcode)\\n                return maxFeePerGas;\\n            }\\n            return min(maxFeePerGas, maxPriorityFeePerGas + block.basefee);\\n        }\\n    }\\n\\n    function pack(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes memory ret) {\\n        address sender = getSender(userOp);\\n        uint256 nonce = userOp.nonce;\\n        bytes32 hashInitCode = calldataKeccak(userOp.initCode);\\n        bytes32 hashCallData = calldataKeccak(userOp.callData);\\n        uint256 callGasLimit = userOp.callGasLimit;\\n        uint256 verificationGasLimit = userOp.verificationGasLimit;\\n        uint256 preVerificationGas = userOp.preVerificationGas;\\n        uint256 maxFeePerGas = userOp.maxFeePerGas;\\n        uint256 maxPriorityFeePerGas = userOp.maxPriorityFeePerGas;\\n        bytes32 hashPaymasterAndData = calldataKeccak(userOp.paymasterAndData);\\n\\n        return\\n            abi.encode(\\n                sender,\\n                nonce,\\n                hashInitCode,\\n                hashCallData,\\n                callGasLimit,\\n                verificationGasLimit,\\n                preVerificationGas,\\n                maxFeePerGas,\\n                maxPriorityFeePerGas,\\n                hashPaymasterAndData\\n            );\\n    }\\n\\n    function hash(\\n        UserOperation calldata userOp\\n    ) internal pure returns (bytes32) {\\n        return keccak256(pack(userOp));\\n    }\\n\\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return a < b ? a : b;\\n    }\\n}\\n\",\"keccak256\":\"0x2429f5cc546bdee08c7e63858d0dda8491eaa3ab5194df884dc948c1154d2834\",\"license\":\"GPL-3.0\"},\"contracts/facets/base/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n/**\\n * @title DiamondCut Facet Interface\\n * @dev Interface for DiamondCut Facet responsible for adding/removing/replace facets in Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IDiamondCut {\\n    error DiamondCutFacet__InvalidRouteWithGuardian();\\n    error DiamondCutFacet__InvalidRouteWithoutGuardian();\\n    error DiamondCutFacet__InvalidArrayLength();\\n    error DiamondCutFacet__InsufficientApprovers();\\n    error DiamondCutFacet__InvalidApprover();\\n    error DiamondCutFacet__InvalidApproverSignature();\\n    error DiamondCutFacet__InvalidApprovalValidationPeriod();\\n    error DiamondCutFacet__CannotRevokeUnapproved();\\n    error DiamondCutFacet__LackOfOwnerApproval();\\n    error DiamondCutFacet__OwnerAlreadyApproved();\\n    error DiamondCutFacet__DuplicateApproval();\\n    error DiamondCutFacet__InvalidInitAddress();\\n\\n    event DiamondCutApproved(FacetCut[] diamondCut);\\n    event DiamondCutApprovalRevoked(FacetCut[] diamondCut);\\n\\n    event SupportsInterfaceUpdated(bytes4 interfaceId, bool _lag);\\n\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param diamondCut Contains the facet addresses and function selectors\\n    /// @param init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(\\n        FacetCut[] calldata diamondCut,\\n        address init,\\n        bytes calldata _calldata\\n    ) external;\\n\\n    function updateSupportsInterface(bytes4 interfaceId, bool flag) external;\\n\\n    function diamondCutWithGuardian(\\n        FacetCut[] calldata diamondCut,\\n        address[] calldata approvers,\\n        bytes[] calldata signatures\\n    ) external;\\n\\n    function approveDiamondCut(FacetCut[] calldata diamondCut) external;\\n\\n    function revokeDiamondCutApproval(FacetCut[] calldata diamondCut) external;\\n\\n    function getDiamondCutApprovalCountWithTimeValidity(\\n        bytes32 diamondCutHash\\n    ) external view returns (uint256);\\n\\n    function getOwnerCutApprovalWithTimeValidity(\\n        bytes32 diamondCutHash\\n    ) external view returns (bool);\\n\\n    function isCutApproved(\\n        bytes32 diamondCutHash,\\n        address approver\\n    ) external view returns (bool);\\n\\n    function getDiamondCutHash(\\n        FacetCut[] calldata diamondCut\\n    ) external view returns (bytes32);\\n\\n    function getDiamondCutNonce() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0x8514213c7677c2122bda0721870b08decaddb68841cb1d6a87b89b04e8f43e1e\",\"license\":\"Apache-2.0\"},\"contracts/facets/base/interfaces/IDiamondLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\n// A loupe is a small magnifying glass used to look at diamonds.\\n// These functions look at diamonds\\ninterface IDiamondLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    struct Facet {\\n        address facetAddress;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facets() external view returns (Facet[] memory facets_);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    /// @return facetFunctionSelectors_\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view returns (bytes4[] memory facetFunctionSelectors_);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    /// @return facetAddresses_\\n    function facetAddresses()\\n        external\\n        view\\n        returns (address[] memory facetAddresses_);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    /// @return facetAddress_ The facet address.\\n    function facetAddress(\\n        bytes4 _functionSelector\\n    ) external view returns (address facetAddress_);\\n}\\n\",\"keccak256\":\"0xd84f7fbb1344f714bceab2c71e4a25a235e3c1457fe7eba6c5538cd95ef5fc0f\",\"license\":\"Apache-2.0\"},\"contracts/facets/base/interfaces/IStorageLoupe.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {IDiamondLoupe} from \\\"./IDiamondLoupe.sol\\\";\\n\\n/**\\n * @title LoupeFromStorage Interface\\n * @dev Interface contract to function as a loupe facet directly attached to diamond storage of Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IStorageLoupe {\\n    /// These functions are expected to be called frequently\\n    /// by tools.\\n\\n    /// @notice Gets all facet addresses and their four byte function selectors.\\n    /// @return facets_ Facet\\n    function facetsFromStorage()\\n        external\\n        view\\n        returns (IDiamondLoupe.Facet[] memory);\\n\\n    /// @notice Gets all the function selectors supported by a specific facet.\\n    /// @param _facet The facet address.\\n    function facetFunctionSelectorsFromStorage(\\n        address _facet\\n    ) external view returns (bytes4[] memory);\\n\\n    /// @notice Get all the facet addresses used by a diamond.\\n    function facetAddressesFromStorage()\\n        external\\n        view\\n        returns (address[] memory);\\n\\n    /// @notice Gets the facet that supports the given selector.\\n    /// @dev If facet is not found return address(0).\\n    /// @param _functionSelector The function selector.\\n    function facetAddressFromStorage(\\n        bytes4 _functionSelector\\n    ) external view returns (address);\\n}\\n\",\"keccak256\":\"0xdf5dc9c57319e9087628c9cf9404b4f75585b76d1c2f4f59ee796c933967ea5c\",\"license\":\"Apache-2.0\"},\"contracts/facets/interfaces/IAccountFacet.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {IEntryPoint} from \\\"../../aa-4337/interfaces/IEntryPoint.sol\\\";\\n\\n/**\\n * @title Account Facet Interface\\n * @dev Interface of module contract that provides the account features and init/unitialization of signer\\n *      compatible with EIP-1271 & EIP-4337\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ninterface IAccountFacet {\\n    event AccountInitialized(\\n        IEntryPoint indexed entryPoint,\\n        bytes indexed ownerPublicKey\\n    );\\n    // NOTE: Added Below Event\\n    event VerificationSuccess(bytes32);\\n    event VerificationFailure(bytes32);\\n\\n    error AccountFacet__InitializationFailure();\\n    error AccountFacet__RestrictionsFailure();\\n    error AccountFacet__NonExistentVerificationFacet();\\n    error AccountFacet__CallNotSuccessful();\\n    error AccountFacet__InvalidArrayLength();\\n\\n    function initialize(\\n        address verificationFacet,\\n        address anEntryPoint,\\n        address facetRegistry,\\n        address _defaultFallBack,\\n        bytes calldata _ownerPublicKey\\n    ) external returns (uint256);\\n\\n    function execute(address dest, uint256 value, bytes calldata func) external;\\n\\n    function executeBatch(\\n        address[] calldata dest,\\n        uint256[] calldata value,\\n        bytes[] calldata func\\n    ) external;\\n}\\n\",\"keccak256\":\"0x74a9cb0b8f2f4a5148e366a401a0354426c536c012c025025d07cc25a4cd5382\",\"license\":\"Apache-2.0\"},\"contracts/infrastructure/DefaultFallbackHandler.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {IERC721Receiver} from \\\"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\\\";\\nimport {IERC1155Receiver} from \\\"@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol\\\";\\nimport {IERC777Recipient} from \\\"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\\\";\\nimport {BaseAccount} from \\\"../aa-4337/core/BaseAccount.sol\\\";\\nimport {DefaultLibDiamond} from \\\"../libraries/DefaultLibDiamond.sol\\\";\\nimport {IDiamondCut} from \\\"../facets/base/interfaces/IDiamondCut.sol\\\";\\nimport {IAccountFacet} from \\\"../facets/interfaces/IAccountFacet.sol\\\";\\nimport {IStorageLoupe} from \\\"../facets/base/interfaces/IStorageLoupe.sol\\\";\\nimport {IDiamondLoupe} from \\\"../facets/base/interfaces/IDiamondLoupe.sol\\\";\\nimport {IERC677Receiver} from \\\"../interfaces/ERC/IERC677Receiver.sol\\\";\\nimport {IERC165} from \\\"../interfaces/ERC/IERC165.sol\\\";\\n\\n/**\\n * @title DefaultFallbackHandler\\n * @dev A default fallback handler for Barz\\n * @author David Yongjun Kim (@Powerstream3604)\\n */\\ncontract DefaultFallbackHandler is IDiamondLoupe {\\n    /**\\n     * @notice Sets the middleware diamond for Barz wallet as a fallback handler\\n     * @dev This contract is also a diamond that holds the default facets to reduce gas cost for wallet activation.\\n     *      Within the constructor this conducts diamond cut to initially setup the diamond. This is a non-upgradeable contract\\n     * @param _diamondCutFacet Address if diamond cut facet\\n     * @param _accountFacet Address account facet\\n     * @param _tokenReceiverFacet Address of token receiver facet\\n     * @param _diamondLoupeFacet Address of diamond loupe facet\\n     */\\n    constructor(\\n        address _diamondCutFacet,\\n        address _accountFacet,\\n        address _tokenReceiverFacet,\\n        address _diamondLoupeFacet\\n    ) payable {\\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](4);\\n        bytes4[] memory functionSelectors = new bytes4[](1);\\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\\n\\n        bytes4[] memory accountFunctionSelectors = new bytes4[](5);\\n        accountFunctionSelectors[0] = IAccountFacet.execute.selector;\\n        accountFunctionSelectors[1] = IAccountFacet.executeBatch.selector;\\n        accountFunctionSelectors[2] = BaseAccount.validateUserOp.selector;\\n        accountFunctionSelectors[3] = BaseAccount.getNonce.selector;\\n        accountFunctionSelectors[4] = BaseAccount.entryPoint.selector;\\n\\n        bytes4[] memory receiverFacetSelectors = new bytes4[](5);\\n        receiverFacetSelectors[0] = IERC721Receiver.onERC721Received.selector;\\n        receiverFacetSelectors[1] = IERC1155Receiver.onERC1155Received.selector;\\n        receiverFacetSelectors[2] = IERC1155Receiver\\n            .onERC1155BatchReceived\\n            .selector;\\n        receiverFacetSelectors[3] = IERC777Recipient.tokensReceived.selector;\\n        receiverFacetSelectors[4] = IERC677Receiver.onTokenTransfer.selector;\\n\\n        bytes4[] memory loupeFacetSelectors = new bytes4[](9);\\n        loupeFacetSelectors[0] = IDiamondLoupe.facets.selector;\\n        loupeFacetSelectors[1] = IDiamondLoupe.facetFunctionSelectors.selector;\\n        loupeFacetSelectors[2] = IDiamondLoupe.facetAddresses.selector;\\n        loupeFacetSelectors[3] = IDiamondLoupe.facetAddress.selector;\\n        loupeFacetSelectors[4] = IERC165.supportsInterface.selector;\\n        loupeFacetSelectors[5] = IStorageLoupe.facetsFromStorage.selector;\\n        loupeFacetSelectors[6] = IStorageLoupe\\n            .facetFunctionSelectorsFromStorage\\n            .selector;\\n        loupeFacetSelectors[7] = IStorageLoupe\\n            .facetAddressesFromStorage\\n            .selector;\\n        loupeFacetSelectors[8] = IStorageLoupe.facetAddressFromStorage.selector;\\n\\n        {\\n            cut[0] = IDiamondCut.FacetCut({\\n                facetAddress: _diamondCutFacet,\\n                action: IDiamondCut.FacetCutAction.Add,\\n                functionSelectors: functionSelectors\\n            });\\n            cut[1] = IDiamondCut.FacetCut({\\n                facetAddress: _accountFacet,\\n                action: IDiamondCut.FacetCutAction.Add,\\n                functionSelectors: accountFunctionSelectors\\n            });\\n            cut[2] = IDiamondCut.FacetCut({\\n                facetAddress: _tokenReceiverFacet,\\n                action: IDiamondCut.FacetCutAction.Add,\\n                functionSelectors: receiverFacetSelectors\\n            });\\n            cut[3] = IDiamondCut.FacetCut({\\n                facetAddress: _diamondLoupeFacet,\\n                action: IDiamondCut.FacetCutAction.Add,\\n                functionSelectors: loupeFacetSelectors\\n            });\\n\\n            DefaultLibDiamond.diamondCut(cut, address(0), \\\"\\\");\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns the facet information of call facets registered to this diamond.\\n     * @return facets_ The facet struct array including all facet information\\n     */\\n    function facets() external view override returns (Facet[] memory facets_) {\\n        DefaultLibDiamond.DiamondStorage storage ds = DefaultLibDiamond\\n            .diamondStorage();\\n        uint256 numFacets = ds.facetAddresses.length;\\n        facets_ = new Facet[](numFacets);\\n        for (uint256 i; i < numFacets; ) {\\n            address facetAddress_ = ds.facetAddresses[i];\\n            facets_[i].facetAddress = facetAddress_;\\n            facets_[i].functionSelectors = ds\\n                .facetFunctionSelectors[facetAddress_]\\n                .functionSelectors;\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    /**\\n     * @notice Gets all the function selectors provided by a facet.\\n     * @param _facet The facet address.\\n     * @return facetFunctionSelectors_\\n     */\\n    function facetFunctionSelectors(\\n        address _facet\\n    ) external view override returns (bytes4[] memory facetFunctionSelectors_) {\\n        facetFunctionSelectors_ = DefaultLibDiamond\\n            .diamondStorage()\\n            .facetFunctionSelectors[_facet]\\n            .functionSelectors;\\n    }\\n\\n    /**\\n     * @notice Get all the facet addresses used by a diamond.\\n     * @return facetAddresses_\\n     */\\n    function facetAddresses()\\n        external\\n        view\\n        override\\n        returns (address[] memory facetAddresses_)\\n    {\\n        facetAddresses_ = DefaultLibDiamond.diamondStorage().facetAddresses;\\n    }\\n\\n    /** @notice Gets the facet that supports the given selector.\\n     * @dev If facet is not found return address(0).\\n     * @param _functionSelector The function selector.\\n     * @return facetAddress_ The facet address.\\n     */\\n    function facetAddress(\\n        bytes4 _functionSelector\\n    ) external view override returns (address facetAddress_) {\\n        facetAddress_ = DefaultLibDiamond\\n            .diamondStorage()\\n            .selectorToFacetAndPosition[_functionSelector]\\n            .facetAddress;\\n    }\\n}\\n\",\"keccak256\":\"0xa482fe778481e34e9fb3c4074231f8048437e934c0ca9a0c78e8e61d3a24470a\",\"license\":\"Apache-2.0\"},\"contracts/interfaces/ERC/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.21;\\n\\ninterface IERC165 {\\n    /// @notice Query if a contract implements an interface\\n    /// @param interfaceId The interface identifier, as specified in ERC-165\\n    /// @dev Interface identification is specified in ERC-165. This function\\n    ///  uses less than 30,000 gas.\\n    /// @return `true` if the contract implements `interfaceID` and\\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xbb7f07e170898793c5535cc4b7e8944c4b990a631ac806d0b788e794abc788a3\",\"license\":\"MIT\"},\"contracts/interfaces/ERC/IERC677Receiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\ninterface IERC677Receiver {\\n    function onTokenTransfer(\\n        address sender,\\n        uint value,\\n        bytes calldata data\\n    ) external pure returns (bool);\\n}\\n\",\"keccak256\":\"0x4c1631cf45ea6daac0ec158c3edb9453099130b6b64f697004b83f95aa1f7350\",\"license\":\"Apache-2.0\"},\"contracts/libraries/DefaultLibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: Apache-2.0\\npragma solidity 0.8.21;\\n\\nimport {IDiamondCut} from \\\"../facets/base/interfaces/IDiamondCut.sol\\\";\\n\\nerror InitializationFunctionReverted(\\n    address _initializationContractAddress,\\n    bytes _calldata\\n);\\n\\nlibrary DefaultLibDiamond {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"trustwallet.barz.diamond.storage\\\");\\n\\n    struct FacetAddressAndPosition {\\n        address facetAddress;\\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\\n    }\\n\\n    struct FacetFunctionSelectors {\\n        bytes4[] functionSelectors;\\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\\n    }\\n\\n    struct DiamondStorage {\\n        // maps function selector to the facet address and\\n        // the position of the selector in the facetFunctionSelectors.selectors array\\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\\n        // maps facet addresses to function selectors\\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\\n        // facet addresses\\n        address[] facetAddresses;\\n        // Used to query if a contract implements an interface.\\n        // Used to implement ERC-165.\\n        mapping(bytes4 => bool) supportedInterfaces;\\n    }\\n\\n    function diamondStorage()\\n        internal\\n        pure\\n        returns (DiamondStorage storage ds)\\n    {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    event DiamondCut(\\n        IDiamondCut.FacetCut[] _diamondCut,\\n        address _init,\\n        bytes _calldata\\n    );\\n\\n    // Internal function version of diamondCut\\n    function diamondCut(\\n        IDiamondCut.FacetCut[] memory _diamondCut,\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        for (\\n            uint256 facetIndex;\\n            facetIndex < _diamondCut.length;\\n            facetIndex++\\n        ) {\\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\\n            if (action == IDiamondCut.FacetCutAction.Add) {\\n                addFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\\n                replaceFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\\n                removeFunctions(\\n                    _diamondCut[facetIndex].facetAddress,\\n                    _diamondCut[facetIndex].functionSelectors\\n                );\\n            } else {\\n                revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n            }\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        uint256 funcSelectorsLength = _functionSelectors.length;\\n        require(\\n            funcSelectorsLength > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Add facet can't be address(0)\\\"\\n        );\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < funcSelectorsLength;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress == address(0),\\n                \\\"LibDiamondCut: Can't add function that already exists\\\"\\n            );\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function replaceFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        uint256 funcSelectorsLength = _functionSelectors.length;\\n        require(\\n            funcSelectorsLength > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Replace facet can't be address(0)\\\"\\n        );\\n        uint96 selectorPosition = uint96(\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors.length\\n        );\\n        // add new facet address if it does not exist\\n        if (selectorPosition == 0) {\\n            addFacet(ds, _facetAddress);\\n        }\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < funcSelectorsLength;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            require(\\n                oldFacetAddress != _facetAddress,\\n                \\\"LibDiamondCut: Can't replace function with same facet\\\"\\n            );\\n            removeFunction(ds, oldFacetAddress, selector);\\n            addFunction(ds, selector, selectorPosition, _facetAddress);\\n            selectorPosition++;\\n        }\\n    }\\n\\n    function removeFunctions(\\n        address _facetAddress,\\n        bytes4[] memory _functionSelectors\\n    ) internal {\\n        uint256 funcSelectorsLength = _functionSelectors.length;\\n        require(\\n            funcSelectorsLength > 0,\\n            \\\"LibDiamondCut: No selectors in facet to cut\\\"\\n        );\\n        DiamondStorage storage ds = diamondStorage();\\n        // if function does not exist then do nothing and return\\n        require(\\n            _facetAddress == address(0),\\n            \\\"LibDiamondCut: Remove facet address must be address(0)\\\"\\n        );\\n        for (\\n            uint256 selectorIndex;\\n            selectorIndex < funcSelectorsLength;\\n            selectorIndex++\\n        ) {\\n            bytes4 selector = _functionSelectors[selectorIndex];\\n            address oldFacetAddress = ds\\n                .selectorToFacetAndPosition[selector]\\n                .facetAddress;\\n            removeFunction(ds, oldFacetAddress, selector);\\n        }\\n    }\\n\\n    function addFacet(\\n        DiamondStorage storage ds,\\n        address _facetAddress\\n    ) internal {\\n        enforceHasContractCode(\\n            _facetAddress,\\n            \\\"LibDiamondCut: New facet has no code\\\"\\n        );\\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds\\n            .facetAddresses\\n            .length;\\n        ds.facetAddresses.push(_facetAddress);\\n    }\\n\\n    function addFunction(\\n        DiamondStorage storage ds,\\n        bytes4 _selector,\\n        uint96 _selectorPosition,\\n        address _facetAddress\\n    ) internal {\\n        ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition = _selectorPosition;\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(\\n            _selector\\n        );\\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\\n    }\\n\\n    function removeFunction(\\n        DiamondStorage storage ds,\\n        address _facetAddress,\\n        bytes4 _selector\\n    ) internal {\\n        require(\\n            _facetAddress != address(0),\\n            \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n        );\\n        // an immutable function is a function defined directly in a diamond\\n        require(\\n            _facetAddress != address(this),\\n            \\\"LibDiamondCut: Can't remove immutable function\\\"\\n        );\\n        // replace selector with last selector, then delete last selector\\n        uint256 selectorPosition = ds\\n            .selectorToFacetAndPosition[_selector]\\n            .functionSelectorPosition;\\n        uint256 lastSelectorPosition = ds\\n            .facetFunctionSelectors[_facetAddress]\\n            .functionSelectors\\n            .length - 1;\\n        // if not the same then replace _selector with lastSelector\\n        if (selectorPosition != lastSelectorPosition) {\\n            bytes4 lastSelector = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .functionSelectors[lastSelectorPosition];\\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[\\n                selectorPosition\\n            ] = lastSelector;\\n            ds\\n                .selectorToFacetAndPosition[lastSelector]\\n                .functionSelectorPosition = uint96(selectorPosition);\\n        }\\n        // delete the last selector\\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\\n        delete ds.selectorToFacetAndPosition[_selector];\\n\\n        // if no more selectors for facet address then delete the facet address\\n        if (lastSelectorPosition == 0) {\\n            // replace facet address with last facet address and delete last facet address\\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\\n            uint256 facetAddressPosition = ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n            if (facetAddressPosition != lastFacetAddressPosition) {\\n                address lastFacetAddress = ds.facetAddresses[\\n                    lastFacetAddressPosition\\n                ];\\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\\n                ds\\n                    .facetFunctionSelectors[lastFacetAddress]\\n                    .facetAddressPosition = facetAddressPosition;\\n            }\\n            ds.facetAddresses.pop();\\n            delete ds\\n                .facetFunctionSelectors[_facetAddress]\\n                .facetAddressPosition;\\n        }\\n    }\\n\\n    function initializeDiamondCut(\\n        address _init,\\n        bytes memory _calldata\\n    ) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(\\n            _init,\\n            \\\"LibDiamondCut: _init address has no code\\\"\\n        );\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(\\n        address _contract,\\n        string memory _errorMessage\\n    ) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0x1b08f332d62919288bb1f0d154ca4b85f4e167d2a06e680f8ec93dba65be3be1\",\"license\":\"Apache-2.0\"}},\"version\":1}",
  "bytecode": "0x6080604052604051620020183803806200201883398101604081905262000026916200156b565b60408051600480825260a08201909252600091816020015b604080516060808201835260008083526020830152918101919091528152602001906001900390816200003e5750506040805160018082528183019092529192506000919060208083019080368337019050509050631f931c1c60e01b81600081518110620000b157620000b1620015c8565b6001600160e01b03199290921660209283029190910182015260408051600580825260c08201909252600092909190820160a08036833701905050905063b61d27f660e01b816000815181106200010c576200010c620015c8565b6001600160e01b03199092166020928302919091019091015280516323f0ed1560e11b9082906001908110620001465762000146620015c8565b6001600160e01b0319909216602092830291909101909101528051633a871cdd60e01b9082906002908110620001805762000180620015c8565b6001600160e01b0319909216602092830291909101909101528051631a10fa5160e31b9082906003908110620001ba57620001ba620015c8565b6001600160e01b031990921660209283029190910190910152805163586b48ff60e11b9082906004908110620001f457620001f4620015c8565b6001600160e01b03199290921660209283029190910182015260408051600580825260c08201909252600092909190820160a08036833701905050905063150b7a0260e01b816000815181106200024f576200024f620015c8565b6001600160e01b031990921660209283029190910190910152805163f23a6e6160e01b9082906001908110620002895762000289620015c8565b6001600160e01b031990921660209283029190910190910152805163bc197c8160e01b9082906002908110620002c357620002c3620015c8565b6001600160e01b03199092166020928302919091019091015280516223de2960e01b9082906003908110620002fc57620002fc620015c8565b6001600160e01b0319909216602092830291909101909101528051635260769b60e11b9082906004908110620003365762000336620015c8565b6001600160e01b0319929092166020928302919091018201526040805160098082526101408201909252600092909190820161012080368337019050509050637a0ed62760e01b81600081518110620003935762000393620015c8565b6001600160e01b03199092166020928302919091019091015280516356fe50af60e11b9082906001908110620003cd57620003cd620015c8565b6001600160e01b03199092166020928302919091019091015280516314bbdacb60e21b9082906002908110620004075762000407620015c8565b6001600160e01b03199092166020928302919091019091015280516366ffd66360e11b9082906003908110620004415762000441620015c8565b6001600160e01b03199092166020928302919091019091015280516301ffc9a760e01b90829060049081106200047b576200047b620015c8565b6001600160e01b031990921660209283029190910190910152805163f9796ccf60e01b9082906005908110620004b557620004b5620015c8565b6001600160e01b031990921660209283029190910190910152805162d2a81160e11b9082906006908110620004ee57620004ee620015c8565b6001600160e01b031990921660209283029190910190910152805163d42139a960e01b9082906007908110620005285762000528620015c8565b6001600160e01b03199092166020928302919091019091015280516371d17b7f60e11b9082906008908110620005625762000562620015c8565b6001600160e01b031990921660209283029190910182015260408051606081019091526001600160a01b038b168152908101600081526020018581525085600081518110620005b557620005b5620015c8565b60200260200101819052506040518060600160405280896001600160a01b0316815260200160006002811115620005f057620005f0620015de565b815260200184815250856001815181106200060f576200060f620015c8565b60200260200101819052506040518060600160405280886001600160a01b03168152602001600060028111156200064a576200064a620015de565b81526020018381525085600281518110620006695762000669620015c8565b60200260200101819052506040518060600160405280876001600160a01b0316815260200160006002811115620006a457620006a4620015de565b81526020018281525085600381518110620006c357620006c3620015c8565b6020026020010181905250620006f1856000604051806020016040528060008152506200070060201b60201c565b5050505050505050506200184c565b60005b83518110156200090c576000848281518110620007245762000724620015c8565b602002602001015160200151905060006002811115620007485762000748620015de565b8160028111156200075d576200075d620015de565b03620007bb57620007b58583815181106200077c576200077c620015c8565b6020026020010151600001518684815181106200079d576200079d620015c8565b6020026020010151604001516200095b60201b60201c565b620008f6565b6001816002811115620007d257620007d2620015de565b036200082a57620007b5858381518110620007f157620007f1620015c8565b602002602001015160000151868481518110620008125762000812620015c8565b60200260200101516040015162000bf760201b60201c565b6002816002811115620008415762000841620015de565b036200089957620007b5858381518110620008605762000860620015c8565b602002602001015160000151868481518110620008815762000881620015c8565b60200260200101516040015162000ea160201b60201c565b60405162461bcd60e51b815260206004820152602760248201527f4c69624469616d6f6e644375743a20496e636f727265637420466163657443756044820152663a20b1ba34b7b760c91b60648201526084015b60405180910390fd5b508062000903816200160a565b91505062000703565b507f8faa70878671ccd212d20771b795c50af8fd3ff6cf27f4bde57e5d4de0aeb67383838360405162000942939291906200167a565b60405180910390a162000956828262001005565b505050565b805180620009af5760405162461bcd60e51b815260206004820152602b602482015260008051602062001ff883398151915260448201526a1858d95d081d1bc818dd5d60aa1b6064820152608401620008ed565b60008051602062001f8c8339815191526001600160a01b03841662000a2c5760405162461bcd60e51b815260206004820152602c60248201527f4c69624469616d6f6e644375743a204164642066616365742063616e2774206260448201526b65206164647265737328302960a01b6064820152608401620008ed565b6001600160a01b0384166000908152600182016020526040812054906001600160601b038216900362000a655762000a658286620010dd565b60005b8381101562000bef57600085828151811062000a885762000a88620015c8565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b0316801562000b305760405162461bcd60e51b815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774206164642066756e6374696f60448201527f6e207468617420616c72656164792065786973747300000000000000000000006064820152608401620008ed565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6001600160601b038c16021782558d168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c94909402939093179092559390925287905281546001600160a01b0319161790558362000bd48162001781565b9450505050808062000be6906200160a565b91505062000a68565b505050505050565b80518062000c4b5760405162461bcd60e51b815260206004820152602b602482015260008051602062001ff883398151915260448201526a1858d95d081d1bc818dd5d60aa1b6064820152608401620008ed565b60008051602062001f8c8339815191526001600160a01b03841662000ccc5760405162461bcd60e51b815260206004820152603060248201527f4c69624469616d6f6e644375743a205265706c6163652066616365742063616e60448201526f2774206265206164647265737328302960801b6064820152608401620008ed565b6001600160a01b0384166000908152600182016020526040812054906001600160601b038216900362000d055762000d058286620010dd565b60005b8381101562000bef57600085828151811062000d285762000d28620015c8565b6020908102919091018101516001600160e01b031981166000908152918690526040909120549091506001600160a01b03908116908816810362000dd55760405162461bcd60e51b815260206004820152603560248201527f4c69624469616d6f6e644375743a2043616e2774207265706c6163652066756e60448201527f6374696f6e20776974682073616d6520666163657400000000000000000000006064820152608401620008ed565b62000de28582846200114a565b6001600160e01b0319821660008181526020878152604080832080546001600160a01b03908116600160a01b6001600160601b038c16021782558d168085526001808c0185529285208054938401815585528385206008840401805463ffffffff60079095166004026101000a948502191660e08a901c94909402939093179092559390925287905281546001600160a01b0319161790558362000e868162001781565b9450505050808062000e98906200160a565b91505062000d08565b80518062000ef55760405162461bcd60e51b815260206004820152602b602482015260008051602062001ff883398151915260448201526a1858d95d081d1bc818dd5d60aa1b6064820152608401620008ed565b60008051602062001f8c8339815191526001600160a01b0384161562000f845760405162461bcd60e51b815260206004820152603660248201527f4c69624469616d6f6e644375743a2052656d6f7665206661636574206164647260448201527f657373206d7573742062652061646472657373283029000000000000000000006064820152608401620008ed565b60005b8281101562000ffe57600084828151811062000fa75762000fa7620015c8565b6020908102919091018101516001600160e01b031981166000908152918590526040909120549091506001600160a01b031662000fe68482846200114a565b5050808062000ff5906200160a565b91505062000f87565b5050505050565b6001600160a01b03821662001018575050565b6200103d8260405180606001604052806028815260200162001fac602891396200152a565b600080836001600160a01b0316836040516200105a9190620017b2565b600060405180830381855af49150503d806000811462001097576040519150601f19603f3d011682016040523d82523d6000602084013e6200109c565b606091505b509150915081620010d757805115620010b85780518082602001fd5b838360405163192105d760e01b8152600401620008ed929190620017d0565b50505050565b620011028160405180606001604052806024815260200162001fd4602491396200152a565b6002820180546001600160a01b0390921660008181526001948501602090815260408220860185905594840183559182529290200180546001600160a01b0319169091179055565b6001600160a01b038216620011c85760405162461bcd60e51b815260206004820152603760248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f76652066756e6360448201527f74696f6e207468617420646f65736e27742065786973740000000000000000006064820152608401620008ed565b306001600160a01b03831603620012395760405162461bcd60e51b815260206004820152602e60248201527f4c69624469616d6f6e644375743a2043616e27742072656d6f766520696d6d7560448201526d3a30b1363290333ab731ba34b7b760911b6064820152608401620008ed565b6001600160e01b03198116600090815260208481526040808320546001600160a01b0386168452600180880190935290832054600160a01b9091046001600160601b031692916200128a91620017fe565b905080821462001383576001600160a01b03841660009081526001860160205260408120805483908110620012c357620012c3620015c8565b600091825260208083206008830401546001600160a01b038916845260018a019091526040909220805460079092166004026101000a90920460e01b925082919085908110620013175762001317620015c8565b600091825260208083206008830401805463ffffffff60079094166004026101000a938402191660e09590951c929092029390931790556001600160e01b03199290921682528690526040902080546001600160a01b0316600160a01b6001600160601b038516021790555b6001600160a01b03841660009081526001860160205260409020805480620013af57620013af6200181a565b60008281526020808220600860001990940193840401805463ffffffff600460078716026101000a0219169055919092556001600160e01b0319851682528690526040812081905581900362000ffe5760028501546000906200141590600190620017fe565b6001600160a01b0386166000908152600180890160205260409091200154909150808214620014cb576000876002018381548110620014585762001458620015c8565b6000918252602090912001546002890180546001600160a01b0390921692508291849081106200148c576200148c620015c8565b600091825260208083209190910180546001600160a01b0319166001600160a01b03948516179055929091168152600189810190925260409020018190555b86600201805480620014e157620014e16200181a565b60008281526020808220830160001990810180546001600160a01b03191690559092019092556001600160a01b0388168252600189810190915260408220015550505050505050565b813b8181620010d75760405162461bcd60e51b8152600401620008ed919062001830565b80516001600160a01b03811681146200156657600080fd5b919050565b600080600080608085870312156200158257600080fd5b6200158d856200154e565b93506200159d602086016200154e565b9250620015ad604086016200154e565b9150620015bd606086016200154e565b905092959194509250565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016200161f576200161f620015f4565b5060010190565b60005b838110156200164357818101518382015260200162001629565b50506000910152565b600081518084526200166681602086016020860162001626565b601f01601f19169290920160200192915050565b60006060808301818452808751808352608092508286019150828160051b8701016020808b0160005b848110156200174f57898403607f19018652815180516001600160a01b03168552838101518986019060038110620016eb57634e487b7160e01b600052602160045260246000fd5b868601526040918201519186018a905281519081905290840190600090898701905b80831015620017395783516001600160e01b03191682529286019260019290920191908601906200170d565b50978501979550505090820190600101620016a3565b50506001600160a01b038a169088015286810360408801526200177381896200164c565b9a9950505050505050505050565b60006001600160601b038281166002600160601b03198101620017a857620017a8620015f4565b6001019392505050565b60008251620017c681846020870162001626565b9190910192915050565b6001600160a01b0383168152604060208201819052600090620017f6908301846200164c565b949350505050565b81810381811115620018145762001814620015f4565b92915050565b634e487b7160e01b600052603160045260246000fd5b6020815260006200184560208301846200164c565b9392505050565b610730806200185c6000396000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc6146100a4575b600080fd5b610059610140565b60405161006691906104ab565b60405180910390f35b6100776101d1565b6040516100669190610562565b61009761009236600461060a565b6103d1565b6040516100669190610647565b61011b6100b236600461065a565b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610066565b60607f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f6002018054806020026020016040519081016040528092919081815260200182805480156101c757602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161019c575b5050505050905090565b7f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4921546060907f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f908067ffffffffffffffff8111156102315761023161069c565b60405190808252806020026020018201604052801561027757816020015b60408051808201909152600081526060602082015281526020019060019003908161024f5790505b50925060005b818110156103cb57600083600201828154811061029c5761029c6106cb565b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050808583815181106102dc576102dc6106cb565b60209081029190910181015173ffffffffffffffffffffffffffffffffffffffff928316905290821660009081526001860182526040908190208054825181850281018501909352808352919290919083018282801561039d57602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161034a5790505b50505050508583815181106103b4576103b46106cb565b60209081029190910181015101525060010161027d565b50505090565b73ffffffffffffffffffffffffffffffffffffffff811660009081527f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4920602090815260409182902080548351818402810184019094528084526060939283018282801561049f57602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161044c5790505b50505050509050919050565b6020808252825182820181905260009190848201906040850190845b818110156104f957835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016104c7565b50909695505050505050565b600081518084526020808501945080840160005b838110156105575781517fffffffff000000000000000000000000000000000000000000000000000000001687529582019590820190600101610519565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b838110156105fc578883037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00185528151805173ffffffffffffffffffffffffffffffffffffffff1684528701518784018790526105e987850182610505565b9588019593505090860190600101610589565b509098975050505050505050565b60006020828403121561061c57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461064057600080fd5b9392505050565b6020815260006106406020830184610505565b60006020828403121561066c57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461064057600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea264697066735822122024a872696a5ad50024326567061c50adea63ff0d49edf0ac60339459d33d571664736f6c63430008150033183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f4c69624469616d6f6e644375743a205f696e6974206164647265737320686173206e6f20636f64654c69624469616d6f6e644375743a204e657720666163657420686173206e6f20636f64654c69624469616d6f6e644375743a204e6f2073656c6563746f727320696e2066",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c806352ef6b2c146100515780637a0ed6271461006f578063adfca15e14610084578063cdffacc6146100a4575b600080fd5b610059610140565b60405161006691906104ab565b60405180910390f35b6100776101d1565b6040516100669190610562565b61009761009236600461060a565b6103d1565b6040516100669190610647565b61011b6100b236600461065a565b7fffffffff000000000000000000000000000000000000000000000000000000001660009081527f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f602052604090205473ffffffffffffffffffffffffffffffffffffffff1690565b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610066565b60607f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f6002018054806020026020016040519081016040528092919081815260200182805480156101c757602002820191906000526020600020905b815473ffffffffffffffffffffffffffffffffffffffff16815260019091019060200180831161019c575b5050505050905090565b7f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4921546060907f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd491f908067ffffffffffffffff8111156102315761023161069c565b60405190808252806020026020018201604052801561027757816020015b60408051808201909152600081526060602082015281526020019060019003908161024f5790505b50925060005b818110156103cb57600083600201828154811061029c5761029c6106cb565b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050808583815181106102dc576102dc6106cb565b60209081029190910181015173ffffffffffffffffffffffffffffffffffffffff928316905290821660009081526001860182526040908190208054825181850281018501909352808352919290919083018282801561039d57602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161034a5790505b50505050508583815181106103b4576103b46106cb565b60209081029190910181015101525060010161027d565b50505090565b73ffffffffffffffffffffffffffffffffffffffff811660009081527f183cde5d4f6bb7b445b8fc2f7f15d0fd1d162275aded24183babbffee7cd4920602090815260409182902080548351818402810184019094528084526060939283018282801561049f57602002820191906000526020600020906000905b82829054906101000a900460e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168152602001906004019060208260030104928301926001038202915080841161044c5790505b50505050509050919050565b6020808252825182820181905260009190848201906040850190845b818110156104f957835173ffffffffffffffffffffffffffffffffffffffff16835292840192918401916001016104c7565b50909695505050505050565b600081518084526020808501945080840160005b838110156105575781517fffffffff000000000000000000000000000000000000000000000000000000001687529582019590820190600101610519565b509495945050505050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b838110156105fc578883037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc00185528151805173ffffffffffffffffffffffffffffffffffffffff1684528701518784018790526105e987850182610505565b9588019593505090860190600101610589565b509098975050505050505050565b60006020828403121561061c57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461064057600080fd5b9392505050565b6020815260006106406020830184610505565b60006020828403121561066c57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461064057600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fdfea264697066735822122024a872696a5ad50024326567061c50adea63ff0d49edf0ac60339459d33d571664736f6c63430008150033",
  "devdoc": {
    "author": "David Yongjun Kim (@Powerstream3604)",
    "details": "A default fallback handler for Barz",
    "kind": "dev",
    "methods": {
      "constructor": {
        "details": "This contract is also a diamond that holds the default facets to reduce gas cost for wallet activation.      Within the constructor this conducts diamond cut to initially setup the diamond. This is a non-upgradeable contract",
        "params": {
          "_accountFacet": "Address account facet",
          "_diamondCutFacet": "Address if diamond cut facet",
          "_diamondLoupeFacet": "Address of diamond loupe facet",
          "_tokenReceiverFacet": "Address of token receiver facet"
        }
      },
      "facetAddress(bytes4)": {
        "details": "If facet is not found return address(0).",
        "params": {
          "_functionSelector": "The function selector."
        },
        "returns": {
          "facetAddress_": "The facet address."
        }
      },
      "facetAddresses()": {
        "returns": {
          "facetAddresses_": "facetAddresses_"
        }
      },
      "facetFunctionSelectors(address)": {
        "params": {
          "_facet": "The facet address."
        },
        "returns": {
          "facetFunctionSelectors_": "facetFunctionSelectors_"
        }
      },
      "facets()": {
        "returns": {
          "facets_": "The facet struct array including all facet information"
        }
      }
    },
    "title": "DefaultFallbackHandler",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Sets the middleware diamond for Barz wallet as a fallback handler"
      },
      "facetAddress(bytes4)": {
        "notice": "Gets the facet that supports the given selector."
      },
      "facetAddresses()": {
        "notice": "Get all the facet addresses used by a diamond."
      },
      "facetFunctionSelectors(address)": {
        "notice": "Gets all the function selectors provided by a facet."
      },
      "facets()": {
        "notice": "Returns the facet information of call facets registered to this diamond."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}